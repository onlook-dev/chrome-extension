
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
(function () {
	'use strict';

	/** @returns {void} */
	function noop$3() {}

	const identity$1 = (x) => x;

	/**
	 * @template T
	 * @template S
	 * @param {T} tar
	 * @param {S} src
	 * @returns {T & S}
	 */
	function assign(tar, src) {
		// @ts-ignore
		for (const k in src) tar[k] = src[k];
		return /** @type {T & S} */ (tar);
	}

	/** @returns {void} */
	function add_location(element, file, line, column, char) {
		element.__svelte_meta = {
			loc: { file, line, column, char }
		};
	}

	function run(fn) {
		return fn();
	}

	function blank_object() {
		return Object.create(null);
	}

	/**
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function run_all(fns) {
		fns.forEach(run);
	}

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	/** @returns {boolean} */
	function safe_not_equal(a, b) {
		return a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';
	}

	/** @returns {boolean} */
	function is_empty(obj) {
		return Object.keys(obj).length === 0;
	}

	/** @returns {void} */
	function validate_store(store, name) {
		if (store != null && typeof store.subscribe !== 'function') {
			throw new Error(`'${name}' is not a store with a 'subscribe' method`);
		}
	}

	function subscribe(store, ...callbacks) {
		if (store == null) {
			for (const callback of callbacks) {
				callback(undefined);
			}
			return noop$3;
		}
		const unsub = store.subscribe(...callbacks);
		return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}

	/**
	 * Get the current value from a store by subscribing and immediately unsubscribing.
	 *
	 * https://svelte.dev/docs/svelte-store#get
	 * @template T
	 * @param {import('../store/public.js').Readable<T>} store
	 * @returns {T}
	 */
	function get_store_value(store) {
		let value;
		subscribe(store, (_) => (value = _))();
		return value;
	}

	/** @returns {void} */
	function component_subscribe(component, store, callback) {
		component.$$.on_destroy.push(subscribe(store, callback));
	}

	function create_slot(definition, ctx, $$scope, fn) {
		if (definition) {
			const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
			return definition[0](slot_ctx);
		}
	}

	function get_slot_context(definition, ctx, $$scope, fn) {
		return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
	}

	function get_slot_changes(definition, $$scope, dirty, fn) {
		if (definition[2] && fn) {
			const lets = definition[2](fn(dirty));
			if ($$scope.dirty === undefined) {
				return lets;
			}
			if (typeof lets === 'object') {
				const merged = [];
				const len = Math.max($$scope.dirty.length, lets.length);
				for (let i = 0; i < len; i += 1) {
					merged[i] = $$scope.dirty[i] | lets[i];
				}
				return merged;
			}
			return $$scope.dirty | lets;
		}
		return $$scope.dirty;
	}

	/** @returns {void} */
	function update_slot_base(
		slot,
		slot_definition,
		ctx,
		$$scope,
		slot_changes,
		get_slot_context_fn
	) {
		if (slot_changes) {
			const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
			slot.p(slot_context, slot_changes);
		}
	}

	/** @returns {any[] | -1} */
	function get_all_dirty_from_scope($$scope) {
		if ($$scope.ctx.length > 32) {
			const dirty = [];
			const length = $$scope.ctx.length / 32;
			for (let i = 0; i < length; i++) {
				dirty[i] = -1;
			}
			return dirty;
		}
		return -1;
	}

	/** @returns {{}} */
	function exclude_internal_props(props) {
		const result = {};
		for (const k in props) if (k[0] !== '$') result[k] = props[k];
		return result;
	}

	/** @returns {{}} */
	function compute_rest_props(props, keys) {
		const rest = {};
		keys = new Set(keys);
		for (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];
		return rest;
	}

	function action_destroyer(action_result) {
		return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$3;
	}

	const is_client = typeof window !== 'undefined';

	/** @type {() => number} */
	let now = is_client ? () => window.performance.now() : () => Date.now();

	let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop$3;

	const tasks = new Set();

	/**
	 * @param {number} now
	 * @returns {void}
	 */
	function run_tasks(now) {
		tasks.forEach((task) => {
			if (!task.c(now)) {
				tasks.delete(task);
				task.f();
			}
		});
		if (tasks.size !== 0) raf(run_tasks);
	}

	/**
	 * Creates a new task that runs on each raf frame
	 * until it returns a falsy value or is aborted
	 * @param {import('./private.js').TaskCallback} callback
	 * @returns {import('./private.js').Task}
	 */
	function loop(callback) {
		/** @type {import('./private.js').TaskEntry} */
		let task;
		if (tasks.size === 0) raf(run_tasks);
		return {
			promise: new Promise((fulfill) => {
				tasks.add((task = { c: callback, f: fulfill }));
			}),
			abort() {
				tasks.delete(task);
			}
		};
	}

	/** @type {typeof globalThis} */
	const globals =
		typeof window !== 'undefined'
			? window
			: typeof globalThis !== 'undefined'
			? globalThis
			: // @ts-ignore Node typings have this
			  global;

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */
	function append(target, node) {
		target.appendChild(node);
	}

	/**
	 * @param {Node} node
	 * @returns {ShadowRoot | Document}
	 */
	function get_root_for_style(node) {
		if (!node) return document;
		const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
		if (root && /** @type {ShadowRoot} */ (root).host) {
			return /** @type {ShadowRoot} */ (root);
		}
		return node.ownerDocument;
	}

	/**
	 * @param {Node} node
	 * @returns {CSSStyleSheet}
	 */
	function append_empty_stylesheet(node) {
		const style_element = element('style');
		// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,
		// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.
		// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.
		// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.
		// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.
		style_element.textContent = '/* empty */';
		append_stylesheet(get_root_for_style(node), style_element);
		return style_element.sheet;
	}

	/**
	 * @param {ShadowRoot | Document} node
	 * @param {HTMLStyleElement} style
	 * @returns {CSSStyleSheet}
	 */
	function append_stylesheet(node, style) {
		append(/** @type {Document} */ (node).head || node, style);
		return style.sheet;
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */
	function insert(target, node, anchor) {
		target.insertBefore(node, anchor || null);
	}

	/**
	 * @param {Node} node
	 * @returns {void}
	 */
	function detach(node) {
		if (node.parentNode) {
			node.parentNode.removeChild(node);
		}
	}

	/**
	 * @returns {void} */
	function destroy_each(iterations, detaching) {
		for (let i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detaching);
		}
	}

	/**
	 * @template {keyof HTMLElementTagNameMap} K
	 * @param {K} name
	 * @returns {HTMLElementTagNameMap[K]}
	 */
	function element(name) {
		return document.createElement(name);
	}

	/**
	 * @template {keyof SVGElementTagNameMap} K
	 * @param {K} name
	 * @returns {SVGElement}
	 */
	function svg_element(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	/**
	 * @param {string} data
	 * @returns {Text}
	 */
	function text(data) {
		return document.createTextNode(data);
	}

	/**
	 * @returns {Text} */
	function space() {
		return text(' ');
	}

	/**
	 * @returns {Text} */
	function empty() {
		return text('');
	}

	/**
	 * @param {EventTarget} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @returns {() => void}
	 */
	function listen(node, event, handler, options) {
		node.addEventListener(event, handler, options);
		return () => node.removeEventListener(event, handler, options);
	}

	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */
	function attr$1(node, attribute, value) {
		if (value == null) node.removeAttribute(attribute);
		else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
	}
	/**
	 * List of attributes that should always be set through the attr method,
	 * because updating them through the property setter doesn't work reliably.
	 * In the example of `width`/`height`, the problem is that the setter only
	 * accepts numeric values, but the attribute can also be set to a string like `50%`.
	 * If this list becomes too big, rethink this approach.
	 */
	const always_set_through_set_attribute = ['width', 'height'];

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {{ [x: string]: string }} attributes
	 * @returns {void}
	 */
	function set_attributes(node, attributes) {
		// @ts-ignore
		const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
		for (const key in attributes) {
			if (attributes[key] == null) {
				node.removeAttribute(key);
			} else if (key === 'style') {
				node.style.cssText = attributes[key];
			} else if (key === '__value') {
				/** @type {any} */ (node).value = node[key] = attributes[key];
			} else if (
				descriptors[key] &&
				descriptors[key].set &&
				always_set_through_set_attribute.indexOf(key) === -1
			) {
				node[key] = attributes[key];
			} else {
				attr$1(node, key, attributes[key]);
			}
		}
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {{ [x: string]: string }} attributes
	 * @returns {void}
	 */
	function set_svg_attributes(node, attributes) {
		for (const key in attributes) {
			attr$1(node, key, attributes[key]);
		}
	}

	/**
	 * @param {Record<string, unknown>} data_map
	 * @returns {void}
	 */
	function set_custom_element_data_map(node, data_map) {
		Object.keys(data_map).forEach((key) => {
			set_custom_element_data(node, key, data_map[key]);
		});
	}

	/**
	 * @returns {void} */
	function set_custom_element_data(node, prop, value) {
		const lower = prop.toLowerCase(); // for backwards compatibility with existing behavior we do lowercase first
		if (lower in node) {
			node[lower] = typeof node[lower] === 'boolean' && value === '' ? true : value;
		} else if (prop in node) {
			node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
		} else {
			attr$1(node, prop, value);
		}
	}

	/**
	 * @param {string} tag
	 */
	function set_dynamic_element_data(tag) {
		return /-/.test(tag) ? set_custom_element_data_map : set_attributes;
	}

	/**
	 * @param {Element} element
	 * @returns {ChildNode[]}
	 */
	function children(element) {
		return Array.from(element.childNodes);
	}

	/**
	 * @returns {void} */
	function set_input_value(input, value) {
		input.value = value == null ? '' : value;
	}

	/**
	 * @returns {void} */
	function select_option(select, value, mounting) {
		for (let i = 0; i < select.options.length; i += 1) {
			const option = select.options[i];
			if (option.__value === value) {
				option.selected = true;
				return;
			}
		}
		if (!mounting || value !== undefined) {
			select.selectedIndex = -1; // no option should be selected
		}
	}

	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]
	 * @returns {CustomEvent<T>}
	 */
	function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
		return new CustomEvent(type, { detail, bubbles, cancelable });
	}

	/**
	 * @typedef {Node & {
	 * 	claim_order?: number;
	 * 	hydrate_init?: true;
	 * 	actual_end_child?: NodeEx;
	 * 	childNodes: NodeListOf<NodeEx>;
	 * }} NodeEx
	 */

	/** @typedef {ChildNode & NodeEx} ChildNodeEx */

	/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */

	/**
	 * @typedef {ChildNodeEx[] & {
	 * 	claim_info?: {
	 * 		last_index: number;
	 * 		total_claimed: number;
	 * 	};
	 * }} ChildNodeArray
	 */

	// we need to store the information for multiple documents because a Svelte application could also contain iframes
	// https://github.com/sveltejs/svelte/issues/3624
	/** @type {Map<Document | ShadowRoot, import('./private.d.ts').StyleInformation>} */
	const managed_styles = new Map();

	let active$1 = 0;

	// https://github.com/darkskyapp/string-hash/blob/master/index.js
	/**
	 * @param {string} str
	 * @returns {number}
	 */
	function hash$1(str) {
		let hash = 5381;
		let i = str.length;
		while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
		return hash >>> 0;
	}

	/**
	 * @param {Document | ShadowRoot} doc
	 * @param {Element & ElementCSSInlineStyle} node
	 * @returns {{ stylesheet: any; rules: {}; }}
	 */
	function create_style_information(doc, node) {
		const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
		managed_styles.set(doc, info);
		return info;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {number} a
	 * @param {number} b
	 * @param {number} duration
	 * @param {number} delay
	 * @param {(t: number) => number} ease
	 * @param {(t: number, u: number) => string} fn
	 * @param {number} uid
	 * @returns {string}
	 */
	function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
		const step = 16.666 / duration;
		let keyframes = '{\n';
		for (let p = 0; p <= 1; p += step) {
			const t = a + (b - a) * ease(p);
			keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
		}
		const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
		const name = `__svelte_${hash$1(rule)}_${uid}`;
		const doc = get_root_for_style(node);
		const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
		if (!rules[name]) {
			rules[name] = true;
			stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
		}
		const animation = node.style.animation || '';
		node.style.animation = `${
		animation ? `${animation}, ` : ''
	}${name} ${duration}ms linear ${delay}ms 1 both`;
		active$1 += 1;
		return name;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {string} [name]
	 * @returns {void}
	 */
	function delete_rule(node, name) {
		const previous = (node.style.animation || '').split(', ');
		const next = previous.filter(
			name
				? (anim) => anim.indexOf(name) < 0 // remove specific animation
				: (anim) => anim.indexOf('__svelte') === -1 // remove all Svelte animations
		);
		const deleted = previous.length - next.length;
		if (deleted) {
			node.style.animation = next.join(', ');
			active$1 -= deleted;
			if (!active$1) clear_rules();
		}
	}

	/** @returns {void} */
	function clear_rules() {
		raf(() => {
			if (active$1) return;
			managed_styles.forEach((info) => {
				const { ownerNode } = info.stylesheet;
				// there is no ownerNode if it runs on jsdom.
				if (ownerNode) detach(ownerNode);
			});
			managed_styles.clear();
		});
	}

	let current_component;

	/** @returns {void} */
	function set_current_component(component) {
		current_component = component;
	}

	function get_current_component() {
		if (!current_component) throw new Error('Function called outside component initialization');
		return current_component;
	}

	/**
	 * Schedules a callback to run immediately before the component is updated after any state change.
	 *
	 * The first time the callback runs will be before the initial `onMount`
	 *
	 * https://svelte.dev/docs/svelte#beforeupdate
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function beforeUpdate(fn) {
		get_current_component().$$.before_update.push(fn);
	}

	/**
	 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
	 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
	 * it can be called from an external module).
	 *
	 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
	 *
	 * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).
	 *
	 * https://svelte.dev/docs/svelte#onmount
	 * @template T
	 * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		get_current_component().$$.on_mount.push(fn);
	}

	/**
	 * Schedules a callback to run immediately after the component has been updated.
	 *
	 * The first time the callback runs will be after the initial `onMount`
	 *
	 * https://svelte.dev/docs/svelte#afterupdate
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function afterUpdate(fn) {
		get_current_component().$$.after_update.push(fn);
	}

	/**
	 * Schedules a callback to run immediately before the component is unmounted.
	 *
	 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
	 * only one that runs inside a server-side component.
	 *
	 * https://svelte.dev/docs/svelte#ondestroy
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function onDestroy(fn) {
		get_current_component().$$.on_destroy.push(fn);
	}

	/**
	 * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).
	 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
	 *
	 * Component events created with `createEventDispatcher` create a
	 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
	 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
	 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
	 * property and can contain any type of data.
	 *
	 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
	 * ```ts
	 * const dispatch = createEventDispatcher<{
	 *  loaded: never; // does not take a detail argument
	 *  change: string; // takes a detail argument of type string, which is required
	 *  optional: number | null; // takes an optional detail argument of type number
	 * }>();
	 * ```
	 *
	 * https://svelte.dev/docs/svelte#createeventdispatcher
	 * @template {Record<string, any>} [EventMap=any]
	 * @returns {import('./public.js').EventDispatcher<EventMap>}
	 */
	function createEventDispatcher() {
		const component = get_current_component();
		return (type, detail, { cancelable = false } = {}) => {
			const callbacks = component.$$.callbacks[type];
			if (callbacks) {
				// TODO are there situations where events could be dispatched
				// in a server (non-DOM) environment?
				const event = custom_event(/** @type {string} */ (type), detail, { cancelable });
				callbacks.slice().forEach((fn) => {
					fn.call(component, event);
				});
				return !event.defaultPrevented;
			}
			return true;
		};
	}

	/**
	 * Associates an arbitrary `context` object with the current component and the specified `key`
	 * and returns that object. The context is then available to children of the component
	 * (including slotted content) with `getContext`.
	 *
	 * Like lifecycle functions, this must be called during component initialisation.
	 *
	 * https://svelte.dev/docs/svelte#setcontext
	 * @template T
	 * @param {any} key
	 * @param {T} context
	 * @returns {T}
	 */
	function setContext(key, context) {
		get_current_component().$$.context.set(key, context);
		return context;
	}

	/**
	 * Retrieves the context that belongs to the closest parent component with the specified `key`.
	 * Must be called during component initialisation.
	 *
	 * https://svelte.dev/docs/svelte#getcontext
	 * @template T
	 * @param {any} key
	 * @returns {T}
	 */
	function getContext(key) {
		return get_current_component().$$.context.get(key);
	}

	// TODO figure out if we still want to support
	// shorthand events, or if we want to implement
	// a real bubbling mechanism
	/**
	 * @param component
	 * @param event
	 * @returns {void}
	 */
	function bubble(component, event) {
		const callbacks = component.$$.callbacks[event.type];
		if (callbacks) {
			// @ts-ignore
			callbacks.slice().forEach((fn) => fn.call(this, event));
		}
	}

	const dirty_components = [];
	const binding_callbacks = [];

	let render_callbacks = [];

	const flush_callbacks = [];

	const resolved_promise = /* @__PURE__ */ Promise.resolve();

	let update_scheduled = false;

	/** @returns {void} */
	function schedule_update() {
		if (!update_scheduled) {
			update_scheduled = true;
			resolved_promise.then(flush);
		}
	}

	/** @returns {Promise<void>} */
	function tick() {
		schedule_update();
		return resolved_promise;
	}

	/** @returns {void} */
	function add_render_callback(fn) {
		render_callbacks.push(fn);
	}

	/** @returns {void} */
	function add_flush_callback(fn) {
		flush_callbacks.push(fn);
	}

	// flush() calls callbacks in this order:
	// 1. All beforeUpdate callbacks, in order: parents before children
	// 2. All bind:this callbacks, in reverse order: children before parents.
	// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
	//    for afterUpdates called during the initial onMount, which are called in
	//    reverse order: children before parents.
	// Since callbacks might update component values, which could trigger another
	// call to flush(), the following steps guard against this:
	// 1. During beforeUpdate, any updated components will be added to the
	//    dirty_components array and will cause a reentrant call to flush(). Because
	//    the flush index is kept outside the function, the reentrant call will pick
	//    up where the earlier call left off and go through all dirty components. The
	//    current_component value is saved and restored so that the reentrant call will
	//    not interfere with the "parent" flush() call.
	// 2. bind:this callbacks cannot trigger new flush() calls.
	// 3. During afterUpdate, any updated components will NOT have their afterUpdate
	//    callback called a second time; the seen_callbacks set, outside the flush()
	//    function, guarantees this behavior.
	const seen_callbacks = new Set();

	let flushidx = 0; // Do *not* move this inside the flush() function

	/** @returns {void} */
	function flush() {
		// Do not reenter flush while dirty components are updated, as this can
		// result in an infinite loop. Instead, let the inner flush handle it.
		// Reentrancy is ok afterwards for bindings etc.
		if (flushidx !== 0) {
			return;
		}
		const saved_component = current_component;
		do {
			// first, call beforeUpdate functions
			// and update components
			try {
				while (flushidx < dirty_components.length) {
					const component = dirty_components[flushidx];
					flushidx++;
					set_current_component(component);
					update(component.$$);
				}
			} catch (e) {
				// reset dirty state to not end up in a deadlocked state and then rethrow
				dirty_components.length = 0;
				flushidx = 0;
				throw e;
			}
			set_current_component(null);
			dirty_components.length = 0;
			flushidx = 0;
			while (binding_callbacks.length) binding_callbacks.pop()();
			// then, once components are updated, call
			// afterUpdate functions. This may cause
			// subsequent updates...
			for (let i = 0; i < render_callbacks.length; i += 1) {
				const callback = render_callbacks[i];
				if (!seen_callbacks.has(callback)) {
					// ...so guard against infinite loops
					seen_callbacks.add(callback);
					callback();
				}
			}
			render_callbacks.length = 0;
		} while (dirty_components.length);
		while (flush_callbacks.length) {
			flush_callbacks.pop()();
		}
		update_scheduled = false;
		seen_callbacks.clear();
		set_current_component(saved_component);
	}

	/** @returns {void} */
	function update($$) {
		if ($$.fragment !== null) {
			$$.update();
			run_all($$.before_update);
			const dirty = $$.dirty;
			$$.dirty = [-1];
			$$.fragment && $$.fragment.p($$.ctx, dirty);
			$$.after_update.forEach(add_render_callback);
		}
	}

	/**
	 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function flush_render_callbacks(fns) {
		const filtered = [];
		const targets = [];
		render_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));
		targets.forEach((c) => c());
		render_callbacks = filtered;
	}

	/**
	 * @type {Promise<void> | null}
	 */
	let promise;

	/**
	 * @returns {Promise<void>}
	 */
	function wait() {
		if (!promise) {
			promise = Promise.resolve();
			promise.then(() => {
				promise = null;
			});
		}
		return promise;
	}

	/**
	 * @param {Element} node
	 * @param {INTRO | OUTRO | boolean} direction
	 * @param {'start' | 'end'} kind
	 * @returns {void}
	 */
	function dispatch(node, direction, kind) {
		node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
	}

	const outroing = new Set();

	/**
	 * @type {Outro}
	 */
	let outros;

	/**
	 * @returns {void} */
	function group_outros() {
		outros = {
			r: 0,
			c: [],
			p: outros // parent group
		};
	}

	/**
	 * @returns {void} */
	function check_outros() {
		if (!outros.r) {
			run_all(outros.c);
		}
		outros = outros.p;
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} [local]
	 * @returns {void}
	 */
	function transition_in(block, local) {
		if (block && block.i) {
			outroing.delete(block);
			block.i(local);
		}
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} local
	 * @param {0 | 1} [detach]
	 * @param {() => void} [callback]
	 * @returns {void}
	 */
	function transition_out(block, local, detach, callback) {
		if (block && block.o) {
			if (outroing.has(block)) return;
			outroing.add(block);
			outros.c.push(() => {
				outroing.delete(block);
				if (callback) {
					if (detach) block.d(1);
					callback();
				}
			});
			block.o(local);
		} else if (callback) {
			callback();
		}
	}

	/**
	 * @type {import('../transition/public.js').TransitionConfig}
	 */
	const null_transition = { duration: 0 };

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {TransitionFn} fn
	 * @param {any} params
	 * @returns {{ start(): void; invalidate(): void; end(): void; }}
	 */
	function create_in_transition(node, fn, params) {
		/**
		 * @type {TransitionOptions} */
		const options = { direction: 'in' };
		let config = fn(node, params, options);
		let running = false;
		let animation_name;
		let task;
		let uid = 0;

		/**
		 * @returns {void} */
		function cleanup() {
			if (animation_name) delete_rule(node, animation_name);
		}

		/**
		 * @returns {void} */
		function go() {
			const {
				delay = 0,
				duration = 300,
				easing = identity$1,
				tick = noop$3,
				css
			} = config || null_transition;
			if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
			tick(0, 1);
			const start_time = now() + delay;
			const end_time = start_time + duration;
			if (task) task.abort();
			running = true;
			add_render_callback(() => dispatch(node, true, 'start'));
			task = loop((now) => {
				if (running) {
					if (now >= end_time) {
						tick(1, 0);
						dispatch(node, true, 'end');
						cleanup();
						return (running = false);
					}
					if (now >= start_time) {
						const t = easing((now - start_time) / duration);
						tick(t, 1 - t);
					}
				}
				return running;
			});
		}
		let started = false;
		return {
			start() {
				if (started) return;
				started = true;
				delete_rule(node);
				if (is_function(config)) {
					config = config(options);
					wait().then(go);
				} else {
					go();
				}
			},
			invalidate() {
				started = false;
			},
			end() {
				if (running) {
					cleanup();
					running = false;
				}
			}
		};
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {TransitionFn} fn
	 * @param {any} params
	 * @returns {{ end(reset: any): void; }}
	 */
	function create_out_transition(node, fn, params) {
		/** @type {TransitionOptions} */
		const options = { direction: 'out' };
		let config = fn(node, params, options);
		let running = true;
		let animation_name;
		const group = outros;
		group.r += 1;
		/** @type {boolean} */
		let original_inert_value;

		/**
		 * @returns {void} */
		function go() {
			const {
				delay = 0,
				duration = 300,
				easing = identity$1,
				tick = noop$3,
				css
			} = config || null_transition;

			if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);

			const start_time = now() + delay;
			const end_time = start_time + duration;
			add_render_callback(() => dispatch(node, false, 'start'));

			if ('inert' in node) {
				original_inert_value = /** @type {HTMLElement} */ (node).inert;
				node.inert = true;
			}

			loop((now) => {
				if (running) {
					if (now >= end_time) {
						tick(0, 1);
						dispatch(node, false, 'end');
						if (!--group.r) {
							// this will result in `end()` being called,
							// so we don't need to clean up here
							run_all(group.c);
						}
						return false;
					}
					if (now >= start_time) {
						const t = easing((now - start_time) / duration);
						tick(1 - t, t);
					}
				}
				return running;
			});
		}

		if (is_function(config)) {
			wait().then(() => {
				// @ts-ignore
				config = config(options);
				go();
			});
		} else {
			go();
		}

		return {
			end(reset) {
				if (reset && 'inert' in node) {
					node.inert = original_inert_value;
				}
				if (reset && config.tick) {
					config.tick(1, 0);
				}
				if (running) {
					if (animation_name) delete_rule(node, animation_name);
					running = false;
				}
			}
		};
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {TransitionFn} fn
	 * @param {any} params
	 * @param {boolean} intro
	 * @returns {{ run(b: 0 | 1): void; end(): void; }}
	 */
	function create_bidirectional_transition(node, fn, params, intro) {
		/**
		 * @type {TransitionOptions} */
		const options = { direction: 'both' };
		let config = fn(node, params, options);
		let t = intro ? 0 : 1;

		/**
		 * @type {Program | null} */
		let running_program = null;

		/**
		 * @type {PendingProgram | null} */
		let pending_program = null;
		let animation_name = null;

		/** @type {boolean} */
		let original_inert_value;

		/**
		 * @returns {void} */
		function clear_animation() {
			if (animation_name) delete_rule(node, animation_name);
		}

		/**
		 * @param {PendingProgram} program
		 * @param {number} duration
		 * @returns {Program}
		 */
		function init(program, duration) {
			const d = /** @type {Program['d']} */ (program.b - t);
			duration *= Math.abs(d);
			return {
				a: t,
				b: program.b,
				d,
				duration,
				start: program.start,
				end: program.start + duration,
				group: program.group
			};
		}

		/**
		 * @param {INTRO | OUTRO} b
		 * @returns {void}
		 */
		function go(b) {
			const {
				delay = 0,
				duration = 300,
				easing = identity$1,
				tick = noop$3,
				css
			} = config || null_transition;

			/**
			 * @type {PendingProgram} */
			const program = {
				start: now() + delay,
				b
			};

			if (!b) {
				// @ts-ignore todo: improve typings
				program.group = outros;
				outros.r += 1;
			}

			if ('inert' in node) {
				if (b) {
					if (original_inert_value !== undefined) {
						// aborted/reversed outro — restore previous inert value
						node.inert = original_inert_value;
					}
				} else {
					original_inert_value = /** @type {HTMLElement} */ (node).inert;
					node.inert = true;
				}
			}

			if (running_program || pending_program) {
				pending_program = program;
			} else {
				// if this is an intro, and there's a delay, we need to do
				// an initial tick and/or apply CSS animation immediately
				if (css) {
					clear_animation();
					animation_name = create_rule(node, t, b, duration, delay, easing, css);
				}
				if (b) tick(0, 1);
				running_program = init(program, duration);
				add_render_callback(() => dispatch(node, b, 'start'));
				loop((now) => {
					if (pending_program && now > pending_program.start) {
						running_program = init(pending_program, duration);
						pending_program = null;
						dispatch(node, running_program.b, 'start');
						if (css) {
							clear_animation();
							animation_name = create_rule(
								node,
								t,
								running_program.b,
								running_program.duration,
								0,
								easing,
								config.css
							);
						}
					}
					if (running_program) {
						if (now >= running_program.end) {
							tick((t = running_program.b), 1 - t);
							dispatch(node, running_program.b, 'end');
							if (!pending_program) {
								// we're done
								if (running_program.b) {
									// intro — we can tidy up immediately
									clear_animation();
								} else {
									// outro — needs to be coordinated
									if (!--running_program.group.r) run_all(running_program.group.c);
								}
							}
							running_program = null;
						} else if (now >= running_program.start) {
							const p = now - running_program.start;
							t = running_program.a + running_program.d * easing(p / running_program.duration);
							tick(t, 1 - t);
						}
					}
					return !!(running_program || pending_program);
				});
			}
		}
		return {
			run(b) {
				if (is_function(config)) {
					wait().then(() => {
						const opts = { direction: b ? 'in' : 'out' };
						// @ts-ignore
						config = config(opts);
						go(b);
					});
				} else {
					go(b);
				}
			},
			end() {
				clear_animation();
				running_program = pending_program = null;
			}
		};
	}

	/** @typedef {1} INTRO */
	/** @typedef {0} OUTRO */
	/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */
	/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */

	/**
	 * @typedef {Object} Outro
	 * @property {number} r
	 * @property {Function[]} c
	 * @property {Object} p
	 */

	/**
	 * @typedef {Object} PendingProgram
	 * @property {number} start
	 * @property {INTRO|OUTRO} b
	 * @property {Outro} [group]
	 */

	/**
	 * @typedef {Object} Program
	 * @property {number} a
	 * @property {INTRO|OUTRO} b
	 * @property {1|-1} d
	 * @property {number} duration
	 * @property {number} start
	 * @property {number} end
	 * @property {Outro} [group]
	 */

	// general each functions:

	function ensure_array_like(array_like_or_iterator) {
		return array_like_or_iterator?.length !== undefined
			? array_like_or_iterator
			: Array.from(array_like_or_iterator);
	}

	/** @returns {void} */
	function outro_and_destroy_block(block, lookup) {
		transition_out(block, 1, 1, () => {
			lookup.delete(block.key);
		});
	}

	/** @returns {any[]} */
	function update_keyed_each(
		old_blocks,
		dirty,
		get_key,
		dynamic,
		ctx,
		list,
		lookup,
		node,
		destroy,
		create_each_block,
		next,
		get_context
	) {
		let o = old_blocks.length;
		let n = list.length;
		let i = o;
		const old_indexes = {};
		while (i--) old_indexes[old_blocks[i].key] = i;
		const new_blocks = [];
		const new_lookup = new Map();
		const deltas = new Map();
		const updates = [];
		i = n;
		while (i--) {
			const child_ctx = get_context(ctx, list, i);
			const key = get_key(child_ctx);
			let block = lookup.get(key);
			if (!block) {
				block = create_each_block(key, child_ctx);
				block.c();
			} else if (dynamic) {
				// defer updates until all the DOM shuffling is done
				updates.push(() => block.p(child_ctx, dirty));
			}
			new_lookup.set(key, (new_blocks[i] = block));
			if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
		}
		const will_move = new Set();
		const did_move = new Set();
		/** @returns {void} */
		function insert(block) {
			transition_in(block, 1);
			block.m(node, next);
			lookup.set(block.key, block);
			next = block.first;
			n--;
		}
		while (o && n) {
			const new_block = new_blocks[n - 1];
			const old_block = old_blocks[o - 1];
			const new_key = new_block.key;
			const old_key = old_block.key;
			if (new_block === old_block) {
				// do nothing
				next = new_block.first;
				o--;
				n--;
			} else if (!new_lookup.has(old_key)) {
				// remove old block
				destroy(old_block, lookup);
				o--;
			} else if (!lookup.has(new_key) || will_move.has(new_key)) {
				insert(new_block);
			} else if (did_move.has(old_key)) {
				o--;
			} else if (deltas.get(new_key) > deltas.get(old_key)) {
				did_move.add(new_key);
				insert(new_block);
			} else {
				will_move.add(old_key);
				o--;
			}
		}
		while (o--) {
			const old_block = old_blocks[o];
			if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
		}
		while (n) insert(new_blocks[n - 1]);
		run_all(updates);
		return new_blocks;
	}

	/** @returns {void} */
	function validate_each_keys(ctx, list, get_context, get_key) {
		const keys = new Map();
		for (let i = 0; i < list.length; i++) {
			const key = get_key(get_context(ctx, list, i));
			if (keys.has(key)) {
				let value = '';
				try {
					value = `with value '${String(key)}' `;
				} catch (e) {
					// can't stringify
				}
				throw new Error(
					`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(
					key
				)} and ${i} ${value}are duplicates`
				);
			}
			keys.set(key, i);
		}
	}

	/** @returns {{}} */
	function get_spread_update(levels, updates) {
		const update = {};
		const to_null_out = {};
		const accounted_for = { $$scope: 1 };
		let i = levels.length;
		while (i--) {
			const o = levels[i];
			const n = updates[i];
			if (n) {
				for (const key in o) {
					if (!(key in n)) to_null_out[key] = 1;
				}
				for (const key in n) {
					if (!accounted_for[key]) {
						update[key] = n[key];
						accounted_for[key] = 1;
					}
				}
				levels[i] = n;
			} else {
				for (const key in o) {
					accounted_for[key] = 1;
				}
			}
		}
		for (const key in to_null_out) {
			if (!(key in update)) update[key] = undefined;
		}
		return update;
	}

	function get_spread_object(spread_props) {
		return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
	}

	/** regex of all html void element names */
	const void_element_names =
		/^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;

	/**
	 * @param {string} name
	 * @returns {boolean}
	 */
	function is_void(name) {
		return void_element_names.test(name) || name.toLowerCase() === '!doctype';
	}

	/** @returns {void} */
	function bind(component, name, callback) {
		const index = component.$$.props[name];
		if (index !== undefined) {
			component.$$.bound[index] = callback;
			callback(component.$$.ctx[index]);
		}
	}

	/** @returns {void} */
	function create_component(block) {
		block && block.c();
	}

	/** @returns {void} */
	function mount_component(component, target, anchor) {
		const { fragment, after_update } = component.$$;
		fragment && fragment.m(target, anchor);
		// onMount happens before the initial afterUpdate
		add_render_callback(() => {
			const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
			// if the component was destroyed immediately
			// it will update the `$$.on_destroy` reference to `null`.
			// the destructured on_destroy may still reference to the old array
			if (component.$$.on_destroy) {
				component.$$.on_destroy.push(...new_on_destroy);
			} else {
				// Edge case - component was destroyed immediately,
				// most likely as a result of a binding initialising
				run_all(new_on_destroy);
			}
			component.$$.on_mount = [];
		});
		after_update.forEach(add_render_callback);
	}

	/** @returns {void} */
	function destroy_component(component, detaching) {
		const $$ = component.$$;
		if ($$.fragment !== null) {
			flush_render_callbacks($$.after_update);
			run_all($$.on_destroy);
			$$.fragment && $$.fragment.d(detaching);
			// TODO null out other refs, including component.$$ (but need to
			// preserve final state?)
			$$.on_destroy = $$.fragment = null;
			$$.ctx = [];
		}
	}

	/** @returns {void} */
	function make_dirty(component, i) {
		if (component.$$.dirty[0] === -1) {
			dirty_components.push(component);
			schedule_update();
			component.$$.dirty.fill(0);
		}
		component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
	}

	// TODO: Document the other params
	/**
	 * @param {SvelteComponent} component
	 * @param {import('./public.js').ComponentConstructorOptions} options
	 *
	 * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.
	 * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.
	 * This will be the `add_css` function from the compiled component.
	 *
	 * @returns {void}
	 */
	function init(
		component,
		options,
		instance,
		create_fragment,
		not_equal,
		props,
		append_styles = null,
		dirty = [-1]
	) {
		const parent_component = current_component;
		set_current_component(component);
		/** @type {import('./private.js').T$$} */
		const $$ = (component.$$ = {
			fragment: null,
			ctx: [],
			// state
			props,
			update: noop$3,
			not_equal,
			bound: blank_object(),
			// lifecycle
			on_mount: [],
			on_destroy: [],
			on_disconnect: [],
			before_update: [],
			after_update: [],
			context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
			// everything else
			callbacks: blank_object(),
			dirty,
			skip_bound: false,
			root: options.target || parent_component.$$.root
		});
		append_styles && append_styles($$.root);
		let ready = false;
		$$.ctx = instance
			? instance(component, options.props || {}, (i, ret, ...rest) => {
					const value = rest.length ? rest[0] : ret;
					if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
						if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
						if (ready) make_dirty(component, i);
					}
					return ret;
			  })
			: [];
		$$.update();
		ready = true;
		run_all($$.before_update);
		// `false` as a special case of no DOM component
		$$.fragment = create_fragment ? create_fragment($$.ctx) : false;
		if (options.target) {
			if (options.hydrate) {
				// TODO: what is the correct type here?
				// @ts-expect-error
				const nodes = children(options.target);
				$$.fragment && $$.fragment.l(nodes);
				nodes.forEach(detach);
			} else {
				// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
				$$.fragment && $$.fragment.c();
			}
			if (options.intro) transition_in(component.$$.fragment);
			mount_component(component, options.target, options.anchor);
			flush();
		}
		set_current_component(parent_component);
	}

	/**
	 * Base class for Svelte components. Used when dev=false.
	 *
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 */
	class SvelteComponent {
		/**
		 * ### PRIVATE API
		 *
		 * Do not use, may change at any time
		 *
		 * @type {any}
		 */
		$$ = undefined;
		/**
		 * ### PRIVATE API
		 *
		 * Do not use, may change at any time
		 *
		 * @type {any}
		 */
		$$set = undefined;

		/** @returns {void} */
		$destroy() {
			destroy_component(this, 1);
			this.$destroy = noop$3;
		}

		/**
		 * @template {Extract<keyof Events, string>} K
		 * @param {K} type
		 * @param {((e: Events[K]) => void) | null | undefined} callback
		 * @returns {() => void}
		 */
		$on(type, callback) {
			if (!is_function(callback)) {
				return noop$3;
			}
			const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
			callbacks.push(callback);
			return () => {
				const index = callbacks.indexOf(callback);
				if (index !== -1) callbacks.splice(index, 1);
			};
		}

		/**
		 * @param {Partial<Props>} props
		 * @returns {void}
		 */
		$set(props) {
			if (this.$$set && !is_empty(props)) {
				this.$$.skip_bound = true;
				this.$$set(props);
				this.$$.skip_bound = false;
			}
		}
	}

	/**
	 * @typedef {Object} CustomElementPropDefinition
	 * @property {string} [attribute]
	 * @property {boolean} [reflect]
	 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
	 */

	// generated during release, do not modify

	/**
	 * The current version, as set in package.json.
	 *
	 * https://svelte.dev/docs/svelte-compiler#svelte-version
	 * @type {string}
	 */
	const VERSION = '4.2.10';
	const PUBLIC_VERSION = '4';

	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @returns {void}
	 */
	function dispatch_dev(type, detail) {
		document.dispatchEvent(custom_event(type, { version: VERSION, ...detail }, { bubbles: true }));
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */
	function append_dev(target, node) {
		dispatch_dev('SvelteDOMInsert', { target, node });
		append(target, node);
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */
	function insert_dev(target, node, anchor) {
		dispatch_dev('SvelteDOMInsert', { target, node, anchor });
		insert(target, node, anchor);
	}

	/**
	 * @param {Node} node
	 * @returns {void}
	 */
	function detach_dev(node) {
		dispatch_dev('SvelteDOMRemove', { node });
		detach(node);
	}

	/**
	 * @param {Node} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @param {boolean} [has_prevent_default]
	 * @param {boolean} [has_stop_propagation]
	 * @param {boolean} [has_stop_immediate_propagation]
	 * @returns {() => void}
	 */
	function listen_dev(
		node,
		event,
		handler,
		options,
		has_prevent_default,
		has_stop_propagation,
		has_stop_immediate_propagation
	) {
		const modifiers =
			options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
		if (has_prevent_default) modifiers.push('preventDefault');
		if (has_stop_propagation) modifiers.push('stopPropagation');
		if (has_stop_immediate_propagation) modifiers.push('stopImmediatePropagation');
		dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
		const dispose = listen(node, event, handler, options);
		return () => {
			dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
			dispose();
		};
	}

	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */
	function attr_dev(node, attribute, value) {
		attr$1(node, attribute, value);
		if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
		else dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
	}

	/**
	 * @param {Element} node
	 * @param {string} property
	 * @param {any} [value]
	 * @returns {void}
	 */
	function prop_dev(node, property, value) {
		node[property] = value;
		dispatch_dev('SvelteDOMSetProperty', { node, property, value });
	}

	/**
	 * @param {Text} text
	 * @param {unknown} data
	 * @returns {void}
	 */
	function set_data_dev(text, data) {
		data = '' + data;
		if (text.data === data) return;
		dispatch_dev('SvelteDOMSetData', { node: text, data });
		text.data = /** @type {string} */ (data);
	}

	function ensure_array_like_dev(arg) {
		if (
			typeof arg !== 'string' &&
			!(arg && typeof arg === 'object' && 'length' in arg) &&
			!(typeof Symbol === 'function' && arg && Symbol.iterator in arg)
		) {
			throw new Error('{#each} only works with iterable values.');
		}
		return ensure_array_like(arg);
	}

	/**
	 * @returns {void} */
	function validate_slots(name, slot, keys) {
		for (const slot_key of Object.keys(slot)) {
			if (!~keys.indexOf(slot_key)) {
				console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
			}
		}
	}

	/**
	 * @param {unknown} tag
	 * @returns {void}
	 */
	function validate_dynamic_element(tag) {
		const is_string = typeof tag === 'string';
		if (tag && !is_string) {
			throw new Error('<svelte:element> expects "this" attribute to be a string.');
		}
	}

	/**
	 * @param {undefined | string} tag
	 * @returns {void}
	 */
	function validate_void_dynamic_element(tag) {
		if (tag && is_void(tag)) {
			console.warn(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
		}
	}

	function construct_svelte_component_dev(component, props) {
		const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
		try {
			const instance = new component(props);
			if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
				throw new Error(error_message);
			}
			return instance;
		} catch (err) {
			const { message } = err;
			if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
				throw new Error(error_message);
			} else {
				throw err;
			}
		}
	}

	/**
	 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
	 *
	 * Can be used to create strongly typed Svelte components.
	 *
	 * #### Example:
	 *
	 * You have component library on npm called `component-library`, from which
	 * you export a component called `MyComponent`. For Svelte+TypeScript users,
	 * you want to provide typings. Therefore you create a `index.d.ts`:
	 * ```ts
	 * import { SvelteComponent } from "svelte";
	 * export class MyComponent extends SvelteComponent<{foo: string}> {}
	 * ```
	 * Typing this makes it possible for IDEs like VS Code with the Svelte extension
	 * to provide intellisense and to use the component like this in a Svelte file
	 * with TypeScript:
	 * ```svelte
	 * <script lang="ts">
	 * 	import { MyComponent } from "component-library";
	 * </script>
	 * <MyComponent foo={'bar'} />
	 * ```
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 * @template {Record<string, any>} [Slots=any]
	 * @extends {SvelteComponent<Props, Events>}
	 */
	class SvelteComponentDev extends SvelteComponent {
		/**
		 * For type checking capabilities only.
		 * Does not exist at runtime.
		 * ### DO NOT USE!
		 *
		 * @type {Props}
		 */
		$$prop_def;
		/**
		 * For type checking capabilities only.
		 * Does not exist at runtime.
		 * ### DO NOT USE!
		 *
		 * @type {Events}
		 */
		$$events_def;
		/**
		 * For type checking capabilities only.
		 * Does not exist at runtime.
		 * ### DO NOT USE!
		 *
		 * @type {Slots}
		 */
		$$slot_def;

		/** @param {import('./public.js').ComponentConstructorOptions<Props>} options */
		constructor(options) {
			if (!options || (!options.target && !options.$$inline)) {
				throw new Error("'target' is a required option");
			}
			super();
		}

		/** @returns {void} */
		$destroy() {
			super.$destroy();
			this.$destroy = () => {
				console.warn('Component was already destroyed'); // eslint-disable-line no-console
			};
		}

		/** @returns {void} */
		$capture_state() {}

		/** @returns {void} */
		$inject_state() {}
	}

	if (typeof window !== 'undefined')
		// @ts-ignore
		(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);

	function styleInject(css, ref) {
	  if ( ref === void 0 ) ref = {};
	  var insertAt = ref.insertAt;

	  if (!css || typeof document === 'undefined') { return; }

	  var head = document.head || document.getElementsByTagName('head')[0];
	  var style = document.createElement('style');
	  style.type = 'text/css';

	  if (insertAt === 'top') {
	    if (head.firstChild) {
	      head.insertBefore(style, head.firstChild);
	    } else {
	      head.appendChild(style);
	    }
	  } else {
	    head.appendChild(style);
	  }

	  if (style.styleSheet) {
	    style.styleSheet.cssText = css;
	  } else {
	    style.appendChild(document.createTextNode(css));
	  }
	}

	var css_248z = "onlook-toolbar {\n  --red: #ff0e48;\n\n  --background: 20 14.3% 4.1%;\n  --foreground: 60 9.1% 97.8%;\n\n  --muted: 12 6.5% 15.1%;\n  --muted-foreground: 24 5.4% 63.9%;\n\n  --popover: 20 14.3% 4.1%;\n  --popover-foreground: 60 9.1% 97.8%;\n\n  --card: 20 14.3% 4.1%;\n  --card-foreground: 60 9.1% 97.8%;\n\n  --border: 12 6.5% 15.1%;\n  --input: 12 6.5% 15.1%;\n\n  --primary: 60 9.1% 97.8%;\n  --primary-foreground: 24 9.8% 10%;\n\n  --secondary: 12 6.5% 15.1%;\n  --secondary-foreground: 60 9.1% 97.8%;\n\n  --accent: 12 6.5% 15.1%;\n  --accent-foreground: 60 9.1% 97.8%;\n\n  --destructive: 0 62.8% 30.6%;\n  --destructive-foreground: 60 9.1% 97.8%;\n\n  --ring: 24 5.7% 82.9%;\n\n  --radius: 0.5rem;\n\n  --tw-border-opacity: 1;\n\n  border-color: hsl(var(--border) / var(--tw-border-opacity));\n\n  --tw-bg-opacity: 1;\n\n  background-color: hsl(var(--background) / var(--tw-bg-opacity));\n\n  --tw-text-opacity: 1;\n\n  color: hsl(var(--foreground) / var(--tw-text-opacity));\n  /* Apply inter font */\n  font-family: \"Inter\", \"InterVariable\", sans-serif;\n}\n";
	styleInject(css_248z);

	function r$1(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r$1(e[t]))&&(n&&(n+=" "),n+=f);}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r$1(e))&&(n&&(n+=" "),n+=t);return n}

	const CLASS_PART_SEPARATOR$1 = '-';
	function createClassUtils$1(config) {
	  const classMap = createClassMap$1(config);
	  const {
	    conflictingClassGroups,
	    conflictingClassGroupModifiers
	  } = config;
	  function getClassGroupId(className) {
	    const classParts = className.split(CLASS_PART_SEPARATOR$1);
	    // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.
	    if (classParts[0] === '' && classParts.length !== 1) {
	      classParts.shift();
	    }
	    return getGroupRecursive$1(classParts, classMap) || getGroupIdForArbitraryProperty$1(className);
	  }
	  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
	    const conflicts = conflictingClassGroups[classGroupId] || [];
	    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
	      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
	    }
	    return conflicts;
	  }
	  return {
	    getClassGroupId,
	    getConflictingClassGroupIds
	  };
	}
	function getGroupRecursive$1(classParts, classPartObject) {
	  if (classParts.length === 0) {
	    return classPartObject.classGroupId;
	  }
	  const currentClassPart = classParts[0];
	  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
	  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive$1(classParts.slice(1), nextClassPartObject) : undefined;
	  if (classGroupFromNextClassPart) {
	    return classGroupFromNextClassPart;
	  }
	  if (classPartObject.validators.length === 0) {
	    return undefined;
	  }
	  const classRest = classParts.join(CLASS_PART_SEPARATOR$1);
	  return classPartObject.validators.find(({
	    validator
	  }) => validator(classRest))?.classGroupId;
	}
	const arbitraryPropertyRegex$1 = /^\[(.+)\]$/;
	function getGroupIdForArbitraryProperty$1(className) {
	  if (arbitraryPropertyRegex$1.test(className)) {
	    const arbitraryPropertyClassName = arbitraryPropertyRegex$1.exec(className)[1];
	    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(':'));
	    if (property) {
	      // I use two dots here because one dot is used as prefix for class groups in plugins
	      return 'arbitrary..' + property;
	    }
	  }
	}
	/**
	 * Exported for testing only
	 */
	function createClassMap$1(config) {
	  const {
	    theme,
	    prefix
	  } = config;
	  const classMap = {
	    nextPart: new Map(),
	    validators: []
	  };
	  const prefixedClassGroupEntries = getPrefixedClassGroupEntries$1(Object.entries(config.classGroups), prefix);
	  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
	    processClassesRecursively$1(classGroup, classMap, classGroupId, theme);
	  });
	  return classMap;
	}
	function processClassesRecursively$1(classGroup, classPartObject, classGroupId, theme) {
	  classGroup.forEach(classDefinition => {
	    if (typeof classDefinition === 'string') {
	      const classPartObjectToEdit = classDefinition === '' ? classPartObject : getPart$1(classPartObject, classDefinition);
	      classPartObjectToEdit.classGroupId = classGroupId;
	      return;
	    }
	    if (typeof classDefinition === 'function') {
	      if (isThemeGetter$1(classDefinition)) {
	        processClassesRecursively$1(classDefinition(theme), classPartObject, classGroupId, theme);
	        return;
	      }
	      classPartObject.validators.push({
	        validator: classDefinition,
	        classGroupId
	      });
	      return;
	    }
	    Object.entries(classDefinition).forEach(([key, classGroup]) => {
	      processClassesRecursively$1(classGroup, getPart$1(classPartObject, key), classGroupId, theme);
	    });
	  });
	}
	function getPart$1(classPartObject, path) {
	  let currentClassPartObject = classPartObject;
	  path.split(CLASS_PART_SEPARATOR$1).forEach(pathPart => {
	    if (!currentClassPartObject.nextPart.has(pathPart)) {
	      currentClassPartObject.nextPart.set(pathPart, {
	        nextPart: new Map(),
	        validators: []
	      });
	    }
	    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
	  });
	  return currentClassPartObject;
	}
	function isThemeGetter$1(func) {
	  return func.isThemeGetter;
	}
	function getPrefixedClassGroupEntries$1(classGroupEntries, prefix) {
	  if (!prefix) {
	    return classGroupEntries;
	  }
	  return classGroupEntries.map(([classGroupId, classGroup]) => {
	    const prefixedClassGroup = classGroup.map(classDefinition => {
	      if (typeof classDefinition === 'string') {
	        return prefix + classDefinition;
	      }
	      if (typeof classDefinition === 'object') {
	        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
	      }
	      return classDefinition;
	    });
	    return [classGroupId, prefixedClassGroup];
	  });
	}

	// LRU cache inspired from hashlru (https://github.com/dominictarr/hashlru/blob/v1.0.4/index.js) but object replaced with Map to improve performance
	function createLruCache$1(maxCacheSize) {
	  if (maxCacheSize < 1) {
	    return {
	      get: () => undefined,
	      set: () => {}
	    };
	  }
	  let cacheSize = 0;
	  let cache = new Map();
	  let previousCache = new Map();
	  function update(key, value) {
	    cache.set(key, value);
	    cacheSize++;
	    if (cacheSize > maxCacheSize) {
	      cacheSize = 0;
	      previousCache = cache;
	      cache = new Map();
	    }
	  }
	  return {
	    get(key) {
	      let value = cache.get(key);
	      if (value !== undefined) {
	        return value;
	      }
	      if ((value = previousCache.get(key)) !== undefined) {
	        update(key, value);
	        return value;
	      }
	    },
	    set(key, value) {
	      if (cache.has(key)) {
	        cache.set(key, value);
	      } else {
	        update(key, value);
	      }
	    }
	  };
	}
	const IMPORTANT_MODIFIER$1 = '!';
	function createSplitModifiers$1(config) {
	  const separator = config.separator;
	  const isSeparatorSingleCharacter = separator.length === 1;
	  const firstSeparatorCharacter = separator[0];
	  const separatorLength = separator.length;
	  // splitModifiers inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js
	  return function splitModifiers(className) {
	    const modifiers = [];
	    let bracketDepth = 0;
	    let modifierStart = 0;
	    let postfixModifierPosition;
	    for (let index = 0; index < className.length; index++) {
	      let currentCharacter = className[index];
	      if (bracketDepth === 0) {
	        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index, index + separatorLength) === separator)) {
	          modifiers.push(className.slice(modifierStart, index));
	          modifierStart = index + separatorLength;
	          continue;
	        }
	        if (currentCharacter === '/') {
	          postfixModifierPosition = index;
	          continue;
	        }
	      }
	      if (currentCharacter === '[') {
	        bracketDepth++;
	      } else if (currentCharacter === ']') {
	        bracketDepth--;
	      }
	    }
	    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
	    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER$1);
	    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
	    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : undefined;
	    return {
	      modifiers,
	      hasImportantModifier,
	      baseClassName,
	      maybePostfixModifierPosition
	    };
	  };
	}
	/**
	 * Sorts modifiers according to following schema:
	 * - Predefined modifiers are sorted alphabetically
	 * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it
	 */
	function sortModifiers$1(modifiers) {
	  if (modifiers.length <= 1) {
	    return modifiers;
	  }
	  const sortedModifiers = [];
	  let unsortedModifiers = [];
	  modifiers.forEach(modifier => {
	    const isArbitraryVariant = modifier[0] === '[';
	    if (isArbitraryVariant) {
	      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
	      unsortedModifiers = [];
	    } else {
	      unsortedModifiers.push(modifier);
	    }
	  });
	  sortedModifiers.push(...unsortedModifiers.sort());
	  return sortedModifiers;
	}
	function createConfigUtils$1(config) {
	  return {
	    cache: createLruCache$1(config.cacheSize),
	    splitModifiers: createSplitModifiers$1(config),
	    ...createClassUtils$1(config)
	  };
	}
	const SPLIT_CLASSES_REGEX$1 = /\s+/;
	function mergeClassList$1(classList, configUtils) {
	  const {
	    splitModifiers,
	    getClassGroupId,
	    getConflictingClassGroupIds
	  } = configUtils;
	  /**
	   * Set of classGroupIds in following format:
	   * `{importantModifier}{variantModifiers}{classGroupId}`
	   * @example 'float'
	   * @example 'hover:focus:bg-color'
	   * @example 'md:!pr'
	   */
	  const classGroupsInConflict = new Set();
	  return classList.trim().split(SPLIT_CLASSES_REGEX$1).map(originalClassName => {
	    const {
	      modifiers,
	      hasImportantModifier,
	      baseClassName,
	      maybePostfixModifierPosition
	    } = splitModifiers(originalClassName);
	    let classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
	    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
	    if (!classGroupId) {
	      if (!maybePostfixModifierPosition) {
	        return {
	          isTailwindClass: false,
	          originalClassName
	        };
	      }
	      classGroupId = getClassGroupId(baseClassName);
	      if (!classGroupId) {
	        return {
	          isTailwindClass: false,
	          originalClassName
	        };
	      }
	      hasPostfixModifier = false;
	    }
	    const variantModifier = sortModifiers$1(modifiers).join(':');
	    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER$1 : variantModifier;
	    return {
	      isTailwindClass: true,
	      modifierId,
	      classGroupId,
	      originalClassName,
	      hasPostfixModifier
	    };
	  }).reverse()
	  // Last class in conflict wins, so we need to filter conflicting classes in reverse order.
	  .filter(parsed => {
	    if (!parsed.isTailwindClass) {
	      return true;
	    }
	    const {
	      modifierId,
	      classGroupId,
	      hasPostfixModifier
	    } = parsed;
	    const classId = modifierId + classGroupId;
	    if (classGroupsInConflict.has(classId)) {
	      return false;
	    }
	    classGroupsInConflict.add(classId);
	    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach(group => classGroupsInConflict.add(modifierId + group));
	    return true;
	  }).reverse().map(parsed => parsed.originalClassName).join(' ');
	}

	/**
	 * The code in this file is copied from https://github.com/lukeed/clsx and modified to suit the needs of tailwind-merge better.
	 *
	 * Specifically:
	 * - Runtime code from https://github.com/lukeed/clsx/blob/v1.2.1/src/index.js
	 * - TypeScript types from https://github.com/lukeed/clsx/blob/v1.2.1/clsx.d.ts
	 *
	 * Original code has MIT license: Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)
	 */
	function twJoin$1() {
	  let index = 0;
	  let argument;
	  let resolvedValue;
	  let string = '';
	  while (index < arguments.length) {
	    if (argument = arguments[index++]) {
	      if (resolvedValue = toValue$1(argument)) {
	        string && (string += ' ');
	        string += resolvedValue;
	      }
	    }
	  }
	  return string;
	}
	function toValue$1(mix) {
	  if (typeof mix === 'string') {
	    return mix;
	  }
	  let resolvedValue;
	  let string = '';
	  for (let k = 0; k < mix.length; k++) {
	    if (mix[k]) {
	      if (resolvedValue = toValue$1(mix[k])) {
	        string && (string += ' ');
	        string += resolvedValue;
	      }
	    }
	  }
	  return string;
	}
	function createTailwindMerge$1(createConfigFirst, ...createConfigRest) {
	  let configUtils;
	  let cacheGet;
	  let cacheSet;
	  let functionToCall = initTailwindMerge;
	  function initTailwindMerge(classList) {
	    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
	    configUtils = createConfigUtils$1(config);
	    cacheGet = configUtils.cache.get;
	    cacheSet = configUtils.cache.set;
	    functionToCall = tailwindMerge;
	    return tailwindMerge(classList);
	  }
	  function tailwindMerge(classList) {
	    const cachedResult = cacheGet(classList);
	    if (cachedResult) {
	      return cachedResult;
	    }
	    const result = mergeClassList$1(classList, configUtils);
	    cacheSet(classList, result);
	    return result;
	  }
	  return function callTailwindMerge() {
	    return functionToCall(twJoin$1.apply(null, arguments));
	  };
	}
	function fromTheme$2(key) {
	  const themeGetter = theme => theme[key] || [];
	  themeGetter.isThemeGetter = true;
	  return themeGetter;
	}
	const arbitraryValueRegex$1 = /^\[(?:([a-z-]+):)?(.+)\]$/i;
	const fractionRegex$1 = /^\d+\/\d+$/;
	const stringLengths$1 = /*#__PURE__*/new Set(['px', 'full', 'screen']);
	const tshirtUnitRegex$1 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
	const lengthUnitRegex$1 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
	const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
	// Shadow always begins with x and y offset separated by underscore
	const shadowRegex$1 = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
	const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
	function isLength$1(value) {
	  return isNumber$1(value) || stringLengths$1.has(value) || fractionRegex$1.test(value);
	}
	function isArbitraryLength$1(value) {
	  return getIsArbitraryValue$1(value, 'length', isLengthOnly$1);
	}
	function isNumber$1(value) {
	  return Boolean(value) && !Number.isNaN(Number(value));
	}
	function isArbitraryNumber$1(value) {
	  return getIsArbitraryValue$1(value, 'number', isNumber$1);
	}
	function isInteger$1(value) {
	  return Boolean(value) && Number.isInteger(Number(value));
	}
	function isPercent$1(value) {
	  return value.endsWith('%') && isNumber$1(value.slice(0, -1));
	}
	function isArbitraryValue$1(value) {
	  return arbitraryValueRegex$1.test(value);
	}
	function isTshirtSize$1(value) {
	  return tshirtUnitRegex$1.test(value);
	}
	const sizeLabels = /*#__PURE__*/new Set(['length', 'size', 'percentage']);
	function isArbitrarySize$1(value) {
	  return getIsArbitraryValue$1(value, sizeLabels, isNever$1);
	}
	function isArbitraryPosition$1(value) {
	  return getIsArbitraryValue$1(value, 'position', isNever$1);
	}
	const imageLabels = /*#__PURE__*/new Set(['image', 'url']);
	function isArbitraryImage(value) {
	  return getIsArbitraryValue$1(value, imageLabels, isImage);
	}
	function isArbitraryShadow$1(value) {
	  return getIsArbitraryValue$1(value, '', isShadow$1);
	}
	function isAny$1() {
	  return true;
	}
	function getIsArbitraryValue$1(value, label, testValue) {
	  const result = arbitraryValueRegex$1.exec(value);
	  if (result) {
	    if (result[1]) {
	      return typeof label === 'string' ? result[1] === label : label.has(result[1]);
	    }
	    return testValue(result[2]);
	  }
	  return false;
	}
	function isLengthOnly$1(value) {
	  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
	  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
	  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
	  return lengthUnitRegex$1.test(value) && !colorFunctionRegex.test(value);
	}
	function isNever$1() {
	  return false;
	}
	function isShadow$1(value) {
	  return shadowRegex$1.test(value);
	}
	function isImage(value) {
	  return imageRegex.test(value);
	}
	function getDefaultConfig$1() {
	  const colors = fromTheme$2('colors');
	  const spacing = fromTheme$2('spacing');
	  const blur = fromTheme$2('blur');
	  const brightness = fromTheme$2('brightness');
	  const borderColor = fromTheme$2('borderColor');
	  const borderRadius = fromTheme$2('borderRadius');
	  const borderSpacing = fromTheme$2('borderSpacing');
	  const borderWidth = fromTheme$2('borderWidth');
	  const contrast = fromTheme$2('contrast');
	  const grayscale = fromTheme$2('grayscale');
	  const hueRotate = fromTheme$2('hueRotate');
	  const invert = fromTheme$2('invert');
	  const gap = fromTheme$2('gap');
	  const gradientColorStops = fromTheme$2('gradientColorStops');
	  const gradientColorStopPositions = fromTheme$2('gradientColorStopPositions');
	  const inset = fromTheme$2('inset');
	  const margin = fromTheme$2('margin');
	  const opacity = fromTheme$2('opacity');
	  const padding = fromTheme$2('padding');
	  const saturate = fromTheme$2('saturate');
	  const scale = fromTheme$2('scale');
	  const sepia = fromTheme$2('sepia');
	  const skew = fromTheme$2('skew');
	  const space = fromTheme$2('space');
	  const translate = fromTheme$2('translate');
	  const getOverscroll = () => ['auto', 'contain', 'none'];
	  const getOverflow = () => ['auto', 'hidden', 'clip', 'visible', 'scroll'];
	  const getSpacingWithAutoAndArbitrary = () => ['auto', isArbitraryValue$1, spacing];
	  const getSpacingWithArbitrary = () => [isArbitraryValue$1, spacing];
	  const getLengthWithEmptyAndArbitrary = () => ['', isLength$1, isArbitraryLength$1];
	  const getNumberWithAutoAndArbitrary = () => ['auto', isNumber$1, isArbitraryValue$1];
	  const getPositions = () => ['bottom', 'center', 'left', 'left-bottom', 'left-top', 'right', 'right-bottom', 'right-top', 'top'];
	  const getLineStyles = () => ['solid', 'dashed', 'dotted', 'double', 'none'];
	  const getBlendModes = () => ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity', 'plus-lighter'];
	  const getAlign = () => ['start', 'end', 'center', 'between', 'around', 'evenly', 'stretch'];
	  const getZeroAndEmpty = () => ['', '0', isArbitraryValue$1];
	  const getBreaks = () => ['auto', 'avoid', 'all', 'avoid-page', 'page', 'left', 'right', 'column'];
	  const getNumber = () => [isNumber$1, isArbitraryNumber$1];
	  const getNumberAndArbitrary = () => [isNumber$1, isArbitraryValue$1];
	  return {
	    cacheSize: 500,
	    separator: ':',
	    theme: {
	      colors: [isAny$1],
	      spacing: [isLength$1, isArbitraryLength$1],
	      blur: ['none', '', isTshirtSize$1, isArbitraryValue$1],
	      brightness: getNumber(),
	      borderColor: [colors],
	      borderRadius: ['none', '', 'full', isTshirtSize$1, isArbitraryValue$1],
	      borderSpacing: getSpacingWithArbitrary(),
	      borderWidth: getLengthWithEmptyAndArbitrary(),
	      contrast: getNumber(),
	      grayscale: getZeroAndEmpty(),
	      hueRotate: getNumberAndArbitrary(),
	      invert: getZeroAndEmpty(),
	      gap: getSpacingWithArbitrary(),
	      gradientColorStops: [colors],
	      gradientColorStopPositions: [isPercent$1, isArbitraryLength$1],
	      inset: getSpacingWithAutoAndArbitrary(),
	      margin: getSpacingWithAutoAndArbitrary(),
	      opacity: getNumber(),
	      padding: getSpacingWithArbitrary(),
	      saturate: getNumber(),
	      scale: getNumber(),
	      sepia: getZeroAndEmpty(),
	      skew: getNumberAndArbitrary(),
	      space: getSpacingWithArbitrary(),
	      translate: getSpacingWithArbitrary()
	    },
	    classGroups: {
	      // Layout
	      /**
	       * Aspect Ratio
	       * @see https://tailwindcss.com/docs/aspect-ratio
	       */
	      aspect: [{
	        aspect: ['auto', 'square', 'video', isArbitraryValue$1]
	      }],
	      /**
	       * Container
	       * @see https://tailwindcss.com/docs/container
	       */
	      container: ['container'],
	      /**
	       * Columns
	       * @see https://tailwindcss.com/docs/columns
	       */
	      columns: [{
	        columns: [isTshirtSize$1]
	      }],
	      /**
	       * Break After
	       * @see https://tailwindcss.com/docs/break-after
	       */
	      'break-after': [{
	        'break-after': getBreaks()
	      }],
	      /**
	       * Break Before
	       * @see https://tailwindcss.com/docs/break-before
	       */
	      'break-before': [{
	        'break-before': getBreaks()
	      }],
	      /**
	       * Break Inside
	       * @see https://tailwindcss.com/docs/break-inside
	       */
	      'break-inside': [{
	        'break-inside': ['auto', 'avoid', 'avoid-page', 'avoid-column']
	      }],
	      /**
	       * Box Decoration Break
	       * @see https://tailwindcss.com/docs/box-decoration-break
	       */
	      'box-decoration': [{
	        'box-decoration': ['slice', 'clone']
	      }],
	      /**
	       * Box Sizing
	       * @see https://tailwindcss.com/docs/box-sizing
	       */
	      box: [{
	        box: ['border', 'content']
	      }],
	      /**
	       * Display
	       * @see https://tailwindcss.com/docs/display
	       */
	      display: ['block', 'inline-block', 'inline', 'flex', 'inline-flex', 'table', 'inline-table', 'table-caption', 'table-cell', 'table-column', 'table-column-group', 'table-footer-group', 'table-header-group', 'table-row-group', 'table-row', 'flow-root', 'grid', 'inline-grid', 'contents', 'list-item', 'hidden'],
	      /**
	       * Floats
	       * @see https://tailwindcss.com/docs/float
	       */
	      float: [{
	        float: ['right', 'left', 'none', 'start', 'end']
	      }],
	      /**
	       * Clear
	       * @see https://tailwindcss.com/docs/clear
	       */
	      clear: [{
	        clear: ['left', 'right', 'both', 'none', 'start', 'end']
	      }],
	      /**
	       * Isolation
	       * @see https://tailwindcss.com/docs/isolation
	       */
	      isolation: ['isolate', 'isolation-auto'],
	      /**
	       * Object Fit
	       * @see https://tailwindcss.com/docs/object-fit
	       */
	      'object-fit': [{
	        object: ['contain', 'cover', 'fill', 'none', 'scale-down']
	      }],
	      /**
	       * Object Position
	       * @see https://tailwindcss.com/docs/object-position
	       */
	      'object-position': [{
	        object: [...getPositions(), isArbitraryValue$1]
	      }],
	      /**
	       * Overflow
	       * @see https://tailwindcss.com/docs/overflow
	       */
	      overflow: [{
	        overflow: getOverflow()
	      }],
	      /**
	       * Overflow X
	       * @see https://tailwindcss.com/docs/overflow
	       */
	      'overflow-x': [{
	        'overflow-x': getOverflow()
	      }],
	      /**
	       * Overflow Y
	       * @see https://tailwindcss.com/docs/overflow
	       */
	      'overflow-y': [{
	        'overflow-y': getOverflow()
	      }],
	      /**
	       * Overscroll Behavior
	       * @see https://tailwindcss.com/docs/overscroll-behavior
	       */
	      overscroll: [{
	        overscroll: getOverscroll()
	      }],
	      /**
	       * Overscroll Behavior X
	       * @see https://tailwindcss.com/docs/overscroll-behavior
	       */
	      'overscroll-x': [{
	        'overscroll-x': getOverscroll()
	      }],
	      /**
	       * Overscroll Behavior Y
	       * @see https://tailwindcss.com/docs/overscroll-behavior
	       */
	      'overscroll-y': [{
	        'overscroll-y': getOverscroll()
	      }],
	      /**
	       * Position
	       * @see https://tailwindcss.com/docs/position
	       */
	      position: ['static', 'fixed', 'absolute', 'relative', 'sticky'],
	      /**
	       * Top / Right / Bottom / Left
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      inset: [{
	        inset: [inset]
	      }],
	      /**
	       * Right / Left
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      'inset-x': [{
	        'inset-x': [inset]
	      }],
	      /**
	       * Top / Bottom
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      'inset-y': [{
	        'inset-y': [inset]
	      }],
	      /**
	       * Start
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      start: [{
	        start: [inset]
	      }],
	      /**
	       * End
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      end: [{
	        end: [inset]
	      }],
	      /**
	       * Top
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      top: [{
	        top: [inset]
	      }],
	      /**
	       * Right
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      right: [{
	        right: [inset]
	      }],
	      /**
	       * Bottom
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      bottom: [{
	        bottom: [inset]
	      }],
	      /**
	       * Left
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      left: [{
	        left: [inset]
	      }],
	      /**
	       * Visibility
	       * @see https://tailwindcss.com/docs/visibility
	       */
	      visibility: ['visible', 'invisible', 'collapse'],
	      /**
	       * Z-Index
	       * @see https://tailwindcss.com/docs/z-index
	       */
	      z: [{
	        z: ['auto', isInteger$1, isArbitraryValue$1]
	      }],
	      // Flexbox and Grid
	      /**
	       * Flex Basis
	       * @see https://tailwindcss.com/docs/flex-basis
	       */
	      basis: [{
	        basis: getSpacingWithAutoAndArbitrary()
	      }],
	      /**
	       * Flex Direction
	       * @see https://tailwindcss.com/docs/flex-direction
	       */
	      'flex-direction': [{
	        flex: ['row', 'row-reverse', 'col', 'col-reverse']
	      }],
	      /**
	       * Flex Wrap
	       * @see https://tailwindcss.com/docs/flex-wrap
	       */
	      'flex-wrap': [{
	        flex: ['wrap', 'wrap-reverse', 'nowrap']
	      }],
	      /**
	       * Flex
	       * @see https://tailwindcss.com/docs/flex
	       */
	      flex: [{
	        flex: ['1', 'auto', 'initial', 'none', isArbitraryValue$1]
	      }],
	      /**
	       * Flex Grow
	       * @see https://tailwindcss.com/docs/flex-grow
	       */
	      grow: [{
	        grow: getZeroAndEmpty()
	      }],
	      /**
	       * Flex Shrink
	       * @see https://tailwindcss.com/docs/flex-shrink
	       */
	      shrink: [{
	        shrink: getZeroAndEmpty()
	      }],
	      /**
	       * Order
	       * @see https://tailwindcss.com/docs/order
	       */
	      order: [{
	        order: ['first', 'last', 'none', isInteger$1, isArbitraryValue$1]
	      }],
	      /**
	       * Grid Template Columns
	       * @see https://tailwindcss.com/docs/grid-template-columns
	       */
	      'grid-cols': [{
	        'grid-cols': [isAny$1]
	      }],
	      /**
	       * Grid Column Start / End
	       * @see https://tailwindcss.com/docs/grid-column
	       */
	      'col-start-end': [{
	        col: ['auto', {
	          span: ['full', isInteger$1, isArbitraryValue$1]
	        }, isArbitraryValue$1]
	      }],
	      /**
	       * Grid Column Start
	       * @see https://tailwindcss.com/docs/grid-column
	       */
	      'col-start': [{
	        'col-start': getNumberWithAutoAndArbitrary()
	      }],
	      /**
	       * Grid Column End
	       * @see https://tailwindcss.com/docs/grid-column
	       */
	      'col-end': [{
	        'col-end': getNumberWithAutoAndArbitrary()
	      }],
	      /**
	       * Grid Template Rows
	       * @see https://tailwindcss.com/docs/grid-template-rows
	       */
	      'grid-rows': [{
	        'grid-rows': [isAny$1]
	      }],
	      /**
	       * Grid Row Start / End
	       * @see https://tailwindcss.com/docs/grid-row
	       */
	      'row-start-end': [{
	        row: ['auto', {
	          span: [isInteger$1, isArbitraryValue$1]
	        }, isArbitraryValue$1]
	      }],
	      /**
	       * Grid Row Start
	       * @see https://tailwindcss.com/docs/grid-row
	       */
	      'row-start': [{
	        'row-start': getNumberWithAutoAndArbitrary()
	      }],
	      /**
	       * Grid Row End
	       * @see https://tailwindcss.com/docs/grid-row
	       */
	      'row-end': [{
	        'row-end': getNumberWithAutoAndArbitrary()
	      }],
	      /**
	       * Grid Auto Flow
	       * @see https://tailwindcss.com/docs/grid-auto-flow
	       */
	      'grid-flow': [{
	        'grid-flow': ['row', 'col', 'dense', 'row-dense', 'col-dense']
	      }],
	      /**
	       * Grid Auto Columns
	       * @see https://tailwindcss.com/docs/grid-auto-columns
	       */
	      'auto-cols': [{
	        'auto-cols': ['auto', 'min', 'max', 'fr', isArbitraryValue$1]
	      }],
	      /**
	       * Grid Auto Rows
	       * @see https://tailwindcss.com/docs/grid-auto-rows
	       */
	      'auto-rows': [{
	        'auto-rows': ['auto', 'min', 'max', 'fr', isArbitraryValue$1]
	      }],
	      /**
	       * Gap
	       * @see https://tailwindcss.com/docs/gap
	       */
	      gap: [{
	        gap: [gap]
	      }],
	      /**
	       * Gap X
	       * @see https://tailwindcss.com/docs/gap
	       */
	      'gap-x': [{
	        'gap-x': [gap]
	      }],
	      /**
	       * Gap Y
	       * @see https://tailwindcss.com/docs/gap
	       */
	      'gap-y': [{
	        'gap-y': [gap]
	      }],
	      /**
	       * Justify Content
	       * @see https://tailwindcss.com/docs/justify-content
	       */
	      'justify-content': [{
	        justify: ['normal', ...getAlign()]
	      }],
	      /**
	       * Justify Items
	       * @see https://tailwindcss.com/docs/justify-items
	       */
	      'justify-items': [{
	        'justify-items': ['start', 'end', 'center', 'stretch']
	      }],
	      /**
	       * Justify Self
	       * @see https://tailwindcss.com/docs/justify-self
	       */
	      'justify-self': [{
	        'justify-self': ['auto', 'start', 'end', 'center', 'stretch']
	      }],
	      /**
	       * Align Content
	       * @see https://tailwindcss.com/docs/align-content
	       */
	      'align-content': [{
	        content: ['normal', ...getAlign(), 'baseline']
	      }],
	      /**
	       * Align Items
	       * @see https://tailwindcss.com/docs/align-items
	       */
	      'align-items': [{
	        items: ['start', 'end', 'center', 'baseline', 'stretch']
	      }],
	      /**
	       * Align Self
	       * @see https://tailwindcss.com/docs/align-self
	       */
	      'align-self': [{
	        self: ['auto', 'start', 'end', 'center', 'stretch', 'baseline']
	      }],
	      /**
	       * Place Content
	       * @see https://tailwindcss.com/docs/place-content
	       */
	      'place-content': [{
	        'place-content': [...getAlign(), 'baseline']
	      }],
	      /**
	       * Place Items
	       * @see https://tailwindcss.com/docs/place-items
	       */
	      'place-items': [{
	        'place-items': ['start', 'end', 'center', 'baseline', 'stretch']
	      }],
	      /**
	       * Place Self
	       * @see https://tailwindcss.com/docs/place-self
	       */
	      'place-self': [{
	        'place-self': ['auto', 'start', 'end', 'center', 'stretch']
	      }],
	      // Spacing
	      /**
	       * Padding
	       * @see https://tailwindcss.com/docs/padding
	       */
	      p: [{
	        p: [padding]
	      }],
	      /**
	       * Padding X
	       * @see https://tailwindcss.com/docs/padding
	       */
	      px: [{
	        px: [padding]
	      }],
	      /**
	       * Padding Y
	       * @see https://tailwindcss.com/docs/padding
	       */
	      py: [{
	        py: [padding]
	      }],
	      /**
	       * Padding Start
	       * @see https://tailwindcss.com/docs/padding
	       */
	      ps: [{
	        ps: [padding]
	      }],
	      /**
	       * Padding End
	       * @see https://tailwindcss.com/docs/padding
	       */
	      pe: [{
	        pe: [padding]
	      }],
	      /**
	       * Padding Top
	       * @see https://tailwindcss.com/docs/padding
	       */
	      pt: [{
	        pt: [padding]
	      }],
	      /**
	       * Padding Right
	       * @see https://tailwindcss.com/docs/padding
	       */
	      pr: [{
	        pr: [padding]
	      }],
	      /**
	       * Padding Bottom
	       * @see https://tailwindcss.com/docs/padding
	       */
	      pb: [{
	        pb: [padding]
	      }],
	      /**
	       * Padding Left
	       * @see https://tailwindcss.com/docs/padding
	       */
	      pl: [{
	        pl: [padding]
	      }],
	      /**
	       * Margin
	       * @see https://tailwindcss.com/docs/margin
	       */
	      m: [{
	        m: [margin]
	      }],
	      /**
	       * Margin X
	       * @see https://tailwindcss.com/docs/margin
	       */
	      mx: [{
	        mx: [margin]
	      }],
	      /**
	       * Margin Y
	       * @see https://tailwindcss.com/docs/margin
	       */
	      my: [{
	        my: [margin]
	      }],
	      /**
	       * Margin Start
	       * @see https://tailwindcss.com/docs/margin
	       */
	      ms: [{
	        ms: [margin]
	      }],
	      /**
	       * Margin End
	       * @see https://tailwindcss.com/docs/margin
	       */
	      me: [{
	        me: [margin]
	      }],
	      /**
	       * Margin Top
	       * @see https://tailwindcss.com/docs/margin
	       */
	      mt: [{
	        mt: [margin]
	      }],
	      /**
	       * Margin Right
	       * @see https://tailwindcss.com/docs/margin
	       */
	      mr: [{
	        mr: [margin]
	      }],
	      /**
	       * Margin Bottom
	       * @see https://tailwindcss.com/docs/margin
	       */
	      mb: [{
	        mb: [margin]
	      }],
	      /**
	       * Margin Left
	       * @see https://tailwindcss.com/docs/margin
	       */
	      ml: [{
	        ml: [margin]
	      }],
	      /**
	       * Space Between X
	       * @see https://tailwindcss.com/docs/space
	       */
	      'space-x': [{
	        'space-x': [space]
	      }],
	      /**
	       * Space Between X Reverse
	       * @see https://tailwindcss.com/docs/space
	       */
	      'space-x-reverse': ['space-x-reverse'],
	      /**
	       * Space Between Y
	       * @see https://tailwindcss.com/docs/space
	       */
	      'space-y': [{
	        'space-y': [space]
	      }],
	      /**
	       * Space Between Y Reverse
	       * @see https://tailwindcss.com/docs/space
	       */
	      'space-y-reverse': ['space-y-reverse'],
	      // Sizing
	      /**
	       * Width
	       * @see https://tailwindcss.com/docs/width
	       */
	      w: [{
	        w: ['auto', 'min', 'max', 'fit', 'svw', 'lvw', 'dvw', isArbitraryValue$1, spacing]
	      }],
	      /**
	       * Min-Width
	       * @see https://tailwindcss.com/docs/min-width
	       */
	      'min-w': [{
	        'min-w': [isArbitraryValue$1, spacing, 'min', 'max', 'fit']
	      }],
	      /**
	       * Max-Width
	       * @see https://tailwindcss.com/docs/max-width
	       */
	      'max-w': [{
	        'max-w': [isArbitraryValue$1, spacing, 'none', 'full', 'min', 'max', 'fit', 'prose', {
	          screen: [isTshirtSize$1]
	        }, isTshirtSize$1]
	      }],
	      /**
	       * Height
	       * @see https://tailwindcss.com/docs/height
	       */
	      h: [{
	        h: [isArbitraryValue$1, spacing, 'auto', 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']
	      }],
	      /**
	       * Min-Height
	       * @see https://tailwindcss.com/docs/min-height
	       */
	      'min-h': [{
	        'min-h': [isArbitraryValue$1, spacing, 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']
	      }],
	      /**
	       * Max-Height
	       * @see https://tailwindcss.com/docs/max-height
	       */
	      'max-h': [{
	        'max-h': [isArbitraryValue$1, spacing, 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']
	      }],
	      /**
	       * Size
	       * @see https://tailwindcss.com/docs/size
	       */
	      size: [{
	        size: [isArbitraryValue$1, spacing, 'auto', 'min', 'max', 'fit']
	      }],
	      // Typography
	      /**
	       * Font Size
	       * @see https://tailwindcss.com/docs/font-size
	       */
	      'font-size': [{
	        text: ['base', isTshirtSize$1, isArbitraryLength$1]
	      }],
	      /**
	       * Font Smoothing
	       * @see https://tailwindcss.com/docs/font-smoothing
	       */
	      'font-smoothing': ['antialiased', 'subpixel-antialiased'],
	      /**
	       * Font Style
	       * @see https://tailwindcss.com/docs/font-style
	       */
	      'font-style': ['italic', 'not-italic'],
	      /**
	       * Font Weight
	       * @see https://tailwindcss.com/docs/font-weight
	       */
	      'font-weight': [{
	        font: ['thin', 'extralight', 'light', 'normal', 'medium', 'semibold', 'bold', 'extrabold', 'black', isArbitraryNumber$1]
	      }],
	      /**
	       * Font Family
	       * @see https://tailwindcss.com/docs/font-family
	       */
	      'font-family': [{
	        font: [isAny$1]
	      }],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-normal': ['normal-nums'],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-ordinal': ['ordinal'],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-slashed-zero': ['slashed-zero'],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-figure': ['lining-nums', 'oldstyle-nums'],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-spacing': ['proportional-nums', 'tabular-nums'],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-fraction': ['diagonal-fractions', 'stacked-fractons'],
	      /**
	       * Letter Spacing
	       * @see https://tailwindcss.com/docs/letter-spacing
	       */
	      tracking: [{
	        tracking: ['tighter', 'tight', 'normal', 'wide', 'wider', 'widest', isArbitraryValue$1]
	      }],
	      /**
	       * Line Clamp
	       * @see https://tailwindcss.com/docs/line-clamp
	       */
	      'line-clamp': [{
	        'line-clamp': ['none', isNumber$1, isArbitraryNumber$1]
	      }],
	      /**
	       * Line Height
	       * @see https://tailwindcss.com/docs/line-height
	       */
	      leading: [{
	        leading: ['none', 'tight', 'snug', 'normal', 'relaxed', 'loose', isLength$1, isArbitraryValue$1]
	      }],
	      /**
	       * List Style Image
	       * @see https://tailwindcss.com/docs/list-style-image
	       */
	      'list-image': [{
	        'list-image': ['none', isArbitraryValue$1]
	      }],
	      /**
	       * List Style Type
	       * @see https://tailwindcss.com/docs/list-style-type
	       */
	      'list-style-type': [{
	        list: ['none', 'disc', 'decimal', isArbitraryValue$1]
	      }],
	      /**
	       * List Style Position
	       * @see https://tailwindcss.com/docs/list-style-position
	       */
	      'list-style-position': [{
	        list: ['inside', 'outside']
	      }],
	      /**
	       * Placeholder Color
	       * @deprecated since Tailwind CSS v3.0.0
	       * @see https://tailwindcss.com/docs/placeholder-color
	       */
	      'placeholder-color': [{
	        placeholder: [colors]
	      }],
	      /**
	       * Placeholder Opacity
	       * @see https://tailwindcss.com/docs/placeholder-opacity
	       */
	      'placeholder-opacity': [{
	        'placeholder-opacity': [opacity]
	      }],
	      /**
	       * Text Alignment
	       * @see https://tailwindcss.com/docs/text-align
	       */
	      'text-alignment': [{
	        text: ['left', 'center', 'right', 'justify', 'start', 'end']
	      }],
	      /**
	       * Text Color
	       * @see https://tailwindcss.com/docs/text-color
	       */
	      'text-color': [{
	        text: [colors]
	      }],
	      /**
	       * Text Opacity
	       * @see https://tailwindcss.com/docs/text-opacity
	       */
	      'text-opacity': [{
	        'text-opacity': [opacity]
	      }],
	      /**
	       * Text Decoration
	       * @see https://tailwindcss.com/docs/text-decoration
	       */
	      'text-decoration': ['underline', 'overline', 'line-through', 'no-underline'],
	      /**
	       * Text Decoration Style
	       * @see https://tailwindcss.com/docs/text-decoration-style
	       */
	      'text-decoration-style': [{
	        decoration: [...getLineStyles(), 'wavy']
	      }],
	      /**
	       * Text Decoration Thickness
	       * @see https://tailwindcss.com/docs/text-decoration-thickness
	       */
	      'text-decoration-thickness': [{
	        decoration: ['auto', 'from-font', isLength$1, isArbitraryLength$1]
	      }],
	      /**
	       * Text Underline Offset
	       * @see https://tailwindcss.com/docs/text-underline-offset
	       */
	      'underline-offset': [{
	        'underline-offset': ['auto', isLength$1, isArbitraryValue$1]
	      }],
	      /**
	       * Text Decoration Color
	       * @see https://tailwindcss.com/docs/text-decoration-color
	       */
	      'text-decoration-color': [{
	        decoration: [colors]
	      }],
	      /**
	       * Text Transform
	       * @see https://tailwindcss.com/docs/text-transform
	       */
	      'text-transform': ['uppercase', 'lowercase', 'capitalize', 'normal-case'],
	      /**
	       * Text Overflow
	       * @see https://tailwindcss.com/docs/text-overflow
	       */
	      'text-overflow': ['truncate', 'text-ellipsis', 'text-clip'],
	      /**
	       * Text Wrap
	       * @see https://tailwindcss.com/docs/text-wrap
	       */
	      'text-wrap': [{
	        text: ['wrap', 'nowrap', 'balance', 'pretty']
	      }],
	      /**
	       * Text Indent
	       * @see https://tailwindcss.com/docs/text-indent
	       */
	      indent: [{
	        indent: getSpacingWithArbitrary()
	      }],
	      /**
	       * Vertical Alignment
	       * @see https://tailwindcss.com/docs/vertical-align
	       */
	      'vertical-align': [{
	        align: ['baseline', 'top', 'middle', 'bottom', 'text-top', 'text-bottom', 'sub', 'super', isArbitraryValue$1]
	      }],
	      /**
	       * Whitespace
	       * @see https://tailwindcss.com/docs/whitespace
	       */
	      whitespace: [{
	        whitespace: ['normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'break-spaces']
	      }],
	      /**
	       * Word Break
	       * @see https://tailwindcss.com/docs/word-break
	       */
	      break: [{
	        break: ['normal', 'words', 'all', 'keep']
	      }],
	      /**
	       * Hyphens
	       * @see https://tailwindcss.com/docs/hyphens
	       */
	      hyphens: [{
	        hyphens: ['none', 'manual', 'auto']
	      }],
	      /**
	       * Content
	       * @see https://tailwindcss.com/docs/content
	       */
	      content: [{
	        content: ['none', isArbitraryValue$1]
	      }],
	      // Backgrounds
	      /**
	       * Background Attachment
	       * @see https://tailwindcss.com/docs/background-attachment
	       */
	      'bg-attachment': [{
	        bg: ['fixed', 'local', 'scroll']
	      }],
	      /**
	       * Background Clip
	       * @see https://tailwindcss.com/docs/background-clip
	       */
	      'bg-clip': [{
	        'bg-clip': ['border', 'padding', 'content', 'text']
	      }],
	      /**
	       * Background Opacity
	       * @deprecated since Tailwind CSS v3.0.0
	       * @see https://tailwindcss.com/docs/background-opacity
	       */
	      'bg-opacity': [{
	        'bg-opacity': [opacity]
	      }],
	      /**
	       * Background Origin
	       * @see https://tailwindcss.com/docs/background-origin
	       */
	      'bg-origin': [{
	        'bg-origin': ['border', 'padding', 'content']
	      }],
	      /**
	       * Background Position
	       * @see https://tailwindcss.com/docs/background-position
	       */
	      'bg-position': [{
	        bg: [...getPositions(), isArbitraryPosition$1]
	      }],
	      /**
	       * Background Repeat
	       * @see https://tailwindcss.com/docs/background-repeat
	       */
	      'bg-repeat': [{
	        bg: ['no-repeat', {
	          repeat: ['', 'x', 'y', 'round', 'space']
	        }]
	      }],
	      /**
	       * Background Size
	       * @see https://tailwindcss.com/docs/background-size
	       */
	      'bg-size': [{
	        bg: ['auto', 'cover', 'contain', isArbitrarySize$1]
	      }],
	      /**
	       * Background Image
	       * @see https://tailwindcss.com/docs/background-image
	       */
	      'bg-image': [{
	        bg: ['none', {
	          'gradient-to': ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl']
	        }, isArbitraryImage]
	      }],
	      /**
	       * Background Color
	       * @see https://tailwindcss.com/docs/background-color
	       */
	      'bg-color': [{
	        bg: [colors]
	      }],
	      /**
	       * Gradient Color Stops From Position
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-from-pos': [{
	        from: [gradientColorStopPositions]
	      }],
	      /**
	       * Gradient Color Stops Via Position
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-via-pos': [{
	        via: [gradientColorStopPositions]
	      }],
	      /**
	       * Gradient Color Stops To Position
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-to-pos': [{
	        to: [gradientColorStopPositions]
	      }],
	      /**
	       * Gradient Color Stops From
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-from': [{
	        from: [gradientColorStops]
	      }],
	      /**
	       * Gradient Color Stops Via
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-via': [{
	        via: [gradientColorStops]
	      }],
	      /**
	       * Gradient Color Stops To
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-to': [{
	        to: [gradientColorStops]
	      }],
	      // Borders
	      /**
	       * Border Radius
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      rounded: [{
	        rounded: [borderRadius]
	      }],
	      /**
	       * Border Radius Start
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-s': [{
	        'rounded-s': [borderRadius]
	      }],
	      /**
	       * Border Radius End
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-e': [{
	        'rounded-e': [borderRadius]
	      }],
	      /**
	       * Border Radius Top
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-t': [{
	        'rounded-t': [borderRadius]
	      }],
	      /**
	       * Border Radius Right
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-r': [{
	        'rounded-r': [borderRadius]
	      }],
	      /**
	       * Border Radius Bottom
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-b': [{
	        'rounded-b': [borderRadius]
	      }],
	      /**
	       * Border Radius Left
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-l': [{
	        'rounded-l': [borderRadius]
	      }],
	      /**
	       * Border Radius Start Start
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-ss': [{
	        'rounded-ss': [borderRadius]
	      }],
	      /**
	       * Border Radius Start End
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-se': [{
	        'rounded-se': [borderRadius]
	      }],
	      /**
	       * Border Radius End End
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-ee': [{
	        'rounded-ee': [borderRadius]
	      }],
	      /**
	       * Border Radius End Start
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-es': [{
	        'rounded-es': [borderRadius]
	      }],
	      /**
	       * Border Radius Top Left
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-tl': [{
	        'rounded-tl': [borderRadius]
	      }],
	      /**
	       * Border Radius Top Right
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-tr': [{
	        'rounded-tr': [borderRadius]
	      }],
	      /**
	       * Border Radius Bottom Right
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-br': [{
	        'rounded-br': [borderRadius]
	      }],
	      /**
	       * Border Radius Bottom Left
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-bl': [{
	        'rounded-bl': [borderRadius]
	      }],
	      /**
	       * Border Width
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w': [{
	        border: [borderWidth]
	      }],
	      /**
	       * Border Width X
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-x': [{
	        'border-x': [borderWidth]
	      }],
	      /**
	       * Border Width Y
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-y': [{
	        'border-y': [borderWidth]
	      }],
	      /**
	       * Border Width Start
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-s': [{
	        'border-s': [borderWidth]
	      }],
	      /**
	       * Border Width End
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-e': [{
	        'border-e': [borderWidth]
	      }],
	      /**
	       * Border Width Top
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-t': [{
	        'border-t': [borderWidth]
	      }],
	      /**
	       * Border Width Right
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-r': [{
	        'border-r': [borderWidth]
	      }],
	      /**
	       * Border Width Bottom
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-b': [{
	        'border-b': [borderWidth]
	      }],
	      /**
	       * Border Width Left
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-l': [{
	        'border-l': [borderWidth]
	      }],
	      /**
	       * Border Opacity
	       * @see https://tailwindcss.com/docs/border-opacity
	       */
	      'border-opacity': [{
	        'border-opacity': [opacity]
	      }],
	      /**
	       * Border Style
	       * @see https://tailwindcss.com/docs/border-style
	       */
	      'border-style': [{
	        border: [...getLineStyles(), 'hidden']
	      }],
	      /**
	       * Divide Width X
	       * @see https://tailwindcss.com/docs/divide-width
	       */
	      'divide-x': [{
	        'divide-x': [borderWidth]
	      }],
	      /**
	       * Divide Width X Reverse
	       * @see https://tailwindcss.com/docs/divide-width
	       */
	      'divide-x-reverse': ['divide-x-reverse'],
	      /**
	       * Divide Width Y
	       * @see https://tailwindcss.com/docs/divide-width
	       */
	      'divide-y': [{
	        'divide-y': [borderWidth]
	      }],
	      /**
	       * Divide Width Y Reverse
	       * @see https://tailwindcss.com/docs/divide-width
	       */
	      'divide-y-reverse': ['divide-y-reverse'],
	      /**
	       * Divide Opacity
	       * @see https://tailwindcss.com/docs/divide-opacity
	       */
	      'divide-opacity': [{
	        'divide-opacity': [opacity]
	      }],
	      /**
	       * Divide Style
	       * @see https://tailwindcss.com/docs/divide-style
	       */
	      'divide-style': [{
	        divide: getLineStyles()
	      }],
	      /**
	       * Border Color
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color': [{
	        border: [borderColor]
	      }],
	      /**
	       * Border Color X
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-x': [{
	        'border-x': [borderColor]
	      }],
	      /**
	       * Border Color Y
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-y': [{
	        'border-y': [borderColor]
	      }],
	      /**
	       * Border Color Top
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-t': [{
	        'border-t': [borderColor]
	      }],
	      /**
	       * Border Color Right
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-r': [{
	        'border-r': [borderColor]
	      }],
	      /**
	       * Border Color Bottom
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-b': [{
	        'border-b': [borderColor]
	      }],
	      /**
	       * Border Color Left
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-l': [{
	        'border-l': [borderColor]
	      }],
	      /**
	       * Divide Color
	       * @see https://tailwindcss.com/docs/divide-color
	       */
	      'divide-color': [{
	        divide: [borderColor]
	      }],
	      /**
	       * Outline Style
	       * @see https://tailwindcss.com/docs/outline-style
	       */
	      'outline-style': [{
	        outline: ['', ...getLineStyles()]
	      }],
	      /**
	       * Outline Offset
	       * @see https://tailwindcss.com/docs/outline-offset
	       */
	      'outline-offset': [{
	        'outline-offset': [isLength$1, isArbitraryValue$1]
	      }],
	      /**
	       * Outline Width
	       * @see https://tailwindcss.com/docs/outline-width
	       */
	      'outline-w': [{
	        outline: [isLength$1, isArbitraryLength$1]
	      }],
	      /**
	       * Outline Color
	       * @see https://tailwindcss.com/docs/outline-color
	       */
	      'outline-color': [{
	        outline: [colors]
	      }],
	      /**
	       * Ring Width
	       * @see https://tailwindcss.com/docs/ring-width
	       */
	      'ring-w': [{
	        ring: getLengthWithEmptyAndArbitrary()
	      }],
	      /**
	       * Ring Width Inset
	       * @see https://tailwindcss.com/docs/ring-width
	       */
	      'ring-w-inset': ['ring-inset'],
	      /**
	       * Ring Color
	       * @see https://tailwindcss.com/docs/ring-color
	       */
	      'ring-color': [{
	        ring: [colors]
	      }],
	      /**
	       * Ring Opacity
	       * @see https://tailwindcss.com/docs/ring-opacity
	       */
	      'ring-opacity': [{
	        'ring-opacity': [opacity]
	      }],
	      /**
	       * Ring Offset Width
	       * @see https://tailwindcss.com/docs/ring-offset-width
	       */
	      'ring-offset-w': [{
	        'ring-offset': [isLength$1, isArbitraryLength$1]
	      }],
	      /**
	       * Ring Offset Color
	       * @see https://tailwindcss.com/docs/ring-offset-color
	       */
	      'ring-offset-color': [{
	        'ring-offset': [colors]
	      }],
	      // Effects
	      /**
	       * Box Shadow
	       * @see https://tailwindcss.com/docs/box-shadow
	       */
	      shadow: [{
	        shadow: ['', 'inner', 'none', isTshirtSize$1, isArbitraryShadow$1]
	      }],
	      /**
	       * Box Shadow Color
	       * @see https://tailwindcss.com/docs/box-shadow-color
	       */
	      'shadow-color': [{
	        shadow: [isAny$1]
	      }],
	      /**
	       * Opacity
	       * @see https://tailwindcss.com/docs/opacity
	       */
	      opacity: [{
	        opacity: [opacity]
	      }],
	      /**
	       * Mix Blend Mode
	       * @see https://tailwindcss.com/docs/mix-blend-mode
	       */
	      'mix-blend': [{
	        'mix-blend': getBlendModes()
	      }],
	      /**
	       * Background Blend Mode
	       * @see https://tailwindcss.com/docs/background-blend-mode
	       */
	      'bg-blend': [{
	        'bg-blend': getBlendModes()
	      }],
	      // Filters
	      /**
	       * Filter
	       * @deprecated since Tailwind CSS v3.0.0
	       * @see https://tailwindcss.com/docs/filter
	       */
	      filter: [{
	        filter: ['', 'none']
	      }],
	      /**
	       * Blur
	       * @see https://tailwindcss.com/docs/blur
	       */
	      blur: [{
	        blur: [blur]
	      }],
	      /**
	       * Brightness
	       * @see https://tailwindcss.com/docs/brightness
	       */
	      brightness: [{
	        brightness: [brightness]
	      }],
	      /**
	       * Contrast
	       * @see https://tailwindcss.com/docs/contrast
	       */
	      contrast: [{
	        contrast: [contrast]
	      }],
	      /**
	       * Drop Shadow
	       * @see https://tailwindcss.com/docs/drop-shadow
	       */
	      'drop-shadow': [{
	        'drop-shadow': ['', 'none', isTshirtSize$1, isArbitraryValue$1]
	      }],
	      /**
	       * Grayscale
	       * @see https://tailwindcss.com/docs/grayscale
	       */
	      grayscale: [{
	        grayscale: [grayscale]
	      }],
	      /**
	       * Hue Rotate
	       * @see https://tailwindcss.com/docs/hue-rotate
	       */
	      'hue-rotate': [{
	        'hue-rotate': [hueRotate]
	      }],
	      /**
	       * Invert
	       * @see https://tailwindcss.com/docs/invert
	       */
	      invert: [{
	        invert: [invert]
	      }],
	      /**
	       * Saturate
	       * @see https://tailwindcss.com/docs/saturate
	       */
	      saturate: [{
	        saturate: [saturate]
	      }],
	      /**
	       * Sepia
	       * @see https://tailwindcss.com/docs/sepia
	       */
	      sepia: [{
	        sepia: [sepia]
	      }],
	      /**
	       * Backdrop Filter
	       * @deprecated since Tailwind CSS v3.0.0
	       * @see https://tailwindcss.com/docs/backdrop-filter
	       */
	      'backdrop-filter': [{
	        'backdrop-filter': ['', 'none']
	      }],
	      /**
	       * Backdrop Blur
	       * @see https://tailwindcss.com/docs/backdrop-blur
	       */
	      'backdrop-blur': [{
	        'backdrop-blur': [blur]
	      }],
	      /**
	       * Backdrop Brightness
	       * @see https://tailwindcss.com/docs/backdrop-brightness
	       */
	      'backdrop-brightness': [{
	        'backdrop-brightness': [brightness]
	      }],
	      /**
	       * Backdrop Contrast
	       * @see https://tailwindcss.com/docs/backdrop-contrast
	       */
	      'backdrop-contrast': [{
	        'backdrop-contrast': [contrast]
	      }],
	      /**
	       * Backdrop Grayscale
	       * @see https://tailwindcss.com/docs/backdrop-grayscale
	       */
	      'backdrop-grayscale': [{
	        'backdrop-grayscale': [grayscale]
	      }],
	      /**
	       * Backdrop Hue Rotate
	       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
	       */
	      'backdrop-hue-rotate': [{
	        'backdrop-hue-rotate': [hueRotate]
	      }],
	      /**
	       * Backdrop Invert
	       * @see https://tailwindcss.com/docs/backdrop-invert
	       */
	      'backdrop-invert': [{
	        'backdrop-invert': [invert]
	      }],
	      /**
	       * Backdrop Opacity
	       * @see https://tailwindcss.com/docs/backdrop-opacity
	       */
	      'backdrop-opacity': [{
	        'backdrop-opacity': [opacity]
	      }],
	      /**
	       * Backdrop Saturate
	       * @see https://tailwindcss.com/docs/backdrop-saturate
	       */
	      'backdrop-saturate': [{
	        'backdrop-saturate': [saturate]
	      }],
	      /**
	       * Backdrop Sepia
	       * @see https://tailwindcss.com/docs/backdrop-sepia
	       */
	      'backdrop-sepia': [{
	        'backdrop-sepia': [sepia]
	      }],
	      // Tables
	      /**
	       * Border Collapse
	       * @see https://tailwindcss.com/docs/border-collapse
	       */
	      'border-collapse': [{
	        border: ['collapse', 'separate']
	      }],
	      /**
	       * Border Spacing
	       * @see https://tailwindcss.com/docs/border-spacing
	       */
	      'border-spacing': [{
	        'border-spacing': [borderSpacing]
	      }],
	      /**
	       * Border Spacing X
	       * @see https://tailwindcss.com/docs/border-spacing
	       */
	      'border-spacing-x': [{
	        'border-spacing-x': [borderSpacing]
	      }],
	      /**
	       * Border Spacing Y
	       * @see https://tailwindcss.com/docs/border-spacing
	       */
	      'border-spacing-y': [{
	        'border-spacing-y': [borderSpacing]
	      }],
	      /**
	       * Table Layout
	       * @see https://tailwindcss.com/docs/table-layout
	       */
	      'table-layout': [{
	        table: ['auto', 'fixed']
	      }],
	      /**
	       * Caption Side
	       * @see https://tailwindcss.com/docs/caption-side
	       */
	      caption: [{
	        caption: ['top', 'bottom']
	      }],
	      // Transitions and Animation
	      /**
	       * Tranisition Property
	       * @see https://tailwindcss.com/docs/transition-property
	       */
	      transition: [{
	        transition: ['none', 'all', '', 'colors', 'opacity', 'shadow', 'transform', isArbitraryValue$1]
	      }],
	      /**
	       * Transition Duration
	       * @see https://tailwindcss.com/docs/transition-duration
	       */
	      duration: [{
	        duration: getNumberAndArbitrary()
	      }],
	      /**
	       * Transition Timing Function
	       * @see https://tailwindcss.com/docs/transition-timing-function
	       */
	      ease: [{
	        ease: ['linear', 'in', 'out', 'in-out', isArbitraryValue$1]
	      }],
	      /**
	       * Transition Delay
	       * @see https://tailwindcss.com/docs/transition-delay
	       */
	      delay: [{
	        delay: getNumberAndArbitrary()
	      }],
	      /**
	       * Animation
	       * @see https://tailwindcss.com/docs/animation
	       */
	      animate: [{
	        animate: ['none', 'spin', 'ping', 'pulse', 'bounce', isArbitraryValue$1]
	      }],
	      // Transforms
	      /**
	       * Transform
	       * @see https://tailwindcss.com/docs/transform
	       */
	      transform: [{
	        transform: ['', 'gpu', 'none']
	      }],
	      /**
	       * Scale
	       * @see https://tailwindcss.com/docs/scale
	       */
	      scale: [{
	        scale: [scale]
	      }],
	      /**
	       * Scale X
	       * @see https://tailwindcss.com/docs/scale
	       */
	      'scale-x': [{
	        'scale-x': [scale]
	      }],
	      /**
	       * Scale Y
	       * @see https://tailwindcss.com/docs/scale
	       */
	      'scale-y': [{
	        'scale-y': [scale]
	      }],
	      /**
	       * Rotate
	       * @see https://tailwindcss.com/docs/rotate
	       */
	      rotate: [{
	        rotate: [isInteger$1, isArbitraryValue$1]
	      }],
	      /**
	       * Translate X
	       * @see https://tailwindcss.com/docs/translate
	       */
	      'translate-x': [{
	        'translate-x': [translate]
	      }],
	      /**
	       * Translate Y
	       * @see https://tailwindcss.com/docs/translate
	       */
	      'translate-y': [{
	        'translate-y': [translate]
	      }],
	      /**
	       * Skew X
	       * @see https://tailwindcss.com/docs/skew
	       */
	      'skew-x': [{
	        'skew-x': [skew]
	      }],
	      /**
	       * Skew Y
	       * @see https://tailwindcss.com/docs/skew
	       */
	      'skew-y': [{
	        'skew-y': [skew]
	      }],
	      /**
	       * Transform Origin
	       * @see https://tailwindcss.com/docs/transform-origin
	       */
	      'transform-origin': [{
	        origin: ['center', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left', isArbitraryValue$1]
	      }],
	      // Interactivity
	      /**
	       * Accent Color
	       * @see https://tailwindcss.com/docs/accent-color
	       */
	      accent: [{
	        accent: ['auto', colors]
	      }],
	      /**
	       * Appearance
	       * @see https://tailwindcss.com/docs/appearance
	       */
	      appearance: [{
	        appearance: ['none', 'auto']
	      }],
	      /**
	       * Cursor
	       * @see https://tailwindcss.com/docs/cursor
	       */
	      cursor: [{
	        cursor: ['auto', 'default', 'pointer', 'wait', 'text', 'move', 'help', 'not-allowed', 'none', 'context-menu', 'progress', 'cell', 'crosshair', 'vertical-text', 'alias', 'copy', 'no-drop', 'grab', 'grabbing', 'all-scroll', 'col-resize', 'row-resize', 'n-resize', 'e-resize', 's-resize', 'w-resize', 'ne-resize', 'nw-resize', 'se-resize', 'sw-resize', 'ew-resize', 'ns-resize', 'nesw-resize', 'nwse-resize', 'zoom-in', 'zoom-out', isArbitraryValue$1]
	      }],
	      /**
	       * Caret Color
	       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
	       */
	      'caret-color': [{
	        caret: [colors]
	      }],
	      /**
	       * Pointer Events
	       * @see https://tailwindcss.com/docs/pointer-events
	       */
	      'pointer-events': [{
	        'pointer-events': ['none', 'auto']
	      }],
	      /**
	       * Resize
	       * @see https://tailwindcss.com/docs/resize
	       */
	      resize: [{
	        resize: ['none', 'y', 'x', '']
	      }],
	      /**
	       * Scroll Behavior
	       * @see https://tailwindcss.com/docs/scroll-behavior
	       */
	      'scroll-behavior': [{
	        scroll: ['auto', 'smooth']
	      }],
	      /**
	       * Scroll Margin
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-m': [{
	        'scroll-m': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin X
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-mx': [{
	        'scroll-mx': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Y
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-my': [{
	        'scroll-my': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Start
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-ms': [{
	        'scroll-ms': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin End
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-me': [{
	        'scroll-me': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Top
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-mt': [{
	        'scroll-mt': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Right
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-mr': [{
	        'scroll-mr': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Bottom
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-mb': [{
	        'scroll-mb': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Left
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-ml': [{
	        'scroll-ml': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-p': [{
	        'scroll-p': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding X
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-px': [{
	        'scroll-px': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Y
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-py': [{
	        'scroll-py': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Start
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-ps': [{
	        'scroll-ps': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding End
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-pe': [{
	        'scroll-pe': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Top
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-pt': [{
	        'scroll-pt': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Right
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-pr': [{
	        'scroll-pr': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Bottom
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-pb': [{
	        'scroll-pb': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Left
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-pl': [{
	        'scroll-pl': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Snap Align
	       * @see https://tailwindcss.com/docs/scroll-snap-align
	       */
	      'snap-align': [{
	        snap: ['start', 'end', 'center', 'align-none']
	      }],
	      /**
	       * Scroll Snap Stop
	       * @see https://tailwindcss.com/docs/scroll-snap-stop
	       */
	      'snap-stop': [{
	        snap: ['normal', 'always']
	      }],
	      /**
	       * Scroll Snap Type
	       * @see https://tailwindcss.com/docs/scroll-snap-type
	       */
	      'snap-type': [{
	        snap: ['none', 'x', 'y', 'both']
	      }],
	      /**
	       * Scroll Snap Type Strictness
	       * @see https://tailwindcss.com/docs/scroll-snap-type
	       */
	      'snap-strictness': [{
	        snap: ['mandatory', 'proximity']
	      }],
	      /**
	       * Touch Action
	       * @see https://tailwindcss.com/docs/touch-action
	       */
	      touch: [{
	        touch: ['auto', 'none', 'manipulation']
	      }],
	      /**
	       * Touch Action X
	       * @see https://tailwindcss.com/docs/touch-action
	       */
	      'touch-x': [{
	        'touch-pan': ['x', 'left', 'right']
	      }],
	      /**
	       * Touch Action Y
	       * @see https://tailwindcss.com/docs/touch-action
	       */
	      'touch-y': [{
	        'touch-pan': ['y', 'up', 'down']
	      }],
	      /**
	       * Touch Action Pinch Zoom
	       * @see https://tailwindcss.com/docs/touch-action
	       */
	      'touch-pz': ['touch-pinch-zoom'],
	      /**
	       * User Select
	       * @see https://tailwindcss.com/docs/user-select
	       */
	      select: [{
	        select: ['none', 'text', 'all', 'auto']
	      }],
	      /**
	       * Will Change
	       * @see https://tailwindcss.com/docs/will-change
	       */
	      'will-change': [{
	        'will-change': ['auto', 'scroll', 'contents', 'transform', isArbitraryValue$1]
	      }],
	      // SVG
	      /**
	       * Fill
	       * @see https://tailwindcss.com/docs/fill
	       */
	      fill: [{
	        fill: [colors, 'none']
	      }],
	      /**
	       * Stroke Width
	       * @see https://tailwindcss.com/docs/stroke-width
	       */
	      'stroke-w': [{
	        stroke: [isLength$1, isArbitraryLength$1, isArbitraryNumber$1]
	      }],
	      /**
	       * Stroke
	       * @see https://tailwindcss.com/docs/stroke
	       */
	      stroke: [{
	        stroke: [colors, 'none']
	      }],
	      // Accessibility
	      /**
	       * Screen Readers
	       * @see https://tailwindcss.com/docs/screen-readers
	       */
	      sr: ['sr-only', 'not-sr-only'],
	      /**
	       * Forced Color Adjust
	       * @see https://tailwindcss.com/docs/forced-color-adjust
	       */
	      'forced-color-adjust': [{
	        'forced-color-adjust': ['auto', 'none']
	      }]
	    },
	    conflictingClassGroups: {
	      overflow: ['overflow-x', 'overflow-y'],
	      overscroll: ['overscroll-x', 'overscroll-y'],
	      inset: ['inset-x', 'inset-y', 'start', 'end', 'top', 'right', 'bottom', 'left'],
	      'inset-x': ['right', 'left'],
	      'inset-y': ['top', 'bottom'],
	      flex: ['basis', 'grow', 'shrink'],
	      gap: ['gap-x', 'gap-y'],
	      p: ['px', 'py', 'ps', 'pe', 'pt', 'pr', 'pb', 'pl'],
	      px: ['pr', 'pl'],
	      py: ['pt', 'pb'],
	      m: ['mx', 'my', 'ms', 'me', 'mt', 'mr', 'mb', 'ml'],
	      mx: ['mr', 'ml'],
	      my: ['mt', 'mb'],
	      size: ['w', 'h'],
	      'font-size': ['leading'],
	      'fvn-normal': ['fvn-ordinal', 'fvn-slashed-zero', 'fvn-figure', 'fvn-spacing', 'fvn-fraction'],
	      'fvn-ordinal': ['fvn-normal'],
	      'fvn-slashed-zero': ['fvn-normal'],
	      'fvn-figure': ['fvn-normal'],
	      'fvn-spacing': ['fvn-normal'],
	      'fvn-fraction': ['fvn-normal'],
	      'line-clamp': ['display', 'overflow'],
	      rounded: ['rounded-s', 'rounded-e', 'rounded-t', 'rounded-r', 'rounded-b', 'rounded-l', 'rounded-ss', 'rounded-se', 'rounded-ee', 'rounded-es', 'rounded-tl', 'rounded-tr', 'rounded-br', 'rounded-bl'],
	      'rounded-s': ['rounded-ss', 'rounded-es'],
	      'rounded-e': ['rounded-se', 'rounded-ee'],
	      'rounded-t': ['rounded-tl', 'rounded-tr'],
	      'rounded-r': ['rounded-tr', 'rounded-br'],
	      'rounded-b': ['rounded-br', 'rounded-bl'],
	      'rounded-l': ['rounded-tl', 'rounded-bl'],
	      'border-spacing': ['border-spacing-x', 'border-spacing-y'],
	      'border-w': ['border-w-s', 'border-w-e', 'border-w-t', 'border-w-r', 'border-w-b', 'border-w-l'],
	      'border-w-x': ['border-w-r', 'border-w-l'],
	      'border-w-y': ['border-w-t', 'border-w-b'],
	      'border-color': ['border-color-t', 'border-color-r', 'border-color-b', 'border-color-l'],
	      'border-color-x': ['border-color-r', 'border-color-l'],
	      'border-color-y': ['border-color-t', 'border-color-b'],
	      'scroll-m': ['scroll-mx', 'scroll-my', 'scroll-ms', 'scroll-me', 'scroll-mt', 'scroll-mr', 'scroll-mb', 'scroll-ml'],
	      'scroll-mx': ['scroll-mr', 'scroll-ml'],
	      'scroll-my': ['scroll-mt', 'scroll-mb'],
	      'scroll-p': ['scroll-px', 'scroll-py', 'scroll-ps', 'scroll-pe', 'scroll-pt', 'scroll-pr', 'scroll-pb', 'scroll-pl'],
	      'scroll-px': ['scroll-pr', 'scroll-pl'],
	      'scroll-py': ['scroll-pt', 'scroll-pb'],
	      touch: ['touch-x', 'touch-y', 'touch-pz'],
	      'touch-x': ['touch'],
	      'touch-y': ['touch'],
	      'touch-pz': ['touch']
	    },
	    conflictingClassGroupModifiers: {
	      'font-size': ['leading']
	    }
	  };
	}
	const twMerge$1 = /*#__PURE__*/createTailwindMerge$1(getDefaultConfig$1);

	/*
	Adapted from https://github.com/mattdesl
	Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md
	*/

	/**
	 * https://svelte.dev/docs/svelte-easing
	 * @param {number} t
	 * @returns {number}
	 */
	function cubicOut(t) {
		const f = t - 1.0;
		return f * f * f + 1.0;
	}

	function cn(...inputs) {
	    return twMerge$1(clsx(inputs));
	}

	/* src/lib/components/ui/card/card.svelte generated by Svelte v4.2.10 */
	const file$z = "src/lib/components/ui/card/card.svelte";

	function create_fragment$15(ctx) {
		let div;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

		let div_levels = [
			{
				class: div_class_value = cn("rounded-xl border bg-card text-card-foreground shadow", /*className*/ ctx[0])
			},
			/*$$restProps*/ ctx[1]
		];

		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$z, 11, 0, 179);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(div, "click", /*click_handler*/ ctx[4], false, false, false, false),
						listen_dev(div, "focusin", /*focusin_handler*/ ctx[5], false, false, false, false),
						listen_dev(div, "focusout", /*focusout_handler*/ ctx[6], false, false, false, false),
						listen_dev(div, "mouseenter", /*mouseenter_handler*/ ctx[7], false, false, false, false),
						listen_dev(div, "mouseleave", /*mouseleave_handler*/ ctx[8], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[2],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
							null
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					(!current || dirty & /*className*/ 1 && div_class_value !== (div_class_value = cn("rounded-xl border bg-card text-card-foreground shadow", /*className*/ ctx[0]))) && { class: div_class_value },
					dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$15.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$15($$self, $$props, $$invalidate) {
		const omit_props_names = ["class"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Card', slots, ['default']);
		let { class: className = undefined } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function focusin_handler(event) {
			bubble.call(this, $$self, event);
		}

		function focusout_handler(event) {
			bubble.call(this, $$self, event);
		}

		function mouseenter_handler(event) {
			bubble.call(this, $$self, event);
		}

		function mouseleave_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
			if ('$$scope' in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({ cn, className });

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			className,
			$$restProps,
			$$scope,
			slots,
			click_handler,
			focusin_handler,
			focusout_handler,
			mouseenter_handler,
			mouseleave_handler
		];
	}

	let Card$1 = class Card extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$15, create_fragment$15, safe_not_equal, { class: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Card",
				options,
				id: create_fragment$15.name
			});
		}

		get class() {
			throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	};

	/* src/lib/components/ui/card/card-content.svelte generated by Svelte v4.2.10 */
	const file$y = "src/lib/components/ui/card/card-content.svelte";

	function create_fragment$14(ctx) {
		let div;
		let div_class_value;
		let current;
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

		let div_levels = [
			{
				class: div_class_value = cn("p-4 pt-0", /*className*/ ctx[0])
			},
			/*$$restProps*/ ctx[1]
		];

		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$y, 10, 0, 120);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[2],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
							null
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					(!current || dirty & /*className*/ 1 && div_class_value !== (div_class_value = cn("p-4 pt-0", /*className*/ ctx[0]))) && { class: div_class_value },
					dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$14.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$14($$self, $$props, $$invalidate) {
		const omit_props_names = ["class"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Card_content', slots, ['default']);
		let { class: className = undefined } = $$props;

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
			if ('$$scope' in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({ cn, className });

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [className, $$restProps, $$scope, slots];
	}

	class Card_content extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$14, create_fragment$14, safe_not_equal, { class: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Card_content",
				options,
				id: create_fragment$14.name
			});
		}

		get class() {
			throw new Error("<Card_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Card_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/ui/card/card-description.svelte generated by Svelte v4.2.10 */
	const file$x = "src/lib/components/ui/card/card-description.svelte";

	function create_fragment$13(ctx) {
		let p;
		let p_class_value;
		let current;
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

		let p_levels = [
			{
				class: p_class_value = cn("text-sm text-muted-foreground", /*className*/ ctx[0])
			},
			/*$$restProps*/ ctx[1]
		];

		let p_data = {};

		for (let i = 0; i < p_levels.length; i += 1) {
			p_data = assign(p_data, p_levels[i]);
		}

		const block = {
			c: function create() {
				p = element("p");
				if (default_slot) default_slot.c();
				set_attributes(p, p_data);
				add_location(p, file$x, 10, 0, 120);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, p, anchor);

				if (default_slot) {
					default_slot.m(p, null);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[2],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
							null
						);
					}
				}

				set_attributes(p, p_data = get_spread_update(p_levels, [
					(!current || dirty & /*className*/ 1 && p_class_value !== (p_class_value = cn("text-sm text-muted-foreground", /*className*/ ctx[0]))) && { class: p_class_value },
					dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(p);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$13.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$13($$self, $$props, $$invalidate) {
		const omit_props_names = ["class"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Card_description', slots, ['default']);
		let { class: className = undefined } = $$props;

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
			if ('$$scope' in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({ cn, className });

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [className, $$restProps, $$scope, slots];
	}

	class Card_description extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$13, create_fragment$13, safe_not_equal, { class: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Card_description",
				options,
				id: create_fragment$13.name
			});
		}

		get class() {
			throw new Error("<Card_description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Card_description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/ui/card/card-footer.svelte generated by Svelte v4.2.10 */
	const file$w = "src/lib/components/ui/card/card-footer.svelte";

	function create_fragment$12(ctx) {
		let div;
		let div_class_value;
		let current;
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

		let div_levels = [
			{
				class: div_class_value = cn("flex items-center p-6 pt-0", /*className*/ ctx[0])
			},
			/*$$restProps*/ ctx[1]
		];

		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$w, 10, 0, 120);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[2],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
							null
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					(!current || dirty & /*className*/ 1 && div_class_value !== (div_class_value = cn("flex items-center p-6 pt-0", /*className*/ ctx[0]))) && { class: div_class_value },
					dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$12.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$12($$self, $$props, $$invalidate) {
		const omit_props_names = ["class"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Card_footer', slots, ['default']);
		let { class: className = undefined } = $$props;

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
			if ('$$scope' in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({ cn, className });

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [className, $$restProps, $$scope, slots];
	}

	class Card_footer extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$12, create_fragment$12, safe_not_equal, { class: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Card_footer",
				options,
				id: create_fragment$12.name
			});
		}

		get class() {
			throw new Error("<Card_footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Card_footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/ui/card/card-header.svelte generated by Svelte v4.2.10 */
	const file$v = "src/lib/components/ui/card/card-header.svelte";

	function create_fragment$11(ctx) {
		let div;
		let div_class_value;
		let current;
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

		let div_levels = [
			{
				class: div_class_value = cn("flex flex-col space-y-1.5 p-6", /*className*/ ctx[0])
			},
			/*$$restProps*/ ctx[1]
		];

		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$v, 10, 0, 120);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[2],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
							null
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					(!current || dirty & /*className*/ 1 && div_class_value !== (div_class_value = cn("flex flex-col space-y-1.5 p-6", /*className*/ ctx[0]))) && { class: div_class_value },
					dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$11.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$11($$self, $$props, $$invalidate) {
		const omit_props_names = ["class"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Card_header', slots, ['default']);
		let { class: className = undefined } = $$props;

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
			if ('$$scope' in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({ cn, className });

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [className, $$restProps, $$scope, slots];
	}

	class Card_header extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$11, create_fragment$11, safe_not_equal, { class: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Card_header",
				options,
				id: create_fragment$11.name
			});
		}

		get class() {
			throw new Error("<Card_header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Card_header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/ui/card/card-title.svelte generated by Svelte v4.2.10 */
	const file$u = "src/lib/components/ui/card/card-title.svelte";

	// (7:0) <svelte:element  this={tag}  class={cn("font-semibold leading-none tracking-tight", className)}  {...$$restProps} >
	function create_dynamic_element$1(ctx) {
		let svelte_element;
		let svelte_element_class_value;
		let current;
		const default_slot_template = /*#slots*/ ctx[4].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

		let svelte_element_levels = [
			{
				class: svelte_element_class_value = cn("font-semibold leading-none tracking-tight", /*className*/ ctx[0])
			},
			/*$$restProps*/ ctx[2]
		];

		let svelte_element_data = {};

		for (let i = 0; i < svelte_element_levels.length; i += 1) {
			svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
		}

		const block = {
			c: function create() {
				svelte_element = element(/*tag*/ ctx[1]);
				if (default_slot) default_slot.c();
				set_dynamic_element_data(/*tag*/ ctx[1])(svelte_element, svelte_element_data);
				add_location(svelte_element, file$u, 14, 0, 143);
			},
			m: function mount(target, anchor) {
				insert_dev(target, svelte_element, anchor);

				if (default_slot) {
					default_slot.m(svelte_element, null);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[3],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
							null
						);
					}
				}

				set_dynamic_element_data(/*tag*/ ctx[1])(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
					(!current || dirty & /*className*/ 1 && svelte_element_class_value !== (svelte_element_class_value = cn("font-semibold leading-none tracking-tight", /*className*/ ctx[0]))) && { class: svelte_element_class_value },
					dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svelte_element);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_dynamic_element$1.name,
			type: "child_dynamic_element",
			source: "(7:0) <svelte:element  this={tag}  class={cn(\\\"font-semibold leading-none tracking-tight\\\", className)}  {...$$restProps} >",
			ctx
		});

		return block;
	}

	function create_fragment$10(ctx) {
		let previous_tag = /*tag*/ ctx[1];
		let svelte_element_anchor;
		let current;
		validate_dynamic_element(/*tag*/ ctx[1]);
		validate_void_dynamic_element(/*tag*/ ctx[1]);
		let svelte_element = /*tag*/ ctx[1] && create_dynamic_element$1(ctx);

		const block = {
			c: function create() {
				if (svelte_element) svelte_element.c();
				svelte_element_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (svelte_element) svelte_element.m(target, anchor);
				insert_dev(target, svelte_element_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (/*tag*/ ctx[1]) {
					if (!previous_tag) {
						svelte_element = create_dynamic_element$1(ctx);
						previous_tag = /*tag*/ ctx[1];
						svelte_element.c();
						svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
					} else if (safe_not_equal(previous_tag, /*tag*/ ctx[1])) {
						svelte_element.d(1);
						validate_dynamic_element(/*tag*/ ctx[1]);
						validate_void_dynamic_element(/*tag*/ ctx[1]);
						svelte_element = create_dynamic_element$1(ctx);
						previous_tag = /*tag*/ ctx[1];
						svelte_element.c();
						svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
					} else {
						svelte_element.p(ctx, dirty);
					}
				} else if (previous_tag) {
					svelte_element.d(1);
					svelte_element = null;
					previous_tag = /*tag*/ ctx[1];
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(svelte_element, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(svelte_element, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svelte_element_anchor);
				}

				if (svelte_element) svelte_element.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$10.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$10($$self, $$props, $$invalidate) {
		const omit_props_names = ["class","tag"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Card_title', slots, ['default']);
		let { class: className = undefined } = $$props;
		let { tag = "h3" } = $$props;

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
			if ('tag' in $$new_props) $$invalidate(1, tag = $$new_props.tag);
			if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({ cn, className, tag });

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
			if ('tag' in $$props) $$invalidate(1, tag = $$new_props.tag);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [className, tag, $$restProps, $$scope, slots];
	}

	class Card_title extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$10, create_fragment$10, safe_not_equal, { class: 0, tag: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Card_title",
				options,
				id: create_fragment$10.name
			});
		}

		get class() {
			throw new Error("<Card_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Card_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get tag() {
			throw new Error("<Card_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set tag(value) {
			throw new Error("<Card_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var Card = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Card: Card$1,
		CardContent: Card_content,
		CardDescription: Card_description,
		CardFooter: Card_footer,
		CardHeader: Card_header,
		CardTitle: Card_title,
		Content: Card_content,
		Description: Card_description,
		Footer: Card_footer,
		Header: Card_header,
		Root: Card$1,
		Title: Card_title
	});

	/* node_modules/radix-icons-svelte/Icons/ChevronDown.svelte generated by Svelte v4.2.10 */
	const file$t = "node_modules/radix-icons-svelte/Icons/ChevronDown.svelte";

	function create_fragment$$(ctx) {
		let svg;
		let path;

		let svg_levels = [
			{ width: /*size*/ ctx[1] },
			{ height: /*size*/ ctx[1] },
			{ viewBox: "0 0 15 15" },
			{ fill: "none" },
			{ xmlns: "http://www.w3.org/2000/svg" },
			/*$$restProps*/ ctx[2]
		];

		let svg_data = {};

		for (let i = 0; i < svg_levels.length; i += 1) {
			svg_data = assign(svg_data, svg_levels[i]);
		}

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$t, 13, 1, 204);
				set_svg_attributes(svg, svg_data);
				add_location(svg, file$t, 5, 0, 79);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}

				set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
					dirty & /*size*/ 2 && { width: /*size*/ ctx[1] },
					dirty & /*size*/ 2 && { height: /*size*/ ctx[1] },
					{ viewBox: "0 0 15 15" },
					{ fill: "none" },
					{ xmlns: "http://www.w3.org/2000/svg" },
					dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2]
				]));
			},
			i: noop$3,
			o: noop$3,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$$.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$$($$self, $$props, $$invalidate) {
		const omit_props_names = ["color","size"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ChevronDown', slots, []);
		let { color = 'currentColor' } = $$props;
		let { size = 15 } = $$props;

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('color' in $$new_props) $$invalidate(0, color = $$new_props.color);
			if ('size' in $$new_props) $$invalidate(1, size = $$new_props.size);
		};

		$$self.$capture_state = () => ({ color, size });

		$$self.$inject_state = $$new_props => {
			if ('color' in $$props) $$invalidate(0, color = $$new_props.color);
			if ('size' in $$props) $$invalidate(1, size = $$new_props.size);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color, size, $$restProps];
	}

	class ChevronDown extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$$, create_fragment$$, safe_not_equal, { color: 0, size: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ChevronDown",
				options,
				id: create_fragment$$.name
			});
		}

		get color() {
			throw new Error("<ChevronDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<ChevronDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get size() {
			throw new Error("<ChevronDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set size(value) {
			throw new Error("<ChevronDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var ChevronDown$1 = ChevronDown;

	/* node_modules/radix-icons-svelte/Icons/ExternalLink.svelte generated by Svelte v4.2.10 */
	const file$s = "node_modules/radix-icons-svelte/Icons/ExternalLink.svelte";

	function create_fragment$_(ctx) {
		let svg;
		let path;

		let svg_levels = [
			{ width: /*size*/ ctx[1] },
			{ height: /*size*/ ctx[1] },
			{ viewBox: "0 0 15 15" },
			{ fill: "none" },
			{ xmlns: "http://www.w3.org/2000/svg" },
			/*$$restProps*/ ctx[2]
		];

		let svg_data = {};

		for (let i = 0; i < svg_levels.length; i += 1) {
			svg_data = assign(svg_data, svg_levels[i]);
		}

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M3 2C2.44772 2 2 2.44772 2 3V12C2 12.5523 2.44772 13 3 13H12C12.5523 13 13 12.5523 13 12V8.5C13 8.22386 12.7761 8 12.5 8C12.2239 8 12 8.22386 12 8.5V12H3V3L6.5 3C6.77614 3 7 2.77614 7 2.5C7 2.22386 6.77614 2 6.5 2H3ZM12.8536 2.14645C12.9015 2.19439 12.9377 2.24964 12.9621 2.30861C12.9861 2.36669 12.9996 2.4303 13 2.497L13 2.5V2.50049V5.5C13 5.77614 12.7761 6 12.5 6C12.2239 6 12 5.77614 12 5.5V3.70711L6.85355 8.85355C6.65829 9.04882 6.34171 9.04882 6.14645 8.85355C5.95118 8.65829 5.95118 8.34171 6.14645 8.14645L11.2929 3H9.5C9.22386 3 9 2.77614 9 2.5C9 2.22386 9.22386 2 9.5 2H12.4999H12.5C12.5678 2 12.6324 2.01349 12.6914 2.03794C12.7504 2.06234 12.8056 2.09851 12.8536 2.14645Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$s, 13, 1, 204);
				set_svg_attributes(svg, svg_data);
				add_location(svg, file$s, 5, 0, 79);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}

				set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
					dirty & /*size*/ 2 && { width: /*size*/ ctx[1] },
					dirty & /*size*/ 2 && { height: /*size*/ ctx[1] },
					{ viewBox: "0 0 15 15" },
					{ fill: "none" },
					{ xmlns: "http://www.w3.org/2000/svg" },
					dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2]
				]));
			},
			i: noop$3,
			o: noop$3,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$_.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$_($$self, $$props, $$invalidate) {
		const omit_props_names = ["color","size"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ExternalLink', slots, []);
		let { color = 'currentColor' } = $$props;
		let { size = 15 } = $$props;

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('color' in $$new_props) $$invalidate(0, color = $$new_props.color);
			if ('size' in $$new_props) $$invalidate(1, size = $$new_props.size);
		};

		$$self.$capture_state = () => ({ color, size });

		$$self.$inject_state = $$new_props => {
			if ('color' in $$props) $$invalidate(0, color = $$new_props.color);
			if ('size' in $$props) $$invalidate(1, size = $$new_props.size);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color, size, $$restProps];
	}

	class ExternalLink extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$_, create_fragment$_, safe_not_equal, { color: 0, size: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ExternalLink",
				options,
				id: create_fragment$_.name
			});
		}

		get color() {
			throw new Error("<ExternalLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<ExternalLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get size() {
			throw new Error("<ExternalLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set size(value) {
			throw new Error("<ExternalLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var ExternalLink$1 = ExternalLink;

	/* node_modules/radix-icons-svelte/Icons/Pencil1.svelte generated by Svelte v4.2.10 */
	const file$r = "node_modules/radix-icons-svelte/Icons/Pencil1.svelte";

	function create_fragment$Z(ctx) {
		let svg;
		let path;

		let svg_levels = [
			{ width: /*size*/ ctx[1] },
			{ height: /*size*/ ctx[1] },
			{ viewBox: "0 0 15 15" },
			{ fill: "none" },
			{ xmlns: "http://www.w3.org/2000/svg" },
			/*$$restProps*/ ctx[2]
		];

		let svg_data = {};

		for (let i = 0; i < svg_levels.length; i += 1) {
			svg_data = assign(svg_data, svg_levels[i]);
		}

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M11.8536 1.14645C11.6583 0.951184 11.3417 0.951184 11.1465 1.14645L3.71455 8.57836C3.62459 8.66832 3.55263 8.77461 3.50251 8.89155L2.04044 12.303C1.9599 12.491 2.00189 12.709 2.14646 12.8536C2.29103 12.9981 2.50905 13.0401 2.69697 12.9596L6.10847 11.4975C6.2254 11.4474 6.3317 11.3754 6.42166 11.2855L13.8536 3.85355C14.0488 3.65829 14.0488 3.34171 13.8536 3.14645L11.8536 1.14645ZM4.42166 9.28547L11.5 2.20711L12.7929 3.5L5.71455 10.5784L4.21924 11.2192L3.78081 10.7808L4.42166 9.28547Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$r, 13, 1, 204);
				set_svg_attributes(svg, svg_data);
				add_location(svg, file$r, 5, 0, 79);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}

				set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
					dirty & /*size*/ 2 && { width: /*size*/ ctx[1] },
					dirty & /*size*/ 2 && { height: /*size*/ ctx[1] },
					{ viewBox: "0 0 15 15" },
					{ fill: "none" },
					{ xmlns: "http://www.w3.org/2000/svg" },
					dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2]
				]));
			},
			i: noop$3,
			o: noop$3,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$Z.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$Z($$self, $$props, $$invalidate) {
		const omit_props_names = ["color","size"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Pencil1', slots, []);
		let { color = 'currentColor' } = $$props;
		let { size = 15 } = $$props;

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('color' in $$new_props) $$invalidate(0, color = $$new_props.color);
			if ('size' in $$new_props) $$invalidate(1, size = $$new_props.size);
		};

		$$self.$capture_state = () => ({ color, size });

		$$self.$inject_state = $$new_props => {
			if ('color' in $$props) $$invalidate(0, color = $$new_props.color);
			if ('size' in $$props) $$invalidate(1, size = $$new_props.size);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color, size, $$restProps];
	}

	class Pencil1 extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$Z, create_fragment$Z, safe_not_equal, { color: 0, size: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Pencil1",
				options,
				id: create_fragment$Z.name
			});
		}

		get color() {
			throw new Error("<Pencil1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<Pencil1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get size() {
			throw new Error("<Pencil1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set size(value) {
			throw new Error("<Pencil1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var Pencil1$1 = Pencil1;

	/* node_modules/radix-icons-svelte/Icons/Stop.svelte generated by Svelte v4.2.10 */
	const file$q = "node_modules/radix-icons-svelte/Icons/Stop.svelte";

	function create_fragment$Y(ctx) {
		let svg;
		let path;

		let svg_levels = [
			{ width: /*size*/ ctx[1] },
			{ height: /*size*/ ctx[1] },
			{ viewBox: "0 0 15 15" },
			{ fill: "none" },
			{ xmlns: "http://www.w3.org/2000/svg" },
			/*$$restProps*/ ctx[2]
		];

		let svg_data = {};

		for (let i = 0; i < svg_levels.length; i += 1) {
			svg_data = assign(svg_data, svg_levels[i]);
		}

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M2 3C2 2.44772 2.44772 2 3 2H12C12.5523 2 13 2.44772 13 3V12C13 12.5523 12.5523 13 12 13H3C2.44772 13 2 12.5523 2 12V3ZM12 3H3V12H12V3Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$q, 13, 1, 204);
				set_svg_attributes(svg, svg_data);
				add_location(svg, file$q, 5, 0, 79);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}

				set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
					dirty & /*size*/ 2 && { width: /*size*/ ctx[1] },
					dirty & /*size*/ 2 && { height: /*size*/ ctx[1] },
					{ viewBox: "0 0 15 15" },
					{ fill: "none" },
					{ xmlns: "http://www.w3.org/2000/svg" },
					dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2]
				]));
			},
			i: noop$3,
			o: noop$3,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$Y.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$Y($$self, $$props, $$invalidate) {
		const omit_props_names = ["color","size"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Stop', slots, []);
		let { color = 'currentColor' } = $$props;
		let { size = 15 } = $$props;

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('color' in $$new_props) $$invalidate(0, color = $$new_props.color);
			if ('size' in $$new_props) $$invalidate(1, size = $$new_props.size);
		};

		$$self.$capture_state = () => ({ color, size });

		$$self.$inject_state = $$new_props => {
			if ('color' in $$props) $$invalidate(0, color = $$new_props.color);
			if ('size' in $$props) $$invalidate(1, size = $$new_props.size);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color, size, $$restProps];
	}

	class Stop extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$Y, create_fragment$Y, safe_not_equal, { color: 0, size: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Stop",
				options,
				id: create_fragment$Y.name
			});
		}

		get color() {
			throw new Error("<Stop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<Stop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get size() {
			throw new Error("<Stop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set size(value) {
			throw new Error("<Stop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var Stop$1 = Stop;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * @public
	 */
	var Presence;
	(function (Presence) {
	    Presence[Presence["Entering"] = 0] = "Entering";
	    Presence[Presence["Present"] = 1] = "Present";
	    Presence[Presence["Exiting"] = 2] = "Exiting";
	})(Presence || (Presence = {}));
	/**
	 * @public
	 */
	var VisibilityAction$1;
	(function (VisibilityAction) {
	    VisibilityAction[VisibilityAction["Hide"] = 0] = "Hide";
	    VisibilityAction[VisibilityAction["Show"] = 1] = "Show";
	})(VisibilityAction$1 || (VisibilityAction$1 = {}));

	const fix = ()=>{
	    try{
	        
	        if (!process.env){
	            process.env={};
	        }
	        return true;;
	    }catch(e){}
	    
	    if (!window || (window.process && window.process.env)){
	        return false;
	    }
	    
	    if (!window.process){
	        window.process={};
	    }
	    window.process.env={};
	    return true;    
	};

	const fixed = fix();

	const defaultTimestep = (1 / 60) * 1000;
	const getCurrentTime = typeof performance !== "undefined"
	    ? () => performance.now()
	    : () => Date.now();
	const onNextFrame = typeof window !== "undefined"
	    ? (callback) => window.requestAnimationFrame(callback)
	    : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);

	function createRenderStep(runNextFrame) {
	    let toRun = [];
	    let toRunNextFrame = [];
	    let numToRun = 0;
	    let isProcessing = false;
	    let flushNextFrame = false;
	    const toKeepAlive = new WeakSet();
	    const step = {
	        schedule: (callback, keepAlive = false, immediate = false) => {
	            const addToCurrentFrame = immediate && isProcessing;
	            const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
	            if (keepAlive)
	                toKeepAlive.add(callback);
	            if (buffer.indexOf(callback) === -1) {
	                buffer.push(callback);
	                if (addToCurrentFrame && isProcessing)
	                    numToRun = toRun.length;
	            }
	            return callback;
	        },
	        cancel: (callback) => {
	            const index = toRunNextFrame.indexOf(callback);
	            if (index !== -1)
	                toRunNextFrame.splice(index, 1);
	            toKeepAlive.delete(callback);
	        },
	        process: (frameData) => {
	            if (isProcessing) {
	                flushNextFrame = true;
	                return;
	            }
	            isProcessing = true;
	            [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
	            toRunNextFrame.length = 0;
	            numToRun = toRun.length;
	            if (numToRun) {
	                for (let i = 0; i < numToRun; i++) {
	                    const callback = toRun[i];
	                    callback(frameData);
	                    if (toKeepAlive.has(callback)) {
	                        step.schedule(callback);
	                        runNextFrame();
	                    }
	                }
	            }
	            isProcessing = false;
	            if (flushNextFrame) {
	                flushNextFrame = false;
	                step.process(frameData);
	            }
	        },
	    };
	    return step;
	}

	const maxElapsed = 40;
	let useDefaultElapsed = true;
	let runNextFrame = false;
	let isProcessing = false;
	const frame = {
	    delta: 0,
	    timestamp: 0,
	};
	const stepsOrder = [
	    "read",
	    "update",
	    "preRender",
	    "render",
	    "postRender",
	];
	const steps$1 = stepsOrder.reduce((acc, key) => {
	    acc[key] = createRenderStep(() => (runNextFrame = true));
	    return acc;
	}, {});
	const sync = stepsOrder.reduce((acc, key) => {
	    const step = steps$1[key];
	    acc[key] = (process, keepAlive = false, immediate = false) => {
	        if (!runNextFrame)
	            startLoop();
	        return step.schedule(process, keepAlive, immediate);
	    };
	    return acc;
	}, {});
	const cancelSync = stepsOrder.reduce((acc, key) => {
	    acc[key] = steps$1[key].cancel;
	    return acc;
	}, {});
	const flushSync = stepsOrder.reduce((acc, key) => {
	    acc[key] = () => steps$1[key].process(frame);
	    return acc;
	}, {});
	const processStep = (stepId) => steps$1[stepId].process(frame);
	const processFrame = (timestamp) => {
	    runNextFrame = false;
	    frame.delta = useDefaultElapsed
	        ? defaultTimestep
	        : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
	    frame.timestamp = timestamp;
	    isProcessing = true;
	    stepsOrder.forEach(processStep);
	    isProcessing = false;
	    if (runNextFrame) {
	        useDefaultElapsed = false;
	        onNextFrame(processFrame);
	    }
	};
	const startLoop = () => {
	    runNextFrame = true;
	    useDefaultElapsed = true;
	    if (!isProcessing)
	        onNextFrame(processFrame);
	};
	const getFrameData = () => frame;

	/******************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	/* global Reflect, Promise, SuppressedError, Symbol */


	var __assign = function() {
	    __assign = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};

	function __rest(s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	}

	function __read(o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	}

	function __spreadArray(to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	}

	typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
	    var e = new Error(message);
	    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	};

	var warning = function () { };
	var invariant = function () { };

	const clamp$1 = (min, max, v) => Math.min(Math.max(v, min), max);

	const safeMin = 0.001;
	const minDuration = 0.01;
	const maxDuration = 10.0;
	const minDamping = 0.05;
	const maxDamping = 1;
	function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {
	    let envelope;
	    let derivative;
	    warning(duration <= maxDuration * 1000);
	    let dampingRatio = 1 - bounce;
	    dampingRatio = clamp$1(minDamping, maxDamping, dampingRatio);
	    duration = clamp$1(minDuration, maxDuration, duration / 1000);
	    if (dampingRatio < 1) {
	        envelope = (undampedFreq) => {
	            const exponentialDecay = undampedFreq * dampingRatio;
	            const delta = exponentialDecay * duration;
	            const a = exponentialDecay - velocity;
	            const b = calcAngularFreq(undampedFreq, dampingRatio);
	            const c = Math.exp(-delta);
	            return safeMin - (a / b) * c;
	        };
	        derivative = (undampedFreq) => {
	            const exponentialDecay = undampedFreq * dampingRatio;
	            const delta = exponentialDecay * duration;
	            const d = delta * velocity + velocity;
	            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;
	            const f = Math.exp(-delta);
	            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);
	            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;
	            return (factor * ((d - e) * f)) / g;
	        };
	    }
	    else {
	        envelope = (undampedFreq) => {
	            const a = Math.exp(-undampedFreq * duration);
	            const b = (undampedFreq - velocity) * duration + 1;
	            return -safeMin + a * b;
	        };
	        derivative = (undampedFreq) => {
	            const a = Math.exp(-undampedFreq * duration);
	            const b = (velocity - undampedFreq) * (duration * duration);
	            return a * b;
	        };
	    }
	    const initialGuess = 5 / duration;
	    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
	    duration = duration * 1000;
	    if (isNaN(undampedFreq)) {
	        return {
	            stiffness: 100,
	            damping: 10,
	            duration,
	        };
	    }
	    else {
	        const stiffness = Math.pow(undampedFreq, 2) * mass;
	        return {
	            stiffness,
	            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
	            duration,
	        };
	    }
	}
	const rootIterations = 12;
	function approximateRoot(envelope, derivative, initialGuess) {
	    let result = initialGuess;
	    for (let i = 1; i < rootIterations; i++) {
	        result = result - envelope(result) / derivative(result);
	    }
	    return result;
	}
	function calcAngularFreq(undampedFreq, dampingRatio) {
	    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
	}

	const durationKeys = ["duration", "bounce"];
	const physicsKeys = ["stiffness", "damping", "mass"];
	function isSpringType(options, keys) {
	    return keys.some((key) => options[key] !== undefined);
	}
	function getSpringOptions(options) {
	    let springOptions = Object.assign({ velocity: 0.0, stiffness: 100, damping: 10, mass: 1.0, isResolvedFromDuration: false }, options);
	    if (!isSpringType(options, physicsKeys) &&
	        isSpringType(options, durationKeys)) {
	        const derived = findSpring(options);
	        springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0.0, mass: 1.0 });
	        springOptions.isResolvedFromDuration = true;
	    }
	    return springOptions;
	}
	function spring(_a) {
	    var { from = 0.0, to = 1.0, restSpeed = 2, restDelta } = _a, options = __rest(_a, ["from", "to", "restSpeed", "restDelta"]);
	    const state = { done: false, value: from };
	    let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);
	    let resolveSpring = zero;
	    let resolveVelocity = zero;
	    function createSpring() {
	        const initialVelocity = velocity ? -(velocity / 1000) : 0.0;
	        const initialDelta = to - from;
	        const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
	        const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;
	        if (restDelta === undefined) {
	            restDelta = Math.min(Math.abs(to - from) / 100, 0.4);
	        }
	        if (dampingRatio < 1) {
	            const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
	            resolveSpring = (t) => {
	                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
	                return (to -
	                    envelope *
	                        (((initialVelocity +
	                            dampingRatio * undampedAngularFreq * initialDelta) /
	                            angularFreq) *
	                            Math.sin(angularFreq * t) +
	                            initialDelta * Math.cos(angularFreq * t)));
	            };
	            resolveVelocity = (t) => {
	                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
	                return (dampingRatio *
	                    undampedAngularFreq *
	                    envelope *
	                    ((Math.sin(angularFreq * t) *
	                        (initialVelocity +
	                            dampingRatio *
	                                undampedAngularFreq *
	                                initialDelta)) /
	                        angularFreq +
	                        initialDelta * Math.cos(angularFreq * t)) -
	                    envelope *
	                        (Math.cos(angularFreq * t) *
	                            (initialVelocity +
	                                dampingRatio *
	                                    undampedAngularFreq *
	                                    initialDelta) -
	                            angularFreq *
	                                initialDelta *
	                                Math.sin(angularFreq * t)));
	            };
	        }
	        else if (dampingRatio === 1) {
	            resolveSpring = (t) => to -
	                Math.exp(-undampedAngularFreq * t) *
	                    (initialDelta +
	                        (initialVelocity + undampedAngularFreq * initialDelta) *
	                            t);
	        }
	        else {
	            const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
	            resolveSpring = (t) => {
	                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
	                const freqForT = Math.min(dampedAngularFreq * t, 300);
	                return (to -
	                    (envelope *
	                        ((initialVelocity +
	                            dampingRatio * undampedAngularFreq * initialDelta) *
	                            Math.sinh(freqForT) +
	                            dampedAngularFreq *
	                                initialDelta *
	                                Math.cosh(freqForT))) /
	                        dampedAngularFreq);
	            };
	        }
	    }
	    createSpring();
	    return {
	        next: (t) => {
	            const current = resolveSpring(t);
	            if (!isResolvedFromDuration) {
	                const currentVelocity = resolveVelocity(t) * 1000;
	                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
	                const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;
	                state.done =
	                    isBelowVelocityThreshold && isBelowDisplacementThreshold;
	            }
	            else {
	                state.done = t >= duration;
	            }
	            state.value = state.done ? to : current;
	            return state;
	        },
	        flipTarget: () => {
	            velocity = -velocity;
	            [from, to] = [to, from];
	            createSpring();
	        },
	    };
	}
	spring.needsInterpolation = (a, b) => typeof a === "string" || typeof b === "string";
	const zero = (_t) => 0;

	const progress = (from, to, value) => {
	    const toFromDifference = to - from;
	    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
	};

	const mix$1 = (from, to, progress) => -progress * from + progress * to + from;

	const clamp = (min, max) => (v) => Math.max(Math.min(v, max), min);
	const sanitize = (v) => (v % 1 ? Number(v.toFixed(5)) : v);
	const floatRegex = /(-)?([\d]*\.?[\d])+/g;
	const colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
	const singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
	function isString$1(v) {
	    return typeof v === 'string';
	}

	const number = {
	    test: (v) => typeof v === 'number',
	    parse: parseFloat,
	    transform: (v) => v,
	};
	const alpha = Object.assign(Object.assign({}, number), { transform: clamp(0, 1) });
	const scale$1 = Object.assign(Object.assign({}, number), { default: 1 });

	const createUnitType = (unit) => ({
	    test: (v) => isString$1(v) && v.endsWith(unit) && v.split(' ').length === 1,
	    parse: parseFloat,
	    transform: (v) => `${v}${unit}`,
	});
	const degrees = createUnitType('deg');
	const percent = createUnitType('%');
	const px = createUnitType('px');
	const vh = createUnitType('vh');
	const vw = createUnitType('vw');
	const progressPercentage = Object.assign(Object.assign({}, percent), { parse: (v) => percent.parse(v) / 100, transform: (v) => percent.transform(v * 100) });

	const isColorString = (type, testProp) => (v) => {
	    return Boolean((isString$1(v) && singleColorRegex.test(v) && v.startsWith(type)) ||
	        (testProp && Object.prototype.hasOwnProperty.call(v, testProp)));
	};
	const splitColor = (aName, bName, cName) => (v) => {
	    if (!isString$1(v))
	        return v;
	    const [a, b, c, alpha] = v.match(floatRegex);
	    return {
	        [aName]: parseFloat(a),
	        [bName]: parseFloat(b),
	        [cName]: parseFloat(c),
	        alpha: alpha !== undefined ? parseFloat(alpha) : 1,
	    };
	};

	const hsla = {
	    test: isColorString('hsl', 'hue'),
	    parse: splitColor('hue', 'saturation', 'lightness'),
	    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
	        return ('hsla(' +
	            Math.round(hue) +
	            ', ' +
	            percent.transform(sanitize(saturation)) +
	            ', ' +
	            percent.transform(sanitize(lightness)) +
	            ', ' +
	            sanitize(alpha.transform(alpha$1)) +
	            ')');
	    },
	};

	const clampRgbUnit = clamp(0, 255);
	const rgbUnit = Object.assign(Object.assign({}, number), { transform: (v) => Math.round(clampRgbUnit(v)) });
	const rgba = {
	    test: isColorString('rgb', 'red'),
	    parse: splitColor('red', 'green', 'blue'),
	    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => 'rgba(' +
	        rgbUnit.transform(red) +
	        ', ' +
	        rgbUnit.transform(green) +
	        ', ' +
	        rgbUnit.transform(blue) +
	        ', ' +
	        sanitize(alpha.transform(alpha$1)) +
	        ')',
	};

	function parseHex(v) {
	    let r = '';
	    let g = '';
	    let b = '';
	    let a = '';
	    if (v.length > 5) {
	        r = v.substr(1, 2);
	        g = v.substr(3, 2);
	        b = v.substr(5, 2);
	        a = v.substr(7, 2);
	    }
	    else {
	        r = v.substr(1, 1);
	        g = v.substr(2, 1);
	        b = v.substr(3, 1);
	        a = v.substr(4, 1);
	        r += r;
	        g += g;
	        b += b;
	        a += a;
	    }
	    return {
	        red: parseInt(r, 16),
	        green: parseInt(g, 16),
	        blue: parseInt(b, 16),
	        alpha: a ? parseInt(a, 16) / 255 : 1,
	    };
	}
	const hex = {
	    test: isColorString('#'),
	    parse: parseHex,
	    transform: rgba.transform,
	};

	const color = {
	    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
	    parse: (v) => {
	        if (rgba.test(v)) {
	            return rgba.parse(v);
	        }
	        else if (hsla.test(v)) {
	            return hsla.parse(v);
	        }
	        else {
	            return hex.parse(v);
	        }
	    },
	    transform: (v) => {
	        return isString$1(v)
	            ? v
	            : v.hasOwnProperty('red')
	                ? rgba.transform(v)
	                : hsla.transform(v);
	    },
	};

	const colorToken = '${c}';
	const numberToken = '${n}';
	function test(v) {
	    var _a, _b, _c, _d;
	    return (isNaN(v) &&
	        isString$1(v) &&
	        ((_b = (_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0);
	}
	function analyse$1(v) {
	    if (typeof v === 'number')
	        v = `${v}`;
	    const values = [];
	    let numColors = 0;
	    const colors = v.match(colorRegex);
	    if (colors) {
	        numColors = colors.length;
	        v = v.replace(colorRegex, colorToken);
	        values.push(...colors.map(color.parse));
	    }
	    const numbers = v.match(floatRegex);
	    if (numbers) {
	        v = v.replace(floatRegex, numberToken);
	        values.push(...numbers.map(number.parse));
	    }
	    return { values, numColors, tokenised: v };
	}
	function parse$2(v) {
	    return analyse$1(v).values;
	}
	function createTransformer(v) {
	    const { values, numColors, tokenised } = analyse$1(v);
	    const numValues = values.length;
	    return (v) => {
	        let output = tokenised;
	        for (let i = 0; i < numValues; i++) {
	            output = output.replace(i < numColors ? colorToken : numberToken, i < numColors ? color.transform(v[i]) : sanitize(v[i]));
	        }
	        return output;
	    };
	}
	const convertNumbersToZero = (v) => typeof v === 'number' ? 0 : v;
	function getAnimatableNone$1(v) {
	    const parsed = parse$2(v);
	    const transformer = createTransformer(v);
	    return transformer(parsed.map(convertNumbersToZero));
	}
	const complex = { test, parse: parse$2, createTransformer, getAnimatableNone: getAnimatableNone$1 };

	const maxDefaults = new Set(['brightness', 'contrast', 'saturate', 'opacity']);
	function applyDefaultFilter(v) {
	    let [name, value] = v.slice(0, -1).split('(');
	    if (name === 'drop-shadow')
	        return v;
	    const [number] = value.match(floatRegex) || [];
	    if (!number)
	        return v;
	    const unit = value.replace(number, '');
	    let defaultValue = maxDefaults.has(name) ? 1 : 0;
	    if (number !== value)
	        defaultValue *= 100;
	    return name + '(' + defaultValue + unit + ')';
	}
	const functionRegex = /([a-z-]*)\(.*?\)/g;
	const filter$1 = Object.assign(Object.assign({}, complex), { getAnimatableNone: (v) => {
	        const functions = v.match(functionRegex);
	        return functions ? functions.map(applyDefaultFilter).join(' ') : v;
	    } });

	function hueToRgb(p, q, t) {
	    if (t < 0)
	        t += 1;
	    if (t > 1)
	        t -= 1;
	    if (t < 1 / 6)
	        return p + (q - p) * 6 * t;
	    if (t < 1 / 2)
	        return q;
	    if (t < 2 / 3)
	        return p + (q - p) * (2 / 3 - t) * 6;
	    return p;
	}
	function hslaToRgba({ hue, saturation, lightness, alpha }) {
	    hue /= 360;
	    saturation /= 100;
	    lightness /= 100;
	    let red = 0;
	    let green = 0;
	    let blue = 0;
	    if (!saturation) {
	        red = green = blue = lightness;
	    }
	    else {
	        const q = lightness < 0.5
	            ? lightness * (1 + saturation)
	            : lightness + saturation - lightness * saturation;
	        const p = 2 * lightness - q;
	        red = hueToRgb(p, q, hue + 1 / 3);
	        green = hueToRgb(p, q, hue);
	        blue = hueToRgb(p, q, hue - 1 / 3);
	    }
	    return {
	        red: Math.round(red * 255),
	        green: Math.round(green * 255),
	        blue: Math.round(blue * 255),
	        alpha,
	    };
	}

	const mixLinearColor = (from, to, v) => {
	    const fromExpo = from * from;
	    const toExpo = to * to;
	    return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));
	};
	const colorTypes = [hex, rgba, hsla];
	const getColorType = (v) => colorTypes.find((type) => type.test(v));
	const mixColor = (from, to) => {
	    let fromColorType = getColorType(from);
	    let toColorType = getColorType(to);
	    let fromColor = fromColorType.parse(from);
	    let toColor = toColorType.parse(to);
	    if (fromColorType === hsla) {
	        fromColor = hslaToRgba(fromColor);
	        fromColorType = rgba;
	    }
	    if (toColorType === hsla) {
	        toColor = hslaToRgba(toColor);
	        toColorType = rgba;
	    }
	    const blended = Object.assign({}, fromColor);
	    return (v) => {
	        for (const key in blended) {
	            if (key !== "alpha") {
	                blended[key] = mixLinearColor(fromColor[key], toColor[key], v);
	            }
	        }
	        blended.alpha = mix$1(fromColor.alpha, toColor.alpha, v);
	        return fromColorType.transform(blended);
	    };
	};

	const isNum = (v) => typeof v === 'number';

	const combineFunctions = (a, b) => (v) => b(a(v));
	const pipe = (...transformers) => transformers.reduce(combineFunctions);

	function getMixer(origin, target) {
	    if (isNum(origin)) {
	        return (v) => mix$1(origin, target, v);
	    }
	    else if (color.test(origin)) {
	        return mixColor(origin, target);
	    }
	    else {
	        return mixComplex(origin, target);
	    }
	}
	const mixArray = (from, to) => {
	    const output = [...from];
	    const numValues = output.length;
	    const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));
	    return (v) => {
	        for (let i = 0; i < numValues; i++) {
	            output[i] = blendValue[i](v);
	        }
	        return output;
	    };
	};
	const mixObject = (origin, target) => {
	    const output = Object.assign(Object.assign({}, origin), target);
	    const blendValue = {};
	    for (const key in output) {
	        if (origin[key] !== undefined && target[key] !== undefined) {
	            blendValue[key] = getMixer(origin[key], target[key]);
	        }
	    }
	    return (v) => {
	        for (const key in blendValue) {
	            output[key] = blendValue[key](v);
	        }
	        return output;
	    };
	};
	function analyse(value) {
	    const parsed = complex.parse(value);
	    const numValues = parsed.length;
	    let numNumbers = 0;
	    let numRGB = 0;
	    let numHSL = 0;
	    for (let i = 0; i < numValues; i++) {
	        if (numNumbers || typeof parsed[i] === "number") {
	            numNumbers++;
	        }
	        else {
	            if (parsed[i].hue !== undefined) {
	                numHSL++;
	            }
	            else {
	                numRGB++;
	            }
	        }
	    }
	    return { parsed, numNumbers, numRGB, numHSL };
	}
	const mixComplex = (origin, target) => {
	    const template = complex.createTransformer(target);
	    const originStats = analyse(origin);
	    const targetStats = analyse(target);
	    const canInterpolate = originStats.numHSL === targetStats.numHSL &&
	        originStats.numRGB === targetStats.numRGB &&
	        originStats.numNumbers >= targetStats.numNumbers;
	    if (canInterpolate) {
	        return pipe(mixArray(originStats.parsed, targetStats.parsed), template);
	    }
	    else {
	        return (p) => `${p > 0 ? target : origin}`;
	    }
	};

	const mixNumber = (from, to) => (p) => mix$1(from, to, p);
	function detectMixerFactory(v) {
	    if (typeof v === 'number') {
	        return mixNumber;
	    }
	    else if (typeof v === 'string') {
	        if (color.test(v)) {
	            return mixColor;
	        }
	        else {
	            return mixComplex;
	        }
	    }
	    else if (Array.isArray(v)) {
	        return mixArray;
	    }
	    else if (typeof v === 'object') {
	        return mixObject;
	    }
	}
	function createMixers(output, ease, customMixer) {
	    const mixers = [];
	    const mixerFactory = customMixer || detectMixerFactory(output[0]);
	    const numMixers = output.length - 1;
	    for (let i = 0; i < numMixers; i++) {
	        let mixer = mixerFactory(output[i], output[i + 1]);
	        if (ease) {
	            const easingFunction = Array.isArray(ease) ? ease[i] : ease;
	            mixer = pipe(easingFunction, mixer);
	        }
	        mixers.push(mixer);
	    }
	    return mixers;
	}
	function fastInterpolate([from, to], [mixer]) {
	    return (v) => mixer(progress(from, to, v));
	}
	function slowInterpolate(input, mixers) {
	    const inputLength = input.length;
	    const lastInputIndex = inputLength - 1;
	    return (v) => {
	        let mixerIndex = 0;
	        let foundMixerIndex = false;
	        if (v <= input[0]) {
	            foundMixerIndex = true;
	        }
	        else if (v >= input[lastInputIndex]) {
	            mixerIndex = lastInputIndex - 1;
	            foundMixerIndex = true;
	        }
	        if (!foundMixerIndex) {
	            let i = 1;
	            for (; i < inputLength; i++) {
	                if (input[i] > v || i === lastInputIndex) {
	                    break;
	                }
	            }
	            mixerIndex = i - 1;
	        }
	        const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);
	        return mixers[mixerIndex](progressInRange);
	    };
	}
	function interpolate$1(input, output, { clamp: isClamp = true, ease, mixer } = {}) {
	    const inputLength = input.length;
	    invariant(inputLength === output.length);
	    invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1);
	    if (input[0] > input[inputLength - 1]) {
	        input = [].concat(input);
	        output = [].concat(output);
	        input.reverse();
	        output.reverse();
	    }
	    const mixers = createMixers(output, ease, mixer);
	    const interpolator = inputLength === 2
	        ? fastInterpolate(input, mixers)
	        : slowInterpolate(input, mixers);
	    return isClamp
	        ? (v) => interpolator(clamp$1(input[0], input[inputLength - 1], v))
	        : interpolator;
	}

	const reverseEasing = easing => p => 1 - easing(1 - p);
	const mirrorEasing = easing => p => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
	const createExpoIn = (power) => p => Math.pow(p, power);
	const createBackIn = (power) => p => p * p * ((power + 1) * p - power);
	const createAnticipate = (power) => {
	    const backEasing = createBackIn(power);
	    return p => (p *= 2) < 1
	        ? 0.5 * backEasing(p)
	        : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
	};

	const DEFAULT_OVERSHOOT_STRENGTH = 1.525;
	const BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;
	const BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;
	const BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;
	const linear$1 = p => p;
	const easeIn = createExpoIn(2);
	const easeOut = reverseEasing(easeIn);
	const easeInOut = mirrorEasing(easeIn);
	const circIn = p => 1 - Math.sin(Math.acos(p));
	const circOut = reverseEasing(circIn);
	const circInOut = mirrorEasing(circOut);
	const backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
	const backOut = reverseEasing(backIn);
	const backInOut = mirrorEasing(backIn);
	const anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);
	const ca = 4356.0 / 361.0;
	const cb = 35442.0 / 1805.0;
	const cc = 16061.0 / 1805.0;
	const bounceOut = (p) => {
	    if (p === 1 || p === 0)
	        return p;
	    const p2 = p * p;
	    return p < BOUNCE_FIRST_THRESHOLD
	        ? 7.5625 * p2
	        : p < BOUNCE_SECOND_THRESHOLD
	            ? 9.075 * p2 - 9.9 * p + 3.4
	            : p < BOUNCE_THIRD_THRESHOLD
	                ? ca * p2 - cb * p + cc
	                : 10.8 * p * p - 20.52 * p + 10.72;
	};
	const bounceIn = reverseEasing(bounceOut);
	const bounceInOut = (p) => p < 0.5
	    ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0))
	    : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;

	function defaultEasing(values, easing) {
	    return values.map(() => easing || easeInOut).splice(0, values.length - 1);
	}
	function defaultOffset(values) {
	    const numValues = values.length;
	    return values.map((_value, i) => i !== 0 ? i / (numValues - 1) : 0);
	}
	function convertOffsetToTimes(offset, duration) {
	    return offset.map((o) => o * duration);
	}
	function keyframes$1({ from = 0, to = 1, ease, offset, duration = 300, }) {
	    const state = { done: false, value: from };
	    const values = Array.isArray(to) ? to : [from, to];
	    const times = convertOffsetToTimes(offset && offset.length === values.length
	        ? offset
	        : defaultOffset(values), duration);
	    function createInterpolator() {
	        return interpolate$1(times, values, {
	            ease: Array.isArray(ease) ? ease : defaultEasing(values, ease),
	        });
	    }
	    let interpolator = createInterpolator();
	    return {
	        next: (t) => {
	            state.value = interpolator(t);
	            state.done = t >= duration;
	            return state;
	        },
	        flipTarget: () => {
	            values.reverse();
	            interpolator = createInterpolator();
	        },
	    };
	}

	function decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget, }) {
	    const state = { done: false, value: from };
	    let amplitude = power * velocity;
	    const ideal = from + amplitude;
	    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);
	    if (target !== ideal)
	        amplitude = target - from;
	    return {
	        next: (t) => {
	            const delta = -amplitude * Math.exp(-t / timeConstant);
	            state.done = !(delta > restDelta || delta < -restDelta);
	            state.value = state.done ? target : target + delta;
	            return state;
	        },
	        flipTarget: () => { },
	    };
	}

	const types = { keyframes: keyframes$1, spring, decay };
	function detectAnimationFromOptions(config) {
	    if (Array.isArray(config.to)) {
	        return keyframes$1;
	    }
	    else if (types[config.type]) {
	        return types[config.type];
	    }
	    const keys = new Set(Object.keys(config));
	    if (keys.has("ease") ||
	        (keys.has("duration") && !keys.has("dampingRatio"))) {
	        return keyframes$1;
	    }
	    else if (keys.has("dampingRatio") ||
	        keys.has("stiffness") ||
	        keys.has("mass") ||
	        keys.has("damping") ||
	        keys.has("restSpeed") ||
	        keys.has("restDelta")) {
	        return spring;
	    }
	    return keyframes$1;
	}

	function loopElapsed(elapsed, duration, delay = 0) {
	    return elapsed - duration - delay;
	}
	function reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {
	    return isForwardPlayback
	        ? loopElapsed(duration + -elapsed, duration, delay)
	        : duration - (elapsed - duration) + delay;
	}
	function hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {
	    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;
	}

	const framesync = (update) => {
	    const passTimestamp = ({ delta }) => update(delta);
	    return {
	        start: () => sync.update(passTimestamp, true),
	        stop: () => cancelSync.update(passTimestamp),
	    };
	};
	function animate(_a) {
	    var _b, _c;
	    var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = "loop", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = __rest(_a, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
	    let { to } = options;
	    let driverControls;
	    let repeatCount = 0;
	    let computedDuration = options.duration;
	    let latest;
	    let isComplete = false;
	    let isForwardPlayback = true;
	    let interpolateFromNumber;
	    const animator = detectAnimationFromOptions(options);
	    if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {
	        interpolateFromNumber = interpolate$1([0, 100], [from, to], {
	            clamp: false,
	        });
	        from = 0;
	        to = 100;
	    }
	    const animation = animator(Object.assign(Object.assign({}, options), { from, to }));
	    function repeat() {
	        repeatCount++;
	        if (repeatType === "reverse") {
	            isForwardPlayback = repeatCount % 2 === 0;
	            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
	        }
	        else {
	            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
	            if (repeatType === "mirror")
	                animation.flipTarget();
	        }
	        isComplete = false;
	        onRepeat && onRepeat();
	    }
	    function complete() {
	        driverControls.stop();
	        onComplete && onComplete();
	    }
	    function update(delta) {
	        if (!isForwardPlayback)
	            delta = -delta;
	        elapsed += delta;
	        if (!isComplete) {
	            const state = animation.next(Math.max(0, elapsed));
	            latest = state.value;
	            if (interpolateFromNumber)
	                latest = interpolateFromNumber(latest);
	            isComplete = isForwardPlayback ? state.done : elapsed <= 0;
	        }
	        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);
	        if (isComplete) {
	            if (repeatCount === 0)
	                computedDuration !== null && computedDuration !== void 0 ? computedDuration : (computedDuration = elapsed);
	            if (repeatCount < repeatMax) {
	                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
	            }
	            else {
	                complete();
	            }
	        }
	    }
	    function play() {
	        onPlay === null || onPlay === void 0 ? void 0 : onPlay();
	        driverControls = driver(update);
	        driverControls.start();
	    }
	    autoplay && play();
	    return {
	        stop: () => {
	            onStop === null || onStop === void 0 ? void 0 : onStop();
	            driverControls.stop();
	        },
	    };
	}

	function velocityPerSecond(velocity, frameDuration) {
	    return frameDuration ? velocity * (1000 / frameDuration) : 0;
	}

	function inertia({ from = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop, }) {
	    let currentAnimation;
	    function isOutOfBounds(v) {
	        return (min !== undefined && v < min) || (max !== undefined && v > max);
	    }
	    function boundaryNearest(v) {
	        if (min === undefined)
	            return max;
	        if (max === undefined)
	            return min;
	        return Math.abs(min - v) < Math.abs(max - v) ? min : max;
	    }
	    function startAnimation(options) {
	        currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
	        currentAnimation = animate(Object.assign(Object.assign({}, options), { driver, onUpdate: (v) => {
	                var _a;
	                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);
	                (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);
	            }, onComplete,
	            onStop }));
	    }
	    function startSpring(options) {
	        startAnimation(Object.assign({ type: "spring", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));
	    }
	    if (isOutOfBounds(from)) {
	        startSpring({ from, velocity, to: boundaryNearest(from) });
	    }
	    else {
	        let target = power * velocity + from;
	        if (typeof modifyTarget !== "undefined")
	            target = modifyTarget(target);
	        const boundary = boundaryNearest(target);
	        const heading = boundary === min ? -1 : 1;
	        let prev;
	        let current;
	        const checkBoundary = (v) => {
	            prev = current;
	            current = v;
	            velocity = velocityPerSecond(v - prev, getFrameData().delta);
	            if ((heading === 1 && v > boundary) ||
	                (heading === -1 && v < boundary)) {
	                startSpring({ from: v, to: boundary, velocity });
	            }
	        };
	        startAnimation({
	            type: "decay",
	            from,
	            velocity,
	            timeConstant,
	            power,
	            restDelta,
	            modifyTarget,
	            onUpdate: isOutOfBounds(target) ? checkBoundary : undefined,
	        });
	    }
	    return {
	        stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop(),
	    };
	}

	const isPoint = (point) => point.hasOwnProperty('x') && point.hasOwnProperty('y');

	const isPoint3D = (point) => isPoint(point) && point.hasOwnProperty('z');

	const distance1D = (a, b) => Math.abs(a - b);
	function distance$1(a, b) {
	    if (isNum(a) && isNum(b)) {
	        return distance1D(a, b);
	    }
	    else if (isPoint(a) && isPoint(b)) {
	        const xDelta = distance1D(a.x, b.x);
	        const yDelta = distance1D(a.y, b.y);
	        const zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;
	        return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
	    }
	}

	const a$3 = (a1, a2) => 1.0 - 3.0 * a2 + 3.0 * a1;
	const b$2 = (a1, a2) => 3.0 * a2 - 6.0 * a1;
	const c$1 = (a1) => 3.0 * a1;
	const calcBezier = (t, a1, a2) => ((a$3(a1, a2) * t + b$2(a1, a2)) * t + c$1(a1)) * t;
	const getSlope = (t, a1, a2) => 3.0 * a$3(a1, a2) * t * t + 2.0 * b$2(a1, a2) * t + c$1(a1);
	const subdivisionPrecision = 0.0000001;
	const subdivisionMaxIterations = 10;
	function binarySubdivide(aX, aA, aB, mX1, mX2) {
	    let currentX;
	    let currentT;
	    let i = 0;
	    do {
	        currentT = aA + (aB - aA) / 2.0;
	        currentX = calcBezier(currentT, mX1, mX2) - aX;
	        if (currentX > 0.0) {
	            aB = currentT;
	        }
	        else {
	            aA = currentT;
	        }
	    } while (Math.abs(currentX) > subdivisionPrecision &&
	        ++i < subdivisionMaxIterations);
	    return currentT;
	}
	const newtonIterations = 8;
	const newtonMinSlope = 0.001;
	function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
	    for (let i = 0; i < newtonIterations; ++i) {
	        const currentSlope = getSlope(aGuessT, mX1, mX2);
	        if (currentSlope === 0.0) {
	            return aGuessT;
	        }
	        const currentX = calcBezier(aGuessT, mX1, mX2) - aX;
	        aGuessT -= currentX / currentSlope;
	    }
	    return aGuessT;
	}
	const kSplineTableSize = 11;
	const kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
	function cubicBezier(mX1, mY1, mX2, mY2) {
	    if (mX1 === mY1 && mX2 === mY2)
	        return linear$1;
	    const sampleValues = new Float32Array(kSplineTableSize);
	    for (let i = 0; i < kSplineTableSize; ++i) {
	        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
	    }
	    function getTForX(aX) {
	        let intervalStart = 0.0;
	        let currentSample = 1;
	        const lastSample = kSplineTableSize - 1;
	        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
	            intervalStart += kSampleStepSize;
	        }
	        --currentSample;
	        const dist = (aX - sampleValues[currentSample]) /
	            (sampleValues[currentSample + 1] - sampleValues[currentSample]);
	        const guessForT = intervalStart + dist * kSampleStepSize;
	        const initialSlope = getSlope(guessForT, mX1, mX2);
	        if (initialSlope >= newtonMinSlope) {
	            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
	        }
	        else if (initialSlope === 0.0) {
	            return guessForT;
	        }
	        else {
	            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
	        }
	    }
	    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	function addUniqueItem(arr, item) {
	    arr.indexOf(item) === -1 && arr.push(item);
	}
	function removeItem(arr, item) {
	    var index = arr.indexOf(item);
	    index > -1 && arr.splice(index, 1);
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var SubscriptionManager = /** @class */ (function () {
	    function SubscriptionManager() {
	        this.subscriptions = [];
	    }
	    SubscriptionManager.prototype.add = function (handler) {
	        var _this = this;
	        addUniqueItem(this.subscriptions, handler);
	        return function () { return removeItem(_this.subscriptions, handler); };
	    };
	    SubscriptionManager.prototype.notify = function (a, b, c) {
	        var numSubscriptions = this.subscriptions.length;
	        if (!numSubscriptions)
	            return;
	        if (numSubscriptions === 1) {
	            /**
	             * If there's only a single handler we can just call it without invoking a loop.
	             */
	            this.subscriptions[0](a, b, c);
	        }
	        else {
	            for (var i = 0; i < numSubscriptions; i++) {
	                /**
	                 * Check whether the handler exists before firing as it's possible
	                 * the subscriptions were modified during this loop running.
	                 */
	                var handler = this.subscriptions[i];
	                handler && handler(a, b, c);
	            }
	        }
	    };
	    SubscriptionManager.prototype.getSize = function () {
	        return this.subscriptions.length;
	    };
	    SubscriptionManager.prototype.clear = function () {
	        this.subscriptions.length = 0;
	    };
	    return SubscriptionManager;
	}());

	var isFloat = function (value) {
	    return !isNaN(parseFloat(value));
	};
	/**
	 * `MotionValue` is used to track the state and velocity of motion values.
	 *
	 * @public
	 */
	var MotionValue = /** @class */ (function () {
	    /**
	     * @param init - The initiating value
	     * @param config - Optional configuration options
	     *
	     * -  `transformer`: A function to transform incoming values with.
	     *
	     * @internal
	     */
	    function MotionValue(init, startStopNotifier) {
	        var _this = this;
	        /**
	         * Duration, in milliseconds, since last updating frame.
	         *
	         * @internal
	         */
	        this.timeDelta = 0;
	        /**
	         * Timestamp of the last time this `MotionValue` was updated.
	         *
	         * @internal
	         */
	        this.lastUpdated = 0;
	        /**
	         * Functions to notify when the `MotionValue` updates.
	         *
	         * @internal
	         */
	        this.updateSubscribers = new SubscriptionManager();
	        /**
	         * Functions to notify when the velocity updates.
	         *
	         * @internal
	         */
	        this.velocityUpdateSubscribers = new SubscriptionManager();
	        /**
	         * Functions to notify when the `MotionValue` updates and `render` is set to `true`.
	         *
	         * @internal
	         */
	        this.renderSubscribers = new SubscriptionManager();
	        /**
	         * Tracks whether this value can output a velocity. Currently this is only true
	         * if the value is numerical, but we might be able to widen the scope here and support
	         * other value types.
	         *
	         * @internal
	         */
	        this.canTrackVelocity = false;
	        this.updateAndNotify = function (v, render) {
	            if (render === void 0) { render = true; }
	            _this.prev = _this.current;
	            _this.current = v;
	            // Update timestamp
	            var _a = getFrameData(), delta = _a.delta, timestamp = _a.timestamp;
	            if (_this.lastUpdated !== timestamp) {
	                _this.timeDelta = delta;
	                _this.lastUpdated = timestamp;
	                sync.postRender(_this.scheduleVelocityCheck);
	            }
	            // Update update subscribers
	            if (_this.prev !== _this.current) {
	                _this.updateSubscribers.notify(_this.current);
	            }
	            // Update velocity subscribers
	            if (_this.velocityUpdateSubscribers.getSize()) {
	                _this.velocityUpdateSubscribers.notify(_this.getVelocity());
	            }
	            // Update render subscribers
	            if (render) {
	                _this.renderSubscribers.notify(_this.current);
	            }
	        };
	        /**
	         * Schedule a velocity check for the next frame.
	         *
	         * This is an instanced and bound function to prevent generating a new
	         * function once per frame.
	         *
	         * @internal
	         */
	        this.scheduleVelocityCheck = function () { return sync.postRender(_this.velocityCheck); };
	        /**
	         * Updates `prev` with `current` if the value hasn't been updated this frame.
	         * This ensures velocity calculations return `0`.
	         *
	         * This is an instanced and bound function to prevent generating a new
	         * function once per frame.
	         *
	         * @internal
	         */
	        this.velocityCheck = function (_a) {
	            var timestamp = _a.timestamp;
	            if (timestamp !== _this.lastUpdated) {
	                _this.prev = _this.current;
	                _this.velocityUpdateSubscribers.notify(_this.getVelocity());
	            }
	        };
	        this.hasAnimated = false;
	        this.prev = this.current = init;
	        this.canTrackVelocity = isFloat(this.current);
	        this.onSubscription = () => { };
	        this.onUnsubscription = () => { };
	        if (startStopNotifier) {
	            this.onSubscription = () => {
	                if (this.updateSubscribers.getSize() + this.velocityUpdateSubscribers.getSize() + this.renderSubscribers.getSize() === 0) {

	                    const unsub = startStopNotifier();
	                    this.onUnsubscription = () => { };
	                    if (unsub) {
	                        this.onUnsubscription = () => {
	                            if (this.updateSubscribers.getSize() + this.velocityUpdateSubscribers.getSize() + this.renderSubscribers.getSize() === 0) {
	                                unsub();
	                            }
	                        };
	                    }

	                }
	            };
	        }
	    }
	    /**
	     * Adds a function that will be notified when the `MotionValue` is updated.
	     *
	     * It returns a function that, when called, will cancel the subscription.
	     *
	     * When calling `onChange` inside a React component, it should be wrapped with the
	     * `useEffect` hook. As it returns an unsubscribe function, this should be returned
	     * from the `useEffect` function to ensure you don't add duplicate subscribers..
	     *
	     * @motion
	     *
	     * ```jsx
	     * export const MyComponent = () => {
	     *   const x = useMotionValue(0)
	     *   const y = useMotionValue(0)
	     *   const opacity = useMotionValue(1)
	     *
	     *   useEffect(() => {
	     *     function updateOpacity() {
	     *       const maxXY = Math.max(x.get(), y.get())
	     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
	     *       opacity.set(newOpacity)
	     *     }
	     *
	     *     const unsubscribeX = x.onChange(updateOpacity)
	     *     const unsubscribeY = y.onChange(updateOpacity)
	     *
	     *     return () => {
	     *       unsubscribeX()
	     *       unsubscribeY()
	     *     }
	     *   }, [])
	     *
	     *   return <MotionDiv style={{ x }} />
	     * }
	     * ```
	     *
	     * @internalremarks
	     *
	     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.
	     *
	     * ```jsx
	     * useOnChange(x, () => {})
	     * ```
	     *
	     * @param subscriber - A function that receives the latest value.
	     * @returns A function that, when called, will cancel this subscription.
	     *
	     * @public
	     */
	    MotionValue.prototype.onChange = function (subscription) {
	        this.onSubscription();
	        const unsub = this.updateSubscribers.add(subscription);
	        return () => {
	            unsub();
	            this.onUnsubscription();

	        }
	    };
	    /** Add subscribe method for Svelte store interface */
	    MotionValue.prototype.subscribe = function (subscription) {
	        return this.onChange(subscription);
	    };

	    MotionValue.prototype.clearListeners = function () {
	        this.updateSubscribers.clear();
	        this.onUnsubscription();
	    };
	    /**
	     * Adds a function that will be notified when the `MotionValue` requests a render.
	     *
	     * @param subscriber - A function that's provided the latest value.
	     * @returns A function that, when called, will cancel this subscription.
	     *
	     * @internal
	     */
	    MotionValue.prototype.onRenderRequest = function (subscription) {
	        this.onSubscription();
	        // Render immediately
	        subscription(this.get());
	        const unsub = this.renderSubscribers.add(subscription);
	        return () => {
	            unsub();
	            this.onUnsubscription();
	        }
	    };
	    /**
	     * Attaches a passive effect to the `MotionValue`.
	     *
	     * @internal
	     */
	    MotionValue.prototype.attach = function (passiveEffect) {
	        this.passiveEffect = passiveEffect;
	    };
	    /**
	     * Sets the state of the `MotionValue`.
	     *
	     * @remarks
	     *
	     * ```jsx
	     * const x = useMotionValue(0)
	     * x.set(10)
	     * ```
	     *
	     * @param latest - Latest value to set.
	     * @param render - Whether to notify render subscribers. Defaults to `true`
	     *
	     * @public
	     */
	    MotionValue.prototype.set = function (v, render) {
	        if (render === void 0) { render = true; }
	        if (!render || !this.passiveEffect) {
	            this.updateAndNotify(v, render);
	        }
	        else {
	            this.passiveEffect(v, this.updateAndNotify);
	        }
	    };
	    /** Add update method for Svelte Store behavior */
	    MotionValue.prototype.update = function (v) {
	        this.set(v(this.get()));
	    };
	    /**
	     * Returns the latest state of `MotionValue`
	     *
	     * @returns - The latest state of `MotionValue`
	     *
	     * @public
	     */
	    MotionValue.prototype.get = function () {
	        this.onSubscription();
	        const curr = this.current;
	        this.onUnsubscription();
	        return curr
	    };
	    /**
	     * @public
	     */
	    MotionValue.prototype.getPrevious = function () {
	        return this.prev;
	    };
	    /**
	     * Returns the latest velocity of `MotionValue`
	     *
	     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
	     *
	     * @public
	     */
	    MotionValue.prototype.getVelocity = function () {
	        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful
	        this.onSubscription();
	        const vel = this.canTrackVelocity
	            ? // These casts could be avoided if parseFloat would be typed better
	            velocityPerSecond(parseFloat(this.current) -
	                parseFloat(this.prev), this.timeDelta)
	            : 0;
	        this.onUnsubscription();
	        return vel;
	    };
	    /**
	     * Registers a new animation to control this `MotionValue`. Only one
	     * animation can drive a `MotionValue` at one time.
	     *
	     * ```jsx
	     * value.start()
	     * ```
	     *
	     * @param animation - A function that starts the provided animation
	     *
	     * @internal
	     */
	    MotionValue.prototype.start = function (animation) {
	        var _this = this;
	        this.stop();
	        return new Promise(function (resolve) {
	            _this.hasAnimated = true;
	            _this.stopAnimation = animation(resolve);
	        }).then(function () { return _this.clearAnimation(); });
	    };
	    /**
	     * Stop the currently active animation.
	     *
	     * @public
	     */
	    MotionValue.prototype.stop = function () {
	        if (this.stopAnimation)
	            this.stopAnimation();
	        this.clearAnimation();
	    };
	    /**
	     * Returns `true` if this value is currently animating.
	     *
	     * @public
	     */
	    MotionValue.prototype.isAnimating = function () {
	        return !!this.stopAnimation;
	    };
	    MotionValue.prototype.clearAnimation = function () {
	        this.stopAnimation = null;
	    };
	    /**
	     * Destroy and clean up subscribers to this `MotionValue`.
	     *
	     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
	     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
	     * created a `MotionValue` via the `motionValue` function.
	     *
	     * @public
	     */
	    MotionValue.prototype.destroy = function () {
	        this.updateSubscribers.clear();
	        this.renderSubscribers.clear();
	        this.stop();
	        this.onUnsubscription();
	    };
	    return MotionValue;
	}());
	/**
	 * @internal
	 */
	function motionValue(init, startStopNotifier) {
	    return new MotionValue(init, startStopNotifier);
	}

	const subscriber_queue = [];

	/**
	 * Creates a `Readable` store that allows reading by subscription.
	 *
	 * https://svelte.dev/docs/svelte-store#readable
	 * @template T
	 * @param {T} [value] initial value
	 * @param {import('./public.js').StartStopNotifier<T>} [start]
	 * @returns {import('./public.js').Readable<T>}
	 */
	function readable(value, start) {
		return {
			subscribe: writable(value, start).subscribe
		};
	}

	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * https://svelte.dev/docs/svelte-store#writable
	 * @template T
	 * @param {T} [value] initial value
	 * @param {import('./public.js').StartStopNotifier<T>} [start]
	 * @returns {import('./public.js').Writable<T>}
	 */
	function writable(value, start = noop$3) {
		/** @type {import('./public.js').Unsubscriber} */
		let stop;
		/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */
		const subscribers = new Set();
		/** @param {T} new_value
		 * @returns {void}
		 */
		function set(new_value) {
			if (safe_not_equal(value, new_value)) {
				value = new_value;
				if (stop) {
					// store is ready
					const run_queue = !subscriber_queue.length;
					for (const subscriber of subscribers) {
						subscriber[1]();
						subscriber_queue.push(subscriber, value);
					}
					if (run_queue) {
						for (let i = 0; i < subscriber_queue.length; i += 2) {
							subscriber_queue[i][0](subscriber_queue[i + 1]);
						}
						subscriber_queue.length = 0;
					}
				}
			}
		}

		/**
		 * @param {import('./public.js').Updater<T>} fn
		 * @returns {void}
		 */
		function update(fn) {
			set(fn(value));
		}

		/**
		 * @param {import('./public.js').Subscriber<T>} run
		 * @param {import('./private.js').Invalidator<T>} [invalidate]
		 * @returns {import('./public.js').Unsubscriber}
		 */
		function subscribe(run, invalidate = noop$3) {
			/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */
			const subscriber = [run, invalidate];
			subscribers.add(subscriber);
			if (subscribers.size === 1) {
				stop = start(set, update) || noop$3;
			}
			run(value);
			return () => {
				subscribers.delete(subscriber);
				if (subscribers.size === 0 && stop) {
					stop();
					stop = null;
				}
			};
		}
		return { set, update, subscribe };
	}

	/**
	 * Derived value store by synchronizing one or more readable stores and
	 * applying an aggregation function over its input values.
	 *
	 * https://svelte.dev/docs/svelte-store#derived
	 * @template {import('./private.js').Stores} S
	 * @template T
	 * @overload
	 * @param {S} stores - input stores
	 * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values
	 * @param {T} [initial_value] - initial value
	 * @returns {import('./public.js').Readable<T>}
	 */

	/**
	 * Derived value store by synchronizing one or more readable stores and
	 * applying an aggregation function over its input values.
	 *
	 * https://svelte.dev/docs/svelte-store#derived
	 * @template {import('./private.js').Stores} S
	 * @template T
	 * @overload
	 * @param {S} stores - input stores
	 * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values
	 * @param {T} [initial_value] - initial value
	 * @returns {import('./public.js').Readable<T>}
	 */

	/**
	 * @template {import('./private.js').Stores} S
	 * @template T
	 * @param {S} stores
	 * @param {Function} fn
	 * @param {T} [initial_value]
	 * @returns {import('./public.js').Readable<T>}
	 */
	function derived(stores, fn, initial_value) {
		const single = !Array.isArray(stores);
		/** @type {Array<import('./public.js').Readable<any>>} */
		const stores_array = single ? [stores] : stores;
		if (!stores_array.every(Boolean)) {
			throw new Error('derived() expects stores as input, got a falsy value');
		}
		const auto = fn.length < 2;
		return readable(initial_value, (set, update) => {
			let started = false;
			const values = [];
			let pending = 0;
			let cleanup = noop$3;
			const sync = () => {
				if (pending) {
					return;
				}
				cleanup();
				const result = fn(single ? values[0] : values, set, update);
				if (auto) {
					set(result);
				} else {
					cleanup = is_function(result) ? result : noop$3;
				}
			};
			const unsubscribers = stores_array.map((store, i) =>
				subscribe(
					store,
					(value) => {
						values[i] = value;
						pending &= ~(1 << i);
						if (started) {
							sync();
						}
					},
					() => {
						pending |= 1 << i;
					}
				)
			);
			started = true;
			sync();
			return function stop() {
				run_all(unsubscribers);
				cleanup();
				// We need to set this to false because callbacks can still happen despite having unsubscribed:
				// Callbacks might already be placed in the queue which doesn't know it should no longer
				// invoke this derived store.
				started = false;
			};
		});
	}

	const getDomContext = (name,el) => {
	    if (!el || !window){
	        return undefined;
	    }
	    let par = el;
	    while(par = par.parentNode){
	        if (par.motionDomContext && par.motionDomContext.has(name)){
	            return par.motionDomContext.get(name)
	        }
	    }
	    return undefined;
	};

	const setDomContext = (name,el,value) => {
	    if (el && window){
	        if (!el.motionDomContext){
	            el.motionDomContext = new Map();
	        }
	        el.motionDomContext.set(name,value);
	    }
	};

	/**
	 * @public
	 */
	var MotionConfigContext = (c)=> getDomContext("MotionConfig",c)||writable({
	    transformPagePoint: function (p) { return p; },
	    isStatic: false,
	});

	/* node_modules/svelte-motion/src/context/ScaleCorrectionProvider.svelte generated by Svelte v4.2.10 */

	function create_fragment$X(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[2].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[1],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$X.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	const ScaleCorrectionContext = isCustom => getDomContext("ScaleCorrection", isCustom) || writable([]);
	const ScaleCorrectionParentContext = () => writable([]);

	const provideScaleCorrection = isCustom => {
		const fromParent = getContext(ScaleCorrectionContext) || ScaleCorrectionContext(isCustom);
		const ctx = ScaleCorrectionContext();
		setContext(ScaleCorrectionContext, ctx);
		setDomContext("ScaleCorrection", isCustom, ctx);
		setContext(ScaleCorrectionParentContext, fromParent);
	};

	function instance$X($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ScaleCorrectionProvider', slots, ['default']);
		let { isCustom } = $$props;
		provideScaleCorrection(isCustom);

		$$self.$$.on_mount.push(function () {
			if (isCustom === undefined && !('isCustom' in $$props || $$self.$$.bound[$$self.$$.props['isCustom']])) {
				console.warn("<ScaleCorrectionProvider> was created without expected prop 'isCustom'");
			}
		});

		const writable_props = ['isCustom'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ScaleCorrectionProvider> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('isCustom' in $$props) $$invalidate(0, isCustom = $$props.isCustom);
			if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			writable,
			getContext,
			setContext,
			getDomContext,
			setDomContext,
			ScaleCorrectionContext,
			ScaleCorrectionParentContext,
			provideScaleCorrection,
			isCustom
		});

		$$self.$inject_state = $$props => {
			if ('isCustom' in $$props) $$invalidate(0, isCustom = $$props.isCustom);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [isCustom, $$scope, slots];
	}

	class ScaleCorrectionProvider extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$X, create_fragment$X, safe_not_equal, { isCustom: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ScaleCorrectionProvider",
				options,
				id: create_fragment$X.name
			});
		}

		get isCustom() {
			throw new Error("<ScaleCorrectionProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isCustom(value) {
			throw new Error("<ScaleCorrectionProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var ScaleCorrectionProvider$1 = ScaleCorrectionProvider;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	/**
	 * Converts seconds to milliseconds
	 *
	 * @param seconds - Time in seconds.
	 * @return milliseconds - Converted time in milliseconds.
	 */
	var secondsToMilliseconds = function (seconds) { return seconds * 1000; };

	//import { invariant } from 'hey-listen';

	var easingLookup = {
	    linear: linear$1,
	    easeIn: easeIn,
	    easeInOut: easeInOut,
	    easeOut: easeOut,
	    circIn: circIn,
	    circInOut: circInOut,
	    circOut: circOut,
	    backIn: backIn,
	    backInOut: backInOut,
	    backOut: backOut,
	    anticipate: anticipate,
	    bounceIn: bounceIn,
	    bounceInOut: bounceInOut,
	    bounceOut: bounceOut,
	};
	var easingDefinitionToFunction = function (definition) {
	    if (Array.isArray(definition)) {
	        // If cubic bezier definition, create bezier curve
	        //invariant(definition.length === 4, "Cubic bezier arrays must contain four numerical values.");
	        var _a = __read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];
	        return cubicBezier(x1, y1, x2, y2);
	    }
	    else if (typeof definition === "string") {
	        // Else lookup from table
	        //invariant(easingLookup[definition] !== undefined, "Invalid easing type '" + definition + "'");
	        return easingLookup[definition];
	    }
	    return definition;
	};
	var isEasingArray = function (ease) {
	    return Array.isArray(ease) && typeof ease[0] !== "number";
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * Check if a value is animatable. Examples:
	 *
	 * ✅: 100, "100px", "#fff"
	 * ❌: "block", "url(2.jpg)"
	 * @param value
	 *
	 * @internal
	 */
	var isAnimatable = function (key, value) {
	    // If the list of keys tat might be non-animatable grows, replace with Set
	    if (key === "zIndex")
	        return false;
	    // If it's a number or a keyframes array, we can animate it. We might at some point
	    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,
	    // but for now lets leave it like this for performance reasons
	    if (typeof value === "number" || Array.isArray(value))
	        return true;
	    if (typeof value === "string" && // It's animatable if we have a string
	        complex.test(value) && // And it contains numbers and/or colors
	        !value.startsWith("url(") // Unless it starts with "url("
	    ) {
	        return true;
	    }
	    return false;
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var isKeyframesTarget = function (v) {
	    return Array.isArray(v);
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/


	var underDampedSpring = function () { return ({
	    type: "spring",
	    stiffness: 500,
	    damping: 25,
	    restDelta: 0.5,
	    restSpeed: 10,
	}); };
	var criticallyDampedSpring = function (to) { return ({
	    type: "spring",
	    stiffness: 550,
	    damping: to === 0 ? 2 * Math.sqrt(550) : 30,
	    restDelta: 0.01,
	    restSpeed: 10,
	}); };
	var linearTween = function () { return ({
	    type: "keyframes",
	    ease: "linear",
	    duration: 0.3,
	}); };
	var keyframes = function (values) { return ({
	    type: "keyframes",
	    duration: 0.8,
	    values: values,
	}); };
	var defaultTransitions = {
	    x: underDampedSpring,
	    y: underDampedSpring,
	    z: underDampedSpring,
	    rotate: underDampedSpring,
	    rotateX: underDampedSpring,
	    rotateY: underDampedSpring,
	    rotateZ: underDampedSpring,
	    scaleX: criticallyDampedSpring,
	    scaleY: criticallyDampedSpring,
	    scale: criticallyDampedSpring,
	    opacity: linearTween,
	    backgroundColor: linearTween,
	    color: linearTween,
	    default: criticallyDampedSpring,
	};
	var getDefaultTransition = function (valueKey, to) {
	    var transitionFactory;
	    if (isKeyframesTarget(to)) {
	        transitionFactory = keyframes;
	    }
	    else {
	        transitionFactory =
	            defaultTransitions[valueKey] || defaultTransitions.default;
	    }
	    return __assign({ to: to }, transitionFactory(to));
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var int = __assign(__assign({}, number), { transform: Math.round });

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var numberValueTypes = {
	    // Border props
	    borderWidth: px,
	    borderTopWidth: px,
	    borderRightWidth: px,
	    borderBottomWidth: px,
	    borderLeftWidth: px,
	    borderRadius: px,
	    radius: px,
	    borderTopLeftRadius: px,
	    borderTopRightRadius: px,
	    borderBottomRightRadius: px,
	    borderBottomLeftRadius: px,
	    // Positioning props
	    width: px,
	    maxWidth: px,
	    height: px,
	    maxHeight: px,
	    size: px,
	    top: px,
	    right: px,
	    bottom: px,
	    left: px,
	    // Spacing props
	    padding: px,
	    paddingTop: px,
	    paddingRight: px,
	    paddingBottom: px,
	    paddingLeft: px,
	    margin: px,
	    marginTop: px,
	    marginRight: px,
	    marginBottom: px,
	    marginLeft: px,
	    // Transform props
	    rotate: degrees,
	    rotateX: degrees,
	    rotateY: degrees,
	    rotateZ: degrees,
	    scale: scale$1,
	    scaleX: scale$1,
	    scaleY: scale$1,
	    scaleZ: scale$1,
	    skew: degrees,
	    skewX: degrees,
	    skewY: degrees,
	    distance: px,
	    translateX: px,
	    translateY: px,
	    translateZ: px,
	    x: px,
	    y: px,
	    z: px,
	    perspective: px,
	    transformPerspective: px,
	    opacity: alpha,
	    originX: progressPercentage,
	    originY: progressPercentage,
	    originZ: px,
	    // Misc
	    zIndex: int,
	    // SVG
	    fillOpacity: alpha,
	    strokeOpacity: alpha,
	    numOctaves: int,
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * A map of default value types for common values
	 */
	var defaultValueTypes = __assign(__assign({}, numberValueTypes), { 
	    // Color props
	    color: color, backgroundColor: color, outlineColor: color, fill: color, stroke: color, 
	    // Border props
	    borderColor: color, borderTopColor: color, borderRightColor: color, borderBottomColor: color, borderLeftColor: color, filter: filter$1, WebkitFilter: filter$1 });
	/**
	 * Gets the default ValueType for the provided value key
	 */
	var getDefaultValueType = function (key) { return defaultValueTypes[key]; };

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	function getAnimatableNone(key, value) {
	    var _a;
	    var defaultValueType = getDefaultValueType(key);
	    if (defaultValueType !== filter$1)
	        defaultValueType = complex;
	    // If value is not recognised as animatable, ie "none", create an animatable version origin based on the target
	    return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);
	}

	/** 
	based on framer-motion@4.1.15,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * Decide whether a transition is defined on a given Transition.
	 * This filters out orchestration options and returns true
	 * if any options are left.
	 */
	function isTransitionDefined(_a) {
	    _a.when; _a.delay; _a.delayChildren; _a.staggerChildren; _a.staggerDirection; _a.repeat; _a.repeatType; _a.repeatDelay; _a.from; var transition = __rest(_a, ["when", "delay", "delayChildren", "staggerChildren", "staggerDirection", "repeat", "repeatType", "repeatDelay", "from"]);
	    return !!Object.keys(transition).length;
	}
	/**
	 * Convert Framer Motion's Transition type into Popmotion-compatible options.
	 */
	function convertTransitionToAnimationOptions(_a) {
	    var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop = _a.loop, transition = __rest(_a, ["ease", "times", "yoyo", "flip", "loop"]);
	    var options = __assign({}, transition);
	    if (times)
	        options["offset"] = times;
	    /**
	     * Convert any existing durations from seconds to milliseconds
	     */
	    if (transition.duration)
	        options["duration"] = secondsToMilliseconds(transition.duration);
	    if (transition.repeatDelay)
	        options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);
	    /**
	     * Map easing names to Popmotion's easing functions
	     */
	    if (ease) {
	        options["ease"] = isEasingArray(ease)
	            ? ease.map(easingDefinitionToFunction)
	            : easingDefinitionToFunction(ease);
	    }
	    /**
	     * Support legacy transition API
	     */
	    if (transition.type === "tween")
	        options.type = "keyframes";
	    /**
	     * TODO: These options are officially removed from the API.
	     */
	    if (yoyo || loop || flip) {
	        if (yoyo) {
	            options.repeatType = "reverse";
	        }
	        else if (loop) {
	            options.repeatType = "loop";
	        }
	        else if (flip) {
	            options.repeatType = "mirror";
	        }
	        options.repeat = loop || yoyo || flip || transition.repeat;
	    }
	    /**
	     * TODO: Popmotion 9 has the ability to automatically detect whether to use
	     * a keyframes or spring animation, but does so by detecting velocity and other spring options.
	     * It'd be good to introduce a similar thing here.
	     */
	    if (transition.type !== "spring")
	        options.type = "keyframes";
	    return options;
	}
	/**
	 * Get the delay for a value by checking Transition with decreasing specificity.
	 */
	function getDelayFromTransition(transition, key) {
	    var _a;
	    var valueTransition = getValueTransition(transition, key) || {};
	    return (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : 0;
	}
	function hydrateKeyframes(options) {
	    if (Array.isArray(options.to) && options.to[0] === null) {
	        options.to = __spreadArray([], __read(options.to));
	        options.to[0] = options.from;
	    }
	    return options;
	}
	function getPopmotionAnimationOptions(transition, options, key) {
	    var _a;
	    if (Array.isArray(options.to)) {
	        (_a = transition.duration) !== null && _a !== void 0 ? _a : (transition.duration = 0.8);
	    }
	    hydrateKeyframes(options);
	    /**
	     * Get a default transition if none is determined to be defined.
	     */
	    if (!isTransitionDefined(transition)) {
	        transition = __assign(__assign({}, transition), getDefaultTransition(key, options.to));
	    }
	    return __assign(__assign({}, options), convertTransitionToAnimationOptions(transition));
	}
	/**
	 *
	 */
	function getAnimation(key, value, target, transition, onComplete) {
	    var _a;
	    var valueTransition = getValueTransition(transition, key);
	    var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();
	    var isTargetAnimatable = isAnimatable(key, target);
	    if (origin === "none" && isTargetAnimatable && typeof target === "string") {
	        /**
	         * If we're trying to animate from "none", try and get an animatable version
	         * of the target. This could be improved to work both ways.
	         */
	        origin = getAnimatableNone(key, target);
	    }
	    else if (isZero(origin) && typeof target === "string") {
	        origin = getZeroUnit(target);
	    }
	    else if (!Array.isArray(target) &&
	        isZero(target) &&
	        typeof origin === "string") {
	        target = getZeroUnit(origin);
	    }
	    var isOriginAnimatable = isAnimatable(key, origin);
	    function start() {
	        var options = {
	            from: origin,
	            to: target,
	            velocity: value.getVelocity(),
	            onComplete: onComplete,
	            onUpdate: function (v) { return value.set(v); },
	        };
	        return valueTransition.type === "inertia" ||
	            valueTransition.type === "decay"
	            ? inertia(__assign(__assign({}, options), valueTransition))
	            : animate(__assign(__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: function (v) {
	                    var _a;
	                    options.onUpdate(v);
	                    (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);
	                }, onComplete: function () {
	                    var _a;
	                    options.onComplete();
	                    (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);
	                } }));
	    }
	    function set() {
	        var _a;
	        value.set(target);
	        onComplete();
	        (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);
	        return { stop: function () { } };
	    }
	    return !isOriginAnimatable ||
	        !isTargetAnimatable ||
	        valueTransition.type === false
	        ? set
	        : start;
	}
	function isZero(value) {
	    return (value === 0 ||
	        (typeof value === "string" &&
	            parseFloat(value) === 0 &&
	            value.indexOf(" ") === -1));
	}
	function getZeroUnit(potentialUnitType) {
	    return typeof potentialUnitType === "number"
	        ? 0
	        : getAnimatableNone("", potentialUnitType);
	}
	function getValueTransition(transition, key) {
	    return transition[key] || transition["default"] || transition;
	}
	/**
	 * Start animation on a MotionValue. This function is an interface between
	 * Framer Motion and Popmotion
	 *
	 * @internal
	 */
	function startAnimation(key, value, target, transition) {
	    if (transition === void 0) { transition = {}; }
	    return value.start(function (onComplete) {
	        var delayTimer;
	        var controls;
	        var animation = getAnimation(key, value, target, transition, onComplete);
	        var delay = getDelayFromTransition(transition, key);
	        var start = function () { return (controls = animation()); };
	        if (delay) {
	            delayTimer = setTimeout(start, secondsToMilliseconds(delay));
	        }
	        else {
	            start();
	        }
	        return function () {
	            clearTimeout(delayTimer);
	            controls === null || controls === void 0 ? void 0 : controls.stop();
	        };
	    });
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	/**
	 * Check if value is a numerical string, ie a string that is purely a number eg "100" or "-100.1"
	 */
	var isNumericalString = function (v) { return /^\-?\d*\.?\d+$/.test(v); };

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var isCustomValue = function (v) {
	    return Boolean(v && typeof v === "object" && v.mix && v.toValue);
	};
	var resolveFinalValueInKeyframes = function (v) {
	    // TODO maybe throw if v.length - 1 is placeholder token?
	    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	/**
	 * Tests a provided value against a ValueType
	 */
	var testValueType = function (v) { return function (type) { return type.test(v); }; };

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * ValueType for "auto"
	 */
	var auto$1 = {
	    test: function (v) { return v === "auto"; },
	    parse: function (v) { return v; },
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * A list of value types commonly used for dimensions
	 */
	var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto$1];
	/**
	 * Tests a dimensional value against the list of dimension ValueTypes
	 */
	var findDimensionValueType = function (v) {
	    return dimensionValueTypes.find(testValueType(v));
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * A list of all ValueTypes
	 */
	var valueTypes = __spreadArray(__spreadArray([], __read(dimensionValueTypes)), [color, complex]);
	/**
	 * Tests a value against the list of ValueTypes
	 */
	var findValueType = function (v) { return valueTypes.find(testValueType(v)); };

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	/**
	 * Decides if the supplied variable is an array of variant labels
	 */
	function isVariantLabels(v) {
	    return Array.isArray(v);
	}
	/**
	 * Decides if the supplied variable is variant label
	 */
	function isVariantLabel(v) {
	    return typeof v === "string" || isVariantLabels(v);
	}
	/**
	 * Creates an object containing the latest state of every MotionValue on a VisualElement
	 */
	function getCurrent(visualElement) {
	    var current = {};
	    visualElement.forEachValue(function (value, key) { return (current[key] = value.get()); });
	    return current;
	}
	/**
	 * Creates an object containing the latest velocity of every MotionValue on a VisualElement
	 */
	function getVelocity$1(visualElement) {
	    var velocity = {};
	    visualElement.forEachValue(function (value, key) { return (velocity[key] = value.getVelocity()); });
	    return velocity;
	}
	function resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {
	    var _a;
	    if (currentValues === void 0) { currentValues = {}; }
	    if (currentVelocity === void 0) { currentVelocity = {}; }
	    if (typeof definition === "string") {
	        definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];
	    }
	    return typeof definition === "function"
	        ? definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity)
	        : definition;
	}
	function resolveVariant(visualElement, definition, custom) {
	    var props = visualElement.getProps();
	    return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));
	}
	function checkIfControllingVariants(props) {
	    var _a;
	    return (typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === "function" ||
	        isVariantLabel(props.initial) ||
	        isVariantLabel(props.animate) ||
	        isVariantLabel(props.whileHover) ||
	        isVariantLabel(props.whileDrag) ||
	        isVariantLabel(props.whileTap) ||
	        isVariantLabel(props.whileFocus) ||
	        isVariantLabel(props.exit));
	}
	function checkIfVariantNode(props) {
	    return Boolean(checkIfControllingVariants(props) || props.variants);
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * Set VisualElement's MotionValue, creating a new MotionValue for it if
	 * it doesn't exist.
	 */
	function setMotionValue(visualElement, key, value) {
	    if (visualElement.hasValue(key)) {
	        visualElement.getValue(key).set(value);
	    }
	    else {
	        visualElement.addValue(key, motionValue(value));
	    }
	}
	function setTarget(visualElement, definition) {
	    var resolved = resolveVariant(visualElement, definition);
	    var _a = resolved
	        ? visualElement.makeTargetAnimatable(resolved, false)
	        : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b; _a.transition; var target = __rest(_a, ["transitionEnd", "transition"]);
	    target = __assign(__assign({}, target), transitionEnd);
	    for (var key in target) {
	        var value = resolveFinalValueInKeyframes(target[key]);
	        setMotionValue(visualElement, key, value);
	    }
	}
	function setVariants(visualElement, variantLabels) {
	    var reversedLabels = __spreadArray([], __read(variantLabels)).reverse();
	    reversedLabels.forEach(function (key) {
	        var _a;
	        var variant = visualElement.getVariant(key);
	        variant && setTarget(visualElement, variant);
	        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {
	            setVariants(child, variantLabels);
	        });
	    });
	}
	function setValues(visualElement, definition) {
	    if (Array.isArray(definition)) {
	        return setVariants(visualElement, definition);
	    }
	    else if (typeof definition === "string") {
	        return setVariants(visualElement, [definition]);
	    }
	    else {
	        setTarget(visualElement, definition);
	    }
	}
	function checkTargetForNewValues(visualElement, target, origin) {
	    var _a, _b, _c;
	    var _d;
	    var newValueKeys = Object.keys(target).filter(function (key) { return !visualElement.hasValue(key); });
	    var numNewValues = newValueKeys.length;
	    if (!numNewValues)
	        return;
	    for (var i = 0; i < numNewValues; i++) {
	        var key = newValueKeys[i];
	        var targetValue = target[key];
	        var value = null;
	        /**
	         * If the target is a series of keyframes, we can use the first value
	         * in the array. If this first value is null, we'll still need to read from the DOM.
	         */
	        if (Array.isArray(targetValue)) {
	            value = targetValue[0];
	        }
	        /**
	         * If the target isn't keyframes, or the first keyframe was null, we need to
	         * first check if an origin value was explicitly defined in the transition as "from",
	         * if not read the value from the DOM. As an absolute fallback, take the defined target value.
	         */
	        if (value === null) {
	            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
	        }
	        /**
	         * If value is still undefined or null, ignore it. Preferably this would throw,
	         * but this was causing issues in Framer.
	         */
	        if (value === undefined || value === null)
	            continue;
	        if (typeof value === "string" && isNumericalString(value)) {
	            // If this is a number read as a string, ie "0" or "200", convert it to a number
	            value = parseFloat(value);
	        }
	        else if (!findValueType(value) && complex.test(targetValue)) {
	            value = getAnimatableNone(key, targetValue);
	        }
	        visualElement.addValue(key, motionValue(value));
	        (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : (_d[key] = value);
	        visualElement.setBaseTarget(key, value);
	    }
	}
	function getOriginFromTransition(key, transition) {
	    if (!transition)
	        return;
	    var valueTransition = transition[key] || transition["default"] || transition;
	    return valueTransition.from;
	}
	function getOrigin(target, transition, visualElement) {
	    var _a, _b;
	    var origin = {};
	    for (var key in target) {
	        origin[key] =
	            (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();
	    }
	    return origin;
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * @internal
	 */
	function animateVisualElement(visualElement, definition, options) {
	    if (options === void 0) { options = {}; }
	    visualElement.notifyAnimationStart();
	    var animation;
	    if (Array.isArray(definition)) {
	        var animations = definition.map(function (variant) {
	            return animateVariant(visualElement, variant, options);
	        });
	        animation = Promise.all(animations);
	    }
	    else if (typeof definition === "string") {
	        animation = animateVariant(visualElement, definition, options);
	    }
	    else {
	        var resolvedDefinition = typeof definition === "function"
	            ? resolveVariant(visualElement, definition, options.custom)
	            : definition;
	        animation = animateTarget(visualElement, resolvedDefinition, options);
	    }
	    return animation.then(function () {
	        return visualElement.notifyAnimationComplete(definition);
	    });
	}
	function animateVariant(visualElement, variant, options) {
	    var _a;
	    if (options === void 0) { options = {}; }
	    var resolved = resolveVariant(visualElement, variant, options.custom);
	    var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;
	    if (options.transitionOverride) {
	        transition = options.transitionOverride;
	    }
	    /**
	     * If we have a variant, create a callback that runs it as an animation.
	     * Otherwise, we resolve a Promise immediately for a composable no-op.
	     */
	    var getAnimation = resolved
	        ? function () { return animateTarget(visualElement, resolved, options); }
	        : function () { return Promise.resolve(); };
	    /**
	     * If we have children, create a callback that runs all their animations.
	     * Otherwise, we resolve a Promise immediately for a composable no-op.
	     */
	    var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size)
	        ? function (forwardDelay) {
	            if (forwardDelay === void 0) { forwardDelay = 0; }
	            var _a = transition.delayChildren, delayChildren = _a === void 0 ? 0 : _a, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;
	            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
	        }
	        : function () { return Promise.resolve(); };
	    /**
	     * If the transition explicitly defines a "when" option, we need to resolve either
	     * this animation or all children animations before playing the other.
	     */
	    var when = transition.when;
	    if (when) {
	        var _c = __read(when === "beforeChildren"
	            ? [getAnimation, getChildAnimations]
	            : [getChildAnimations, getAnimation], 2), first = _c[0], last = _c[1];
	        return first().then(last);
	    }
	    else {
	        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
	    }
	}
	/**
	 * @internal
	 */
	function animateTarget(visualElement, definition, _a) {
	    var _b;
	    var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;
	    var _e = visualElement.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = __rest(_e, ["transition", "transitionEnd"]);
	    if (transitionOverride)
	        transition = transitionOverride;
	    var animations = [];
	    var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);
	    for (var key in target) {
	        var value = visualElement.getValue(key);
	        var valueTarget = target[key];
	        if (!value ||
	            valueTarget === undefined ||
	            (animationTypeState &&
	                shouldBlockAnimation(animationTypeState, key))) {
	            continue;
	        }
	        var animation = startAnimation(key, value, valueTarget, __assign({ delay: delay }, transition));
	        animations.push(animation);
	    }
	    return Promise.all(animations).then(function () {
	        transitionEnd && setTarget(visualElement, transitionEnd);
	    });
	}
	function animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {
	    if (delayChildren === void 0) { delayChildren = 0; }
	    if (staggerChildren === void 0) { staggerChildren = 0; }
	    if (staggerDirection === void 0) { staggerDirection = 1; }
	    var animations = [];
	    var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
	    var generateStaggerDuration = staggerDirection === 1
	        ? function (i) {
	            if (i === void 0) { i = 0; }
	            return i * staggerChildren;
	        }
	        : function (i) {
	            if (i === void 0) { i = 0; }
	            return maxStaggerDuration - i * staggerChildren;
	        };
	    Array.from(visualElement.variantChildren)
	        .sort(sortByTreeOrder)
	        .forEach(function (child, i) {
	        animations.push(animateVariant(child, variant, __assign(__assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(function () { return child.notifyAnimationComplete(variant); }));
	    });
	    return Promise.all(animations);
	}
	function stopAnimation(visualElement) {
	    visualElement.forEachValue(function (value) { return value.stop(); });
	}
	function sortByTreeOrder(a, b) {
	    return a.sortNodePosition(b);
	}
	/**
	 * Decide whether we should block this animation. Previously, we achieved this
	 * just by checking whether the key was listed in protectedKeys, but this
	 * posed problems if an animation was triggered by afterChildren and protectedKeys
	 * had been set to true in the meantime.
	 */
	function shouldBlockAnimation(_a, key) {
	    
	    var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;
	    var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
	    needsAnimating[key] = false;
	    return shouldBlock;
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/


	/**
	 * @public
	 */
	function animationControls(startStopNotifier) {
	    /**
	     * Track whether the host component has mounted.
	     */
	    var hasMounted = false;
	    /**
	     * Pending animations that are started before a component is mounted.
	     * TODO: Remove this as animations should only run in effects
	     */
	    var pendingAnimations = [];
	    /**
	     * A collection of linked component animation controls.
	     */
	    var subscribers = new Set();
	    var stopNotification;
	    var controls = {
	        subscribe: function (visualElement) {
	            if (subscribers.size === 0){
	                stopNotification = startStopNotifier?.();
	            }
	            subscribers.add(visualElement);
	            return function () { 
	                subscribers.delete(visualElement); 
	                if (subscribers.size===0){
	                    stopNotification?.();
	                }
	            };
	        },
	        start: function (definition, transitionOverride) {
	            /**
	             * TODO: We only perform this hasMounted check because in Framer we used to
	             * encourage the ability to start an animation within the render phase. This
	             * isn't behaviour concurrent-safe so when we make Framer concurrent-safe
	             * we can ditch this.
	             */
	            if (hasMounted) {
	                var animations_1 = [];
	                subscribers.forEach(function (visualElement) {
	                    animations_1.push(animateVisualElement(visualElement, definition, {
	                        transitionOverride: transitionOverride,
	                    }));
	                });
	                return Promise.all(animations_1);
	            }
	            else {
	                return new Promise(function (resolve) {
	                    pendingAnimations.push({
	                        animation: [definition, transitionOverride],
	                        resolve: resolve,
	                    });
	                });
	            }
	        },
	        set: function (definition) {
	            //invariant(hasMounted, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");
	            return subscribers.forEach(function (visualElement) {
	                setValues(visualElement, definition);
	            });
	        },
	        stop: function () {
	            subscribers.forEach(function (visualElement) {
	                stopAnimation(visualElement);
	            });
	        },
	        mount: function () {
	            hasMounted = true;
	            pendingAnimations.forEach(function (_a) {
	                var animation = _a.animation, resolve = _a.resolve;
	                controls.start.apply(controls, __spreadArray([], __read(animation))).then(resolve);
	            });
	            return function () {
	                hasMounted = false;
	                controls.stop();
	            };
	        },
	    };
	    return controls;
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	var valueScaleCorrection = {};
	/**
	 * @internal
	 */
	function addScaleCorrection(correctors) {
	    for (var key in correctors) {
	        valueScaleCorrection[key] = correctors[key];
	    }
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	// Call a handler once for each axis
	function eachAxis(handler) {
	    return [handler("x"), handler("y")];
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	function noop$2(any) {
	    return any;
	}

	/** 
	based on framer-motion@4.1.15,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * Bounding boxes tend to be defined as top, left, right, bottom. For various operations
	 * it's easier to consider each axis individually. This function returns a bounding box
	 * as a map of single-axis min/max values.
	 */
	function convertBoundingBoxToAxisBox(_a) {
	    var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;
	    return {
	        x: { min: left, max: right },
	        y: { min: top, max: bottom },
	    };
	}
	function convertAxisBoxToBoundingBox(_a) {
	    var x = _a.x, y = _a.y;
	    return {
	        top: y.min,
	        bottom: y.max,
	        left: x.min,
	        right: x.max,
	    };
	}
	/**
	 * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function
	 * provided by Framer to allow measured points to be corrected for device scaling. This is used
	 * when measuring DOM elements and DOM event points.
	 */
	function transformBoundingBox(_a, transformPoint) {
	    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;
	    if (transformPoint === void 0) { transformPoint = noop$2; }
	    var topLeft = transformPoint({ x: left, y: top });
	    var bottomRight = transformPoint({ x: right, y: bottom });
	    return {
	        top: topLeft.y,
	        left: topLeft.x,
	        bottom: bottomRight.y,
	        right: bottomRight.x,
	    };
	}
	/**
	 * Create an empty axis box of zero size
	 */
	function axisBox() {
	    return { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };
	}
	function copyAxisBox(box) {
	    return {
	        x: __assign({}, box.x),
	        y: __assign({}, box.y),
	    };
	}
	/**
	 * Create an empty box delta
	 */
	var zeroDelta = {
	    translate: 0,
	    scale: 1,
	    origin: 0,
	    originPoint: 0,
	};
	function delta() {
	    return {
	        x: __assign({}, zeroDelta),
	        y: __assign({}, zeroDelta),
	    };
	}

	/** 
	based on framer-motion@4.1.11,
	Copyright (c) 2018 Framer B.V.
	*/
	function isDraggable(visualElement) {
	    var _a = visualElement.getProps(), drag = _a.drag, _dragX = _a._dragX;
	    return drag && !_dragX;
	}

	/** 
	based on framer-motion@4.1.15,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * Reset an axis to the provided origin box.
	 *
	 * This is a mutative operation.
	 */
	function resetAxis(axis, originAxis) {
	    axis.min = originAxis.min;
	    axis.max = originAxis.max;
	}
	/**
	 * Reset a box to the provided origin box.
	 *
	 * This is a mutative operation.
	 */
	function resetBox(box, originBox) {
	    resetAxis(box.x, originBox.x);
	    resetAxis(box.y, originBox.y);
	}
	/**
	 * Scales a point based on a factor and an originPoint
	 */
	function scalePoint(point, scale, originPoint) {
	    var distanceFromOrigin = point - originPoint;
	    var scaled = scale * distanceFromOrigin;
	    return originPoint + scaled;
	}
	/**
	 * Applies a translate/scale delta to a point
	 */
	function applyPointDelta(point, translate, scale, originPoint, boxScale) {
	    if (boxScale !== undefined) {
	        point = scalePoint(point, boxScale, originPoint);
	    }
	    return scalePoint(point, scale, originPoint) + translate;
	}
	/**
	 * Applies a translate/scale delta to an axis
	 */
	function applyAxisDelta(axis, translate, scale, originPoint, boxScale) {
	    if (translate === void 0) { translate = 0; }
	    if (scale === void 0) { scale = 1; }
	    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);
	    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);
	}
	/**
	 * Applies a translate/scale delta to a box
	 */
	function applyBoxDelta(box, _a) {
	    var x = _a.x, y = _a.y;
	    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
	    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
	}
	/**
	 * Apply a transform to an axis from the latest resolved motion values.
	 * This function basically acts as a bridge between a flat motion value map
	 * and applyAxisDelta
	 */
	function applyAxisTransforms(final, axis, transforms, _a) {
	    var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
	    // Copy the current axis to the final axis before mutation
	    final.min = axis.min;
	    final.max = axis.max;
	    var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;
	    var originPoint = mix$1(axis.min, axis.max, axisOrigin);
	    // Apply the axis delta to the final axis
	    applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
	}
	/**
	 * The names of the motion values we want to apply as translation, scale and origin.
	 */
	var xKeys = ["x", "scaleX", "originX"];
	var yKeys = ["y", "scaleY", "originY"];
	/**
	 * Apply a transform to a box from the latest resolved motion values.
	 */
	function applyBoxTransforms(finalBox, box, transforms) {
	    applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);
	    applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);
	}
	/**
	 * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse
	 */
	function removePointDelta(point, translate, scale, originPoint, boxScale) {
	    point -= translate;
	    point = scalePoint(point, 1 / scale, originPoint);
	    if (boxScale !== undefined) {
	        point = scalePoint(point, 1 / boxScale, originPoint);
	    }
	    return point;
	}
	/**
	 * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse
	 */
	function removeAxisDelta(axis, translate, scale, origin, boxScale) {
	    if (translate === void 0) { translate = 0; }
	    if (scale === void 0) { scale = 1; }
	    if (origin === void 0) { origin = 0.5; }
	    var originPoint = mix$1(axis.min, axis.max, origin) - translate;
	    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);
	    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);
	}
	/**
	 * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse
	 * and acts as a bridge between motion values and removeAxisDelta
	 */
	function removeAxisTransforms(axis, transforms, _a) {
	    var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
	    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);
	}
	/**
	 * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse
	 * and acts as a bridge between motion values and removeAxisDelta
	 */
	function removeBoxTransforms(box, transforms) {
	    removeAxisTransforms(box.x, transforms, xKeys);
	    removeAxisTransforms(box.y, transforms, yKeys);
	}
	/**
	 * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms
	 * in a tree upon our box before then calculating how to project it into our desired viewport-relative box
	 *
	 * This is the final nested loop within updateLayoutDelta for future refactoring
	 */
	function applyTreeDeltas(box, treeScale, treePath) {
	    var treeLength = treePath.length;
	    if (!treeLength)
	        return;
	    // Reset the treeScale
	    treeScale.x = treeScale.y = 1;
	    var node;
	    var delta;
	    for (var i = 0; i < treeLength; i++) {
	        node = treePath[i];
	        delta = node.getLayoutState().delta;
	        // Incoporate each ancestor's scale into a culmulative treeScale for this component
	        treeScale.x *= delta.x.scale;
	        treeScale.y *= delta.y.scale;
	        // Apply each ancestor's calculated delta into this component's recorded layout box
	        applyBoxDelta(box, delta);
	        // If this is a draggable ancestor, also incorporate the node's transform to the layout box
	        if (isDraggable(node)) {
	            applyBoxTransforms(box, box, node.getLatestValues());
	        }
	    }
	}

	/** 
	based on framer-motion@4.1.15,
	Copyright (c) 2018 Framer B.V.
	*/

	var clampProgress = function (v) { return clamp$1(0, 1, v); };
	/**
	 * Returns true if the provided value is within maxDistance of the provided target
	 */
	function isNear(value, target, maxDistance) {
	    if (target === void 0) { target = 0; }
	    if (maxDistance === void 0) { maxDistance = 0.01; }
	    return distance$1(value, target) < maxDistance;
	}
	function calcLength(axis) {
	    return axis.max - axis.min;
	}
	/**
	 * Calculate a transform origin relative to the source axis, between 0-1, that results
	 * in an asthetically pleasing scale/transform needed to project from source to target.
	 */
	function calcOrigin$1(source, target) {
	    var origin = 0.5;
	    var sourceLength = calcLength(source);
	    var targetLength = calcLength(target);
	    if (targetLength > sourceLength) {
	        origin = progress(target.min, target.max - sourceLength, source.min);
	    }
	    else if (sourceLength > targetLength) {
	        origin = progress(source.min, source.max - targetLength, target.min);
	    }
	    return clampProgress(origin);
	}
	/**
	 * Update the AxisDelta with a transform that projects source into target.
	 *
	 * The transform `origin` is optional. If not provided, it'll be automatically
	 * calculated based on the relative positions of the two bounding boxes.
	 */
	function updateAxisDelta(delta, source, target, origin) {
	    if (origin === void 0) { origin = 0.5; }
	    delta.origin = origin;
	    delta.originPoint = mix$1(source.min, source.max, delta.origin);
	    delta.scale = calcLength(target) / calcLength(source);
	    if (isNear(delta.scale, 1, 0.0001))
	        delta.scale = 1;
	    delta.translate =
	        mix$1(target.min, target.max, delta.origin) - delta.originPoint;
	    if (isNear(delta.translate))
	        delta.translate = 0;
	}
	/**
	 * Update the BoxDelta with a transform that projects the source into the target.
	 *
	 * The transform `origin` is optional. If not provided, it'll be automatically
	 * calculated based on the relative positions of the two bounding boxes.
	 */
	function updateBoxDelta(delta, source, target, origin) {
	    updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));
	    updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));
	}
	/**
	 * Currently this only accepts numerical origins, measured as 0-1, but could
	 * accept pixel values by comparing to the target axis.
	 */
	function defaultOrigin(origin) {
	    return typeof origin === "number" ? origin : 0.5;
	}
	function calcRelativeAxis(target, relative, parent) {
	    target.min = parent.min + relative.min;
	    target.max = target.min + calcLength(relative);
	}
	function calcRelativeBox(projection, parentProjection) {
	    calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);
	    calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	var isMotionValue = function (value) {
	    return value !== null && typeof value === "object" && value.getVelocity;
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var createProjectionState = function () { return ({
	    isEnabled: false,
	    isTargetLocked: false,
	    target: axisBox(),
	    targetFinal: axisBox(),
	}); };
	function createLayoutState() {
	    return {
	        isHydrated: false,
	        layout: axisBox(),
	        layoutCorrected: axisBox(),
	        treeScale: { x: 1, y: 1 },
	        delta: delta(),
	        deltaFinal: delta(),
	        deltaTransform: "",
	    };
	}
	var zeroLayout = createLayoutState();

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * Build a transform style that takes a calculated delta between the element's current
	 * space on screen and projects it into the desired space.
	 */
	function buildLayoutProjectionTransform(_a, treeScale, latestTransform) {
	    var x = _a.x, y = _a.y;
	    /**
	     * The translations we use to calculate are always relative to the viewport coordinate space.
	     * But when we apply scales, we also scale the coordinate space of an element and its children.
	     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need
	     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.
	     */
	    var xTranslate = x.translate / treeScale.x;
	    var yTranslate = y.translate / treeScale.y;
	    var transform = "translate3d(" + xTranslate + "px, " + yTranslate + "px, 0) ";
	    if (latestTransform) {
	        var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;
	        if (rotate)
	            transform += "rotate(" + rotate + ") ";
	        if (rotateX)
	            transform += "rotateX(" + rotateX + ") ";
	        if (rotateY)
	            transform += "rotateY(" + rotateY + ") ";
	    }
	    transform += "scale(" + x.scale + ", " + y.scale + ")";
	    return !latestTransform && transform === identityProjection ? "" : transform;
	}
	/**
	 * Take the calculated delta origin and apply it as a transform string.
	 */
	function buildLayoutProjectionTransformOrigin(_a) {
	    var deltaFinal = _a.deltaFinal;
	    return deltaFinal.x.origin * 100 + "% " + deltaFinal.y.origin * 100 + "% 0";
	}
	var identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var isAnimationControls = function (v) {
	    return typeof v === "object" && typeof (v).start === "function"
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	function shallowCompare(next, prev) {
	    if (!Array.isArray(prev))
	        return false;
	    var prevLength = prev.length;
	    if (prevLength !== next.length)
	        return false;
	    for (var i = 0; i < prevLength; i++) {
	        if (prev[i] !== next[i])
	            return false;
	    }
	    return true;
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	var AnimationType;
	(function (AnimationType) {
	    AnimationType["Animate"] = "animate";
	    AnimationType["Hover"] = "whileHover";
	    AnimationType["Tap"] = "whileTap";
	    AnimationType["Drag"] = "whileDrag";
	    AnimationType["Focus"] = "whileFocus";
	    AnimationType["Exit"] = "exit";
	})(AnimationType || (AnimationType = {}));

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var variantPriorityOrder = [
	    AnimationType.Animate,
	    AnimationType.Hover,
	    AnimationType.Tap,
	    AnimationType.Drag,
	    AnimationType.Focus,
	    AnimationType.Exit,
	];
	var reversePriorityOrder = __spreadArray([], __read(variantPriorityOrder)).reverse();
	var numAnimationTypes = variantPriorityOrder.length;
	function animateList(visualElement) {
	    return function (animations) {
	        return Promise.all(animations.map(function (_a) {
	            var animation = _a.animation, options = _a.options;
	            return animateVisualElement(visualElement, animation, options);
	        }));
	    };
	}
	function createAnimationState(visualElement) {
	    var animate = animateList(visualElement);
	    var state = createState();
	    var allAnimatedKeys = {};
	    var isInitialRender = true;
	    /**
	     * This function will be used to reduce the animation definitions for
	     * each active animation type into an object of resolved values for it.
	     */
	    var buildResolvedTypeValues = function (acc, definition) {
	        var resolved = resolveVariant(visualElement, definition);
	        if (resolved) {
	            resolved.transition; var transitionEnd = resolved.transitionEnd, target = __rest(resolved, ["transition", "transitionEnd"]);
	            acc = __assign(__assign(__assign({}, acc), target), transitionEnd);
	        }
	        return acc;
	    };
	    function isAnimated(key) {
	        return allAnimatedKeys[key] !== undefined;
	    }
	    /**
	     * This just allows us to inject mocked animation functions
	     * @internal
	     */
	    function setAnimateFunction(makeAnimator) {
	        animate = makeAnimator(visualElement);
	    }
	    /**
	     * When we receive new props, we need to:
	     * 1. Create a list of protected keys for each type. This is a directory of
	     *    value keys that are currently being "handled" by types of a higher priority
	     *    so that whenever an animation is played of a given type, these values are
	     *    protected from being animated.
	     * 2. Determine if an animation type needs animating.
	     * 3. Determine if any values have been removed from a type and figure out
	     *    what to animate those to.
	     */
	    function animateChanges(options, changedActiveType) {
	        var _a;
	        var props = visualElement.getProps();
	        var context = visualElement.getVariantContext(true) || {};
	        /**
	         * A list of animations that we'll build into as we iterate through the animation
	         * types. This will get executed at the end of the function.
	         */
	        var animations = [];
	        /**
	         * Keep track of which values have been removed. Then, as we hit lower priority
	         * animation types, we can check if they contain removed values and animate to that.
	         */
	        var removedKeys = new Set();
	        /**
	         * A dictionary of all encountered keys. This is an object to let us build into and
	         * copy it without iteration. Each time we hit an animation type we set its protected
	         * keys - the keys its not allowed to animate - to the latest version of this object.
	         */
	        var encounteredKeys = {};
	        /**
	         * If a variant has been removed at a given index, and this component is controlling
	         * variant animations, we want to ensure lower-priority variants are forced to animate.
	         */
	        var removedVariantIndex = Infinity;
	        var _loop_1 = function (i) {
	            var type = reversePriorityOrder[i];
	            var typeState = state[type];
	            var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];
	            var propIsVariant = isVariantLabel(prop);
	            /**
	             * If this type has *just* changed isActive status, set activeDelta
	             * to that status. Otherwise set to null.
	             */
	            var activeDelta = type === changedActiveType ? typeState.isActive : null;
	            if (activeDelta === false)
	                removedVariantIndex = i;
	            /**
	             * If this prop is an inherited variant, rather than been set directly on the
	             * component itself, we want to make sure we allow the parent to trigger animations.
	             *
	             * TODO: Can probably change this to a !isControllingVariants check
	             */
	            var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
	            /**
	             *
	             */
	            if (isInherited &&
	                isInitialRender &&
	                visualElement.manuallyAnimateOnMount) {
	                isInherited = false;
	            }
	            /**
	             * Set all encountered keys so far as the protected keys for this type. This will
	             * be any key that has been animated or otherwise handled by active, higher-priortiy types.
	             */
	            typeState.protectedKeys = __assign({}, encounteredKeys);
	            // Check if we can skip analysing this prop early
	            if (
	            // If it isn't active and hasn't *just* been set as inactive
	            (!typeState.isActive && activeDelta === null) ||
	                // If we didn't and don't have any defined prop for this animation type
	                (!prop && !typeState.prevProp) ||
	                // Or if the prop doesn't define an animation
	                isAnimationControls(prop) ||
	                typeof prop === "boolean") {
	                return "continue";
	            }
	            /**
	             * As we go look through the values defined on this type, if we detect
	             * a changed value or a value that was removed in a higher priority, we set
	             * this to true and add this prop to the animation list.
	             */
	            var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) ||
	                // If we're making this variant active, we want to always make it active
	                (type === changedActiveType &&
	                    typeState.isActive &&
	                    !isInherited &&
	                    propIsVariant) ||
	                // If we removed a higher-priority variant (i is in reverse order)
	                (i > removedVariantIndex && propIsVariant);
	            /**
	             * As animations can be set as variant lists, variants or target objects, we
	             * coerce everything to an array if it isn't one already
	             */
	            var definitionList = Array.isArray(prop) ? prop : [prop];
	            /**
	             * Build an object of all the resolved values. We'll use this in the subsequent
	             * animateChanges calls to determine whether a value has changed.
	             */
	            var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
	            if (activeDelta === false)
	                resolvedValues = {};
	            /**
	             * Now we need to loop through all the keys in the prev prop and this prop,
	             * and decide:
	             * 1. If the value has changed, and needs animating
	             * 2. If it has been removed, and needs adding to the removedKeys set
	             * 3. If it has been removed in a higher priority type and needs animating
	             * 4. If it hasn't been removed in a higher priority but hasn't changed, and
	             *    needs adding to the type's protectedKeys list.
	             */
	            var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;
	            var allKeys = __assign(__assign({}, prevResolvedValues), resolvedValues);
	            var markToAnimate = function (key) {
	                shouldAnimateType = true;
	                removedKeys.delete(key);
	                typeState.needsAnimating[key] = true;
	            };
	            for (var key in allKeys) {
	                var next = resolvedValues[key];
	                var prev = prevResolvedValues[key];
	                // If we've already handled this we can just skip ahead
	                if (encounteredKeys.hasOwnProperty(key))
	                    continue;
	                /**
	                 * If the value has changed, we probably want to animate it.
	                 */
	                if (next !== prev) {
	                    /**
	                     * If both values are keyframes, we need to shallow compare them to
	                     * detect whether any value has changed. If it has, we animate it.
	                     */
	                    if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
	                        if (!shallowCompare(next, prev)) {
	                            markToAnimate(key);
	                        }
	                        else {
	                            /**
	                             * If it hasn't changed, we want to ensure it doesn't animate by
	                             * adding it to the list of protected keys.
	                             */
	                            typeState.protectedKeys[key] = true;
	                        }
	                    }
	                    else if (next !== undefined) {
	                        // If next is defined and doesn't equal prev, it needs animating
	                        markToAnimate(key);
	                    }
	                    else {
	                        // If it's undefined, it's been removed.
	                        removedKeys.add(key);
	                    }
	                }
	                else if (next !== undefined && removedKeys.has(key)) {
	                    /**
	                     * If next hasn't changed and it isn't undefined, we want to check if it's
	                     * been removed by a higher priority
	                     */
	                    markToAnimate(key);
	                }
	                else {
	                    /**
	                     * If it hasn't changed, we add it to the list of protected values
	                     * to ensure it doesn't get animated.
	                     */
	                    typeState.protectedKeys[key] = true;
	                }
	            }
	            /**
	             * Update the typeState so next time animateChanges is called we can compare the
	             * latest prop and resolvedValues to these.
	             */
	            typeState.prevProp = prop;
	            typeState.prevResolvedValues = resolvedValues;
	            /**
	             *
	             */
	            if (typeState.isActive) {
	                encounteredKeys = __assign(__assign({}, encounteredKeys), resolvedValues);
	            }
	            if (isInitialRender && visualElement.blockInitialAnimation) {
	                shouldAnimateType = false;
	            }
	            /**
	             * If this is an inherited prop we want to hard-block animations
	             * TODO: Test as this should probably still handle animations triggered
	             * by removed values?
	             */
	            if (shouldAnimateType && !isInherited) {
	                animations.push.apply(animations, __spreadArray([], __read(definitionList.map(function (animation) { return ({
	                    animation: animation,
	                    options: __assign({ type: type }, options),
	                }); }))));
	            }
	        };
	        /**
	         * Iterate through all animation types in reverse priority order. For each, we want to
	         * detect which values it's handling and whether or not they've changed (and therefore
	         * need to be animated). If any values have been removed, we want to detect those in
	         * lower priority props and flag for animation.
	         */
	        for (var i = 0; i < numAnimationTypes; i++) {
	            _loop_1(i);
	        }
	        allAnimatedKeys = __assign({}, encounteredKeys);
	        /**
	         * If there are some removed value that haven't been dealt with,
	         * we need to create a new animation that falls back either to the value
	         * defined in the style prop, or the last read value.
	         */
	        if (removedKeys.size) {
	            var fallbackAnimation_1 = {};
	            removedKeys.forEach(function (key) {
	                var fallbackTarget = visualElement.getBaseTarget(key);
	                if (fallbackTarget !== undefined) {
	                    fallbackAnimation_1[key] = fallbackTarget;
	                }
	            });
	            animations.push({ animation: fallbackAnimation_1 });
	        }
	        var shouldAnimate = Boolean(animations.length);
	        if (isInitialRender &&
	            props.initial === false &&
	            !visualElement.manuallyAnimateOnMount) {
	            shouldAnimate = false;
	        }
	        isInitialRender = false;
	        return shouldAnimate ? animate(animations) : Promise.resolve();
	    }
	    /**
	     * Change whether a certain animation type is active.
	     */
	    function setActive(type, isActive, options) {
	        var _a;
	        // If the active state hasn't changed, we can safely do nothing here
	        if (state[type].isActive === isActive)
	            return Promise.resolve();
	        // Propagate active change to children
	        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });
	        state[type].isActive = isActive;
	        return animateChanges(options, type);
	    }
	    return {
	        isAnimated: isAnimated,
	        animateChanges: animateChanges,
	        setActive: setActive,
	        setAnimateFunction: setAnimateFunction,
	        getState: function () { return state; },
	    };
	}
	function variantsHaveChanged(prev, next) {
	    if (typeof next === "string") {
	        return next !== prev;
	    }
	    else if (isVariantLabels(next)) {
	        return !shallowCompare(next, prev);
	    }
	    return false;
	}
	function createTypeState(isActive) {
	    if (isActive === void 0) { isActive = false; }
	    return {
	        isActive: isActive,
	        protectedKeys: {},
	        needsAnimating: {},
	        prevResolvedValues: {},
	    };
	}
	function createState() {
	    var _a;
	    return _a = {},
	        _a[AnimationType.Animate] = createTypeState(true),
	        _a[AnimationType.Hover] = createTypeState(),
	        _a[AnimationType.Tap] = createTypeState(),
	        _a[AnimationType.Drag] = createTypeState(),
	        _a[AnimationType.Focus] = createTypeState(),
	        _a[AnimationType.Exit] = createTypeState(),
	        _a;
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var names = [
	    "LayoutMeasure",
	    "BeforeLayoutMeasure",
	    "LayoutUpdate",
	    "ViewportBoxUpdate",
	    "Update",
	    "Render",
	    "AnimationComplete",
	    "LayoutAnimationComplete",
	    "AnimationStart",
	    "SetAxisTarget",
	    "Unmount",
	];
	function createLifecycles() {
	    var managers = names.map(function () { return new SubscriptionManager(); });
	    var propSubscriptions = {};
	    var lifecycles = {
	        clearAllListeners: function () { return managers.forEach(function (manager) { return manager.clear(); }); },
	        updatePropListeners: function (props) {
	            return names.forEach(function (name) {
	                var _a;
	                (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);
	                var on = "on" + name;
	                var propListener = props[on];
	                if (propListener) {
	                    propSubscriptions[name] = lifecycles[on](propListener);
	                }
	            });
	        },
	    };
	    managers.forEach(function (manager, i) {
	        lifecycles["on" + names[i]] = function (handler) { return manager.add(handler); };
	        lifecycles["notify" + names[i]] = function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            return manager.notify.apply(manager, __spreadArray([], __read(args)));
	        };
	    });
	    return lifecycles;
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	function updateMotionValuesFromProps(element, next, prev) {
	    var _a;
	    for (var key in next) {
	        var nextValue = next[key];
	        var prevValue = prev[key];
	        if (isMotionValue(nextValue)) {
	            /**
	             * If this is a motion value found in props or style, we want to add it
	             * to our visual element's motion value map.
	             */
	            element.addValue(key, nextValue);
	        }
	        else if (isMotionValue(prevValue)) {
	            /**
	             * If we're swapping to a new motion value, create a new motion value
	             * from that
	             */
	            element.addValue(key, motionValue(nextValue));
	        }
	        else if (prevValue !== nextValue) {
	            /**
	             * If this is a flat value that has changed, update the motion value
	             * or create one if it doesn't exist. We only want to do this if we're
	             * not handling the value with our animation state.
	             */
	            if (element.hasValue(key)) {
	                var existingValue = element.getValue(key);
	                // TODO: Only update values that aren't being animated or even looked at
	                !existingValue.hasAnimated && existingValue.set(nextValue);
	            }
	            else {
	                element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));
	            }
	        }
	    }
	    // Handle removed values
	    for (var key in prev) {
	        if (next[key] === undefined)
	            element.removeValue(key);
	    }
	    return next;
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	function updateLayoutDeltas(_a, _b, treePath, transformOrigin) {
	    var delta = _a.delta, layout = _a.layout, layoutCorrected = _a.layoutCorrected, treeScale = _a.treeScale;
	    var target = _b.target;
	    /**
	     * Reset the corrected box with the latest values from box, as we're then going
	     * to perform mutative operations on it.
	     */
	    resetBox(layoutCorrected, layout);
	    /**
	     * Apply all the parent deltas to this box to produce the corrected box. This
	     * is the layout box, as it will appear on screen as a result of the transforms of its parents.
	     */
	    applyTreeDeltas(layoutCorrected, treeScale, treePath);
	    /**
	     * Update the delta between the corrected box and the target box before user-set transforms were applied.
	     * This will allow us to calculate the corrected borderRadius and boxShadow to compensate
	     * for our layout reprojection, but still allow them to be scaled correctly by the user.
	     * It might be that to simplify this we may want to accept that user-set scale1 is also corrected
	     * and we wouldn't have to keep and calc both deltas, OR we could support a user setting
	     * to allow people to choose whether these styles are corrected based on just the
	     * layout reprojection or the final bounding box.
	     */
	    updateBoxDelta(delta, layoutCorrected, target, transformOrigin);
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	var compareByDepth = function (a, b) {
	    return a.depth - b.depth;
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var FlatTree = /** @class */ (function () {
	    function FlatTree() {
	        this.children = [];
	        this.isDirty = false;
	    }
	    FlatTree.prototype.add = function (child) {
	        addUniqueItem(this.children, child);
	        this.isDirty = true;
	    };
	    FlatTree.prototype.remove = function (child) {
	        removeItem(this.children, child);
	        this.isDirty = true;
	    };
	    FlatTree.prototype.forEach = function (callback) {
	        this.isDirty && this.children.sort(compareByDepth);
	        var numChildren = this.children.length;
	        for (var i = 0; i < numChildren; i++) {
	            callback(this.children[i]);
	        }
	    };
	    return FlatTree;
	}());

	/** 
	based on framer-motion@4.1.11,
	Copyright (c) 2018 Framer B.V.
	*/

	function tweenAxis(target, prev, next, p) {
	    target.min = mix$1(prev.min, next.min, p);
	    target.max = mix$1(prev.max, next.max, p);
	}
	function calcRelativeOffsetAxis(parent, child) {
	    return {
	        min: child.min - parent.min,
	        max: child.max - parent.min,
	    };
	}
	function calcRelativeOffset(parent, child) {
	    return {
	        x: calcRelativeOffsetAxis(parent.x, child.x),
	        y: calcRelativeOffsetAxis(parent.y, child.y),
	    };
	}

	/** 
	based on framer-motion@4.1.11,
	Copyright (c) 2018 Framer B.V.
	*/

	function setCurrentViewportBox(visualElement) {
	    var projectionParent = visualElement.getProjectionParent();
	    if (!projectionParent) {
	        visualElement.rebaseProjectionTarget();
	        return;
	    }
	    var relativeOffset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);
	    eachAxis(function (axis) {
	        visualElement.setProjectionTargetAxis(axis, relativeOffset[axis].min, relativeOffset[axis].max, true);
	    });
	}

	/** 
	based on framer-motion@4.1.1,
	Copyright (c) 2018 Framer B.V.
	*/

	var visualElement = function (_a) {
	    var _b = _a.treeType, treeType = _b === void 0 ? "" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, resetTransform = _a.resetTransform, restoreTransform = _a.restoreTransform, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;
	    return function (_a, options) {
	        var parent = _a.parent, props = _a.props, presenceId = _a.presenceId, blockInitialAnimation = _a.blockInitialAnimation, visualState = _a.visualState;
	        if (options === void 0) { options = {}; }
	        var latestValues = visualState.latestValues, renderState = visualState.renderState;
	        /**
	         * The instance of the render-specific node that will be hydrated by the
	         * exposed React ref. So for example, this visual element can host a
	         * HTMLElement, plain object, or Three.js object. The functions provided
	         * in VisualElementConfig allow us to interface with this instance.
	         */
	        var instance;
	        /**
	         * Manages the subscriptions for a visual element's lifecycle, for instance
	         * onRender and onViewportBoxUpdate.
	         */
	        var lifecycles = createLifecycles();
	        /**
	         *
	         */
	        var projection = createProjectionState();
	        /**
	         * A reference to the nearest projecting parent. This is either
	         * undefined if we haven't looked for the nearest projecting parent,
	         * false if there is no parent performing layout projection, or a reference
	         * to the projecting parent.
	         */
	        var projectionParent;
	        /**
	         * This is a reference to the visual state of the "lead" visual element.
	         * Usually, this will be this visual element. But if it shares a layoutId
	         * with other visual elements, only one of them will be designated lead by
	         * AnimateSharedLayout. All the other visual elements will take on the visual
	         * appearance of the lead while they crossfade to it.
	         */
	        var leadProjection = projection;
	        var leadLatestValues = latestValues;
	        var unsubscribeFromLeadVisualElement;
	        /**
	         * The latest layout measurements and calculated projections. This
	         * is seperate from the target projection data in visualState as
	         * many visual elements might point to the same piece of visualState as
	         * a target, whereas they might each have different layouts and thus
	         * projection calculations needed to project into the same viewport box.
	         */
	        var layoutState = createLayoutState();
	        /**
	         *
	         */
	        var crossfader;
	        /**
	         * Keep track of whether the viewport box has been updated since the
	         * last time the layout projection was re-calculated.
	         */
	        var hasViewportBoxUpdated = false;
	        /**
	         * A map of all motion values attached to this visual element. Motion
	         * values are source of truth for any given animated value. A motion
	         * value might be provided externally by the component via props.
	         */
	        var values = new Map();
	        /**
	         * A map of every subscription that binds the provided or generated
	         * motion values onChange listeners to this visual element.
	         */
	        var valueSubscriptions = new Map();
	        /**
	         * A reference to the previously-provided motion values as returned
	         * from scrapeMotionValuesFromProps. We use the keys in here to determine
	         * if any motion values need to be removed after props are updated.
	         */
	        var prevMotionValues = {};
	        /**
	         * x/y motion values that track the progress of initiated layout
	         * animations.
	         *
	         * TODO: Target for removal
	         */
	        var projectionTargetProgress;
	        /**
	         * When values are removed from all animation props we need to search
	         * for a fallback value to animate to. These values are tracked in baseTarget.
	         */
	        var baseTarget = __assign({}, latestValues);
	        // Internal methods ========================
	        /**
	         * On mount, this will be hydrated with a callback to disconnect
	         * this visual element from its parent on unmount.
	         */
	        var removeFromVariantTree;
	        /**
	         *
	         */
	        function render() {
	            if (!instance)
	                return;
	            if (element.isProjectionReady()) {
	                /**
	                 * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.
	                 * This is the final box that we will then project into by calculating a transform delta and
	                 * applying it to the corrected box.
	                 */
	                applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);
	                /**
	                 * Update the delta between the corrected box and the final target box, after
	                 * user-set transforms are applied to it. This will be used by the renderer to
	                 * create a transform style that will reproject the element from its actual layout
	                 * into the desired bounding box.
	                 */
	                updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);
	            }
	            triggerBuild();
	            renderInstance(instance, renderState);
	        }
	        function triggerBuild() {
	            var valuesToRender = latestValues;
	            if (crossfader && crossfader.isActive()) {
	                var crossfadedValues = crossfader.getCrossfadeState(element);
	                if (crossfadedValues)
	                    valuesToRender = crossfadedValues;
	            }
	            build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);
	        }
	        function update() {
	            lifecycles.notifyUpdate(latestValues);
	        }
	        function updateLayoutProjection() {
	            if (!element.isProjectionReady())
	                return;
	            var delta = layoutState.delta, treeScale = layoutState.treeScale;
	            var prevTreeScaleX = treeScale.x;
	            var prevTreeScaleY = treeScale.y;
	            var prevDeltaTransform = layoutState.deltaTransform;
	            updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);
	            hasViewportBoxUpdated &&
	                element.notifyViewportBoxUpdate(leadProjection.target, delta);
	            hasViewportBoxUpdated = false;
	            var deltaTransform = buildLayoutProjectionTransform(delta, treeScale);
	            if (deltaTransform !== prevDeltaTransform ||
	                // Also compare calculated treeScale, for values that rely on this only for scale correction
	                prevTreeScaleX !== treeScale.x ||
	                prevTreeScaleY !== treeScale.y) {
	                element.scheduleRender();
	            }
	            layoutState.deltaTransform = deltaTransform;
	        }
	        function updateTreeLayoutProjection() {
	            element.layoutTree.forEach(fireUpdateLayoutProjection);
	        }
	        /**
	         *
	         */
	        function bindToMotionValue(key, value) {
	            var removeOnChange = value.onChange(function (latestValue) {
	                latestValues[key] = latestValue;
	                props.onUpdate && sync.update(update, false, true);
	            });
	            var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);
	            valueSubscriptions.set(key, function () {
	                removeOnChange();
	                removeOnRenderRequest();
	            });
	        }
	        /**
	         * Any motion values that are provided to the element when created
	         * aren't yet bound to the element, as this would technically be impure.
	         * However, we iterate through the motion values and set them to the
	         * initial values for this component.
	         *
	         * TODO: This is impure and we should look at changing this to run on mount.
	         * Doing so will break some tests but this isn't neccessarily a breaking change,
	         * more a reflection of the test.
	         */
	        var initialMotionValues = scrapeMotionValuesFromProps(props);
	        for (var key in initialMotionValues) {
	            var value = initialMotionValues[key];
	            if (latestValues[key] !== undefined && isMotionValue(value)) {
	                value.set(latestValues[key], false);
	            }
	        }
	        /**
	         * Determine what role this visual element should take in the variant tree.
	         */
	        var isControllingVariants = checkIfControllingVariants(props);
	        var isVariantNode = checkIfVariantNode(props);
	        var element = __assign(__assign({ treeType: treeType, 
	            /**
	             * This is a mirror of the internal instance prop, which keeps
	             * VisualElement type-compatible with React's RefObject.
	             */
	            current: null, 
	            /**
	             * The depth of this visual element within the visual element tree.
	             */
	            depth: parent ? parent.depth + 1 : 0, parent: parent, children: new Set(), 
	            /**
	             * An ancestor path back to the root visual element. This is used
	             * by layout projection to quickly recurse back up the tree.
	             */
	            path: parent ? __spreadArray(__spreadArray([], __read(parent.path)), [parent]) : [], layoutTree: parent ? parent.layoutTree : new FlatTree(), 
	            /**
	             *
	             */
	            presenceId: presenceId,
	            projection: projection, 
	            /**
	             * If this component is part of the variant tree, it should track
	             * any children that are also part of the tree. This is essentially
	             * a shadow tree to simplify logic around how to stagger over children.
	             */
	            variantChildren: isVariantNode ? new Set() : undefined, 
	            /**
	             * Whether this instance is visible. This can be changed imperatively
	             * by AnimateSharedLayout, is analogous to CSS's visibility in that
	             * hidden elements should take up layout, and needs enacting by the configured
	             * render function.
	             */
	            isVisible: undefined, 
	            /**
	             * Normally, if a component is controlled by a parent's variants, it can
	             * rely on that ancestor to trigger animations further down the tree.
	             * However, if a component is created after its parent is mounted, the parent
	             * won't trigger that mount animation so the child needs to.
	             *
	             * TODO: This might be better replaced with a method isParentMounted
	             */
	            manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()), 
	            /**
	             * This can be set by AnimatePresence to force components that mount
	             * at the same time as it to mount as if they have initial={false} set.
	             */
	            blockInitialAnimation: blockInitialAnimation, 
	            /**
	             * Determine whether this component has mounted yet. This is mostly used
	             * by variant children to determine whether they need to trigger their
	             * own animations on mount.
	             */
	            isMounted: function () { return Boolean(instance); }, mount: function (newInstance) {
	                instance = element.current = newInstance;
	                element.pointTo(element);
	                if (isVariantNode && parent && !isControllingVariants) {
	                    removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);
	                }
	                parent === null || parent === void 0 ? void 0 : parent.children.add(element);
	            },
	            /**
	             *
	             */
	            unmount: function () {
	                cancelSync.update(update);
	                cancelSync.render(render);
	                cancelSync.preRender(element.updateLayoutProjection);
	                valueSubscriptions.forEach(function (remove) { return remove(); });
	                element.stopLayoutAnimation();
	                element.layoutTree.remove(element);
	                removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();
	                parent === null || parent === void 0 ? void 0 : parent.children.delete(element);
	                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();
	                lifecycles.clearAllListeners();
	            },
	            /**
	             * Add a child visual element to our set of children.
	             */
	            addVariantChild: function (child) {
	                var _a;
	                var closestVariantNode = element.getClosestVariantNode();
	                if (closestVariantNode) {
	                    (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);
	                    return function () { return closestVariantNode.variantChildren.delete(child); };
	                }
	            },
	            sortNodePosition: function (other) {
	                /**
	                 * If these nodes aren't even of the same type we can't compare their depth.
	                 */
	                if (!sortNodePosition || treeType !== other.treeType)
	                    return 0;
	                return sortNodePosition(element.getInstance(), other.getInstance());
	            }, 
	            /**
	             * Returns the closest variant node in the tree starting from
	             * this visual element.
	             */
	            getClosestVariantNode: function () {
	                return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();
	            }, 
	            /**
	             * A method that schedules an update to layout projections throughout
	             * the tree. We inherit from the parent so there's only ever one
	             * job scheduled on the next frame - that of the root visual element.
	             */
	            scheduleUpdateLayoutProjection: parent
	                ? parent.scheduleUpdateLayoutProjection
	                : function () {
	                    return sync.preRender(element.updateTreeLayoutProjection, false, true);
	                }, 
	            /**
	             * Expose the latest layoutId prop.
	             */
	            getLayoutId: function () { return props.layoutId; }, 
	            /**
	             * Returns the current instance.
	             */
	            getInstance: function () { return instance; }, 
	            /**
	             * Get/set the latest static values.
	             */
	            getStaticValue: function (key) { return latestValues[key]; }, setStaticValue: function (key, value) { return (latestValues[key] = value); }, 
	            /**
	             * Returns the latest motion value state. Currently only used to take
	             * a snapshot of the visual element - perhaps this can return the whole
	             * visual state
	             */
	            getLatestValues: function () { return latestValues; }, 
	            /**
	             * Set the visiblity of the visual element. If it's changed, schedule
	             * a render to reflect these changes.
	             */
	            setVisibility: function (visibility) {
	                if (element.isVisible === visibility)
	                    return;
	                element.isVisible = visibility;
	                element.scheduleRender();
	            },
	            /**
	             * Make a target animatable by Popmotion. For instance, if we're
	             * trying to animate width from 100px to 100vw we need to measure 100vw
	             * in pixels to determine what we really need to animate to. This is also
	             * pluggable to support Framer's custom value types like Color,
	             * and CSS variables.
	             */
	            makeTargetAnimatable: function (target, canMutate) {
	                if (canMutate === void 0) { canMutate = true; }
	                return makeTargetAnimatable(element, target, props, canMutate);
	            },
	            // Motion values ========================
	            /**
	             * Add a motion value and bind it to this visual element.
	             */
	            addValue: function (key, value) {
	                // Remove existing value if it exists
	                if (element.hasValue(key))
	                    element.removeValue(key);
	                values.set(key, value);
	                latestValues[key] = value.get();
	                bindToMotionValue(key, value);
	            },
	            /**
	             * Remove a motion value and unbind any active subscriptions.
	             */
	            removeValue: function (key) {
	                var _a;
	                values.delete(key);
	                (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();
	                valueSubscriptions.delete(key);
	                delete latestValues[key];
	                removeValueFromRenderState(key, renderState);
	            }, 
	            /**
	             * Check whether we have a motion value for this key
	             */
	            hasValue: function (key) { return values.has(key); }, 
	            /**
	             * Get a motion value for this key. If called with a default
	             * value, we'll create one if none exists.
	             */
	            getValue: function (key, defaultValue) {
	                var value = values.get(key);
	                if (value === undefined && defaultValue !== undefined) {
	                    value = motionValue(defaultValue);
	                    element.addValue(key, value);
	                }
	                return value;
	            }, 
	            /**
	             * Iterate over our motion values.
	             */
	            forEachValue: function (callback) { return values.forEach(callback); }, 
	            /**
	             * If we're trying to animate to a previously unencountered value,
	             * we need to check for it in our state and as a last resort read it
	             * directly from the instance (which might have performance implications).
	             */
	            readValue: function (key) { var _a; return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options); }, 
	            /**
	             * Set the base target to later animate back to. This is currently
	             * only hydrated on creation and when we first read a value.
	             */
	            setBaseTarget: function (key, value) {
	                baseTarget[key] = value;
	            },
	            /**
	             * Find the base target for a value thats been removed from all animation
	             * props.
	             */
	            getBaseTarget: function (key) {
	                if (getBaseTarget) {
	                    var target = getBaseTarget(props, key);
	                    if (target !== undefined && !isMotionValue(target))
	                        return target;
	                }
	                return baseTarget[key];
	            } }, lifecycles), { 
	            /**
	             * Build the renderer state based on the latest visual state.
	             */
	            build: function () {
	                triggerBuild();
	                return renderState;
	            },
	            /**
	             * Schedule a render on the next animation frame.
	             */
	            scheduleRender: function () {
	                sync.render(render, false, true);
	            }, 
	            /**
	             * Synchronously fire render. It's prefered that we batch renders but
	             * in many circumstances, like layout measurement, we need to run this
	             * synchronously. However in those instances other measures should be taken
	             * to batch reads/writes.
	             */
	            syncRender: render, 
	            /**
	             * Update the provided props. Ensure any newly-added motion values are
	             * added to our map, old ones removed, and listeners updated.
	             */
	            setProps: function (newProps) {
	                props = newProps;
	                lifecycles.updatePropListeners(newProps);
	                prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);
	            }, getProps: function () { return props; }, 
	            // Variants ==============================
	            /**
	             * Returns the variant definition with a given name.
	             */
	            getVariant: function (name) { var _a; return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name]; }, 
	            /**
	             * Returns the defined default transition on this component.
	             */
	            getDefaultTransition: function () { return props.transition; }, 
	            /**
	             * Used by child variant nodes to get the closest ancestor variant props.
	             */
	            getVariantContext: function (startAtParent) {
	                if (startAtParent === void 0) { startAtParent = false; }
	                if (startAtParent)
	                    return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();
	                if (!isControllingVariants) {
	                    var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};
	                    if (props.initial !== undefined) {
	                        context_1.initial = props.initial;
	                    }
	                    return context_1;
	                }
	                var context = {};
	                for (var i = 0; i < numVariantProps; i++) {
	                    var name_1 = variantProps[i];
	                    var prop = props[name_1];
	                    if (isVariantLabel(prop) || prop === false) {
	                        context[name_1] = prop;
	                    }
	                }
	                return context;
	            },
	            // Layout projection ==============================
	            /**
	             * Enable layout projection for this visual element. Won't actually
	             * occur until we also have hydrated layout measurements.
	             */
	            enableLayoutProjection: function () {
	                projection.isEnabled = true;
	                element.layoutTree.add(element);
	            },
	            /**
	             * Lock the projection target, for instance when dragging, so
	             * nothing else can try and animate it.
	             */
	            lockProjectionTarget: function () {
	                projection.isTargetLocked = true;
	            },
	            unlockProjectionTarget: function () {
	                element.stopLayoutAnimation();
	                projection.isTargetLocked = false;
	            }, getLayoutState: function () { return layoutState; }, setCrossfader: function (newCrossfader) {
	                crossfader = newCrossfader;
	            }, isProjectionReady: function () {
	                return projection.isEnabled &&
	                    projection.isHydrated &&
	                    layoutState.isHydrated;
	            }, 
	            /**
	             * Start a layout animation on a given axis.
	             */
	            startLayoutAnimation: function (axis, transition, isRelative) {
	                if (isRelative === void 0) { isRelative = false; }
	                var progress = element.getProjectionAnimationProgress()[axis];
	                var _a = isRelative
	                    ? projection.relativeTarget[axis]
	                    : projection.target[axis], min = _a.min, max = _a.max;
	                var length = max - min;
	                progress.clearListeners();
	                progress.set(min);
	                progress.set(min); // Set twice to hard-reset velocity
	                progress.onChange(function (v) {
	                    element.setProjectionTargetAxis(axis, v, v + length, isRelative);
	                });
	                return element.animateMotionValue(axis, progress, 0, transition);
	            },
	            /**
	             * Stop layout animations.
	             */
	            stopLayoutAnimation: function () {
	                eachAxis(function (axis) {
	                    return element.getProjectionAnimationProgress()[axis].stop();
	                });
	            },
	            /**
	             * Measure the current viewport box with or without transforms.
	             * Only measures axis-aligned boxes, rotate and skew must be manually
	             * removed with a re-render to work.
	             */
	            measureViewportBox: function (withTransform) {
	                if (withTransform === void 0) { withTransform = true; }
	                var viewportBox = measureViewportBox(instance, options);
	                if (!withTransform)
	                    removeBoxTransforms(viewportBox, latestValues);
	                return viewportBox;
	            },
	            /**
	             * Get the motion values tracking the layout animations on each
	             * axis. Lazy init if not already created.
	             */
	            getProjectionAnimationProgress: function () {
	                projectionTargetProgress || (projectionTargetProgress = {
	                    x: motionValue(0),
	                    y: motionValue(0),
	                });
	                return projectionTargetProgress;
	            },
	            /**
	             * Update the projection of a single axis. Schedule an update to
	             * the tree layout projection.
	             */
	            setProjectionTargetAxis: function (axis, min, max, isRelative) {
	                if (isRelative === void 0) { isRelative = false; }
	                var target;
	                if (isRelative) {
	                    if (!projection.relativeTarget) {
	                        projection.relativeTarget = axisBox();
	                    }
	                    target = projection.relativeTarget[axis];
	                }
	                else {
	                    projection.relativeTarget = undefined;
	                    target = projection.target[axis];
	                }
	                projection.isHydrated = true;
	                target.min = min;
	                target.max = max;
	                // Flag that we want to fire the onViewportBoxUpdate event handler
	                hasViewportBoxUpdated = true;
	                lifecycles.notifySetAxisTarget();
	            },
	            /**
	             * Rebase the projection target on top of the provided viewport box
	             * or the measured layout. This ensures that non-animating elements
	             * don't fall out of sync differences in measurements vs projections
	             * after a page scroll or other relayout.
	             */
	            rebaseProjectionTarget: function (force, box) {
	                if (box === void 0) { box = layoutState.layout; }
	                var _a = element.getProjectionAnimationProgress(), x = _a.x, y = _a.y;
	                var shouldRebase = !projection.relativeTarget &&
	                    !projection.isTargetLocked &&
	                    !x.isAnimating() &&
	                    !y.isAnimating();
	                if (force || shouldRebase) {
	                    eachAxis(function (axis) {
	                        var _a = box[axis], min = _a.min, max = _a.max;
	                        element.setProjectionTargetAxis(axis, min, max);
	                    });
	                }
	            },
	            /**
	             * Notify the visual element that its layout is up-to-date.
	             * Currently Animate.tsx uses this to check whether a layout animation
	             * needs to be performed.
	             */
	            notifyLayoutReady: function (config) {
	                setCurrentViewportBox(element);
	                element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);
	            }, 
	            /**
	             * Temporarily reset the transform of the instance.
	             */
	            resetTransform: function () { return resetTransform(element, instance, props); }, restoreTransform: function () { return restoreTransform(instance, renderState); }, updateLayoutProjection: updateLayoutProjection,
	            updateTreeLayoutProjection: function () {
	                element.layoutTree.forEach(fireResolveRelativeTargetBox);
	                /**
	                 * Schedule the projection updates at the end of the current preRender
	                 * step. This will ensure that all layout trees will first resolve
	                 * relative projection boxes into viewport boxes, and *then*
	                 * update projections.
	                 */
	                sync.preRender(updateTreeLayoutProjection, false, true);
	                // sync.postRender(() => element.scheduleUpdateLayoutProjection())
	            },
	            getProjectionParent: function () {
	                if (projectionParent === undefined) {
	                    var foundParent = false;
	                    // Search backwards through the tree path
	                    for (var i = element.path.length - 1; i >= 0; i--) {
	                        var ancestor = element.path[i];
	                        if (ancestor.projection.isEnabled) {
	                            foundParent = ancestor;
	                            break;
	                        }
	                    }
	                    projectionParent = foundParent;
	                }
	                return projectionParent;
	            },
	            resolveRelativeTargetBox: function () {
	                var relativeParent = element.getProjectionParent();
	                if (!projection.relativeTarget || !relativeParent)
	                    return;
	                calcRelativeBox(projection, relativeParent.projection);
	                if (isDraggable(relativeParent)) {
	                    var target = projection.target;
	                    applyBoxTransforms(target, target, relativeParent.getLatestValues());
	                }
	            },
	            shouldResetTransform: function () {
	                return Boolean(props._layoutResetTransform);
	            },
	            /**
	             *
	             */
	            pointTo: function (newLead) {
	                leadProjection = newLead.projection;
	                leadLatestValues = newLead.getLatestValues();
	                /**
	                 * Subscribe to lead component's layout animations
	                 */
	                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();
	                unsubscribeFromLeadVisualElement = pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function () {
	                    var _a;
	                    if (element.isPresent) {
	                        element.presence = Presence.Present;
	                    }
	                    else {
	                        (_a = element.layoutSafeToRemove) === null || _a === void 0 ? void 0 : _a.call(element);
	                    }
	                }));
	            }, 
	            // TODO: Clean this up
	            isPresent: true, presence: Presence.Entering });
	        return element;
	    };
	};
	function fireResolveRelativeTargetBox(child) {
	    child.resolveRelativeTargetBox();
	}
	function fireUpdateLayoutProjection(child) {
	    child.updateLayoutProjection();
	}
	var variantProps = __spreadArray(["initial"], __read(variantPriorityOrder));
	var numVariantProps = variantProps.length;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	/**
	 * A list of all valid MotionProps.
	 *
	 * @internalremarks
	 * This doesn't throw if a `MotionProp` name is missing - it should.
	 */
	var validMotionProps = new Set([
	    "initial",
	    "animate",
	    "exit",
	    "style",
	    "variants",
	    "transition",
	    "transformTemplate",
	    "transformValues",
	    "custom",
	    "inherit",
	    "layout",
	    "layoutId",
	    "onLayoutAnimationComplete",
	    "onViewportBoxUpdate",
	    "onLayoutMeasure",
	    "onBeforeLayoutMeasure",
	    "onAnimationStart",
	    "onAnimationComplete",
	    "onUpdate",
	    "onDragStart",
	    "onDrag",
	    "onDragEnd",
	    "onMeasureDragConstraints",
	    "onDirectionLock",
	    "onDragTransitionEnd",
	    "drag",
	    "dragControls",
	    "dragListener",
	    "dragConstraints",
	    "dragDirectionLock",
	    "_dragX",
	    "_dragY",
	    "dragElastic",
	    "dragMomentum",
	    "dragPropagation",
	    "dragTransition",
	    "whileDrag",
	    "onPan",
	    "onPanStart",
	    "onPanEnd",
	    "onPanSessionStart",
	    "onTap",
	    "onTapStart",
	    "onTapCancel",
	    "onHoverStart",
	    "onHoverEnd",
	    "whileFocus",
	    "whileTap",
	    "whileHover",
	]);
	/**
	 * Check whether a prop name is a valid `MotionProp` key.
	 *
	 * @param key - Name of the property to check
	 * @returns `true` is key is a valid `MotionProp`.
	 *
	 * @public
	 */
	function isValidMotionProp(key) {
	    return validMotionProps.has(key);
	}

	/**
	 * @public
	 */
	const PresenceContext = (c)=> getDomContext("Presence",c)||writable(null);

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	let counter = 0;
	const incrementId = () => counter++;

	function isPresent(context) {
	    return context === null ? true : context.isPresent
	}

	const usePresence = (isCustom=false) => {

	    const context = getContext(PresenceContext)||PresenceContext(isCustom);
	    const id = get_store_value(context) === null ? undefined : incrementId();
	    onMount(()=>{
	        if (get_store_value(context)!==null){
	            get_store_value(context).register(id);
	        }
	    });

	    if (get_store_value(context) === null){
	        return readable([true,null]);
	    }
	    return derived(context,$v=>
	        (!$v.isPresent && $v.onExitComplete) ? 
	            [false, ()=>$v.onExitComplete?.(id)] :
	            [true]
	    )
	};

	/**
	 * @internal
	 */
	const LayoutGroupContext = (c)=>getDomContext("LayoutGroup",c)||writable(null);

	/** 
	based on framer-motion@4.1.11,
	Copyright (c) 2018 Framer B.V.
	*/


	function isProjecting(visualElement) {
	    var isEnabled = visualElement.projection.isEnabled;
	    return isEnabled || visualElement.shouldResetTransform();
	}
	function collectProjectingAncestors(visualElement, ancestors) {
	    if (ancestors === void 0) { ancestors = []; }
	    var parent = visualElement.parent;
	    if (parent)
	        collectProjectingAncestors(parent, ancestors);
	    if (isProjecting(visualElement))
	        ancestors.push(visualElement);
	    return ancestors;
	}
	function collectProjectingChildren(visualElement) {
	    var children = [];
	    var addChild = function (child) {
	        if (isProjecting(child))
	            children.push(child);
	        child.children.forEach(addChild);
	    };
	    visualElement.children.forEach(addChild);
	    return children.sort(compareByDepth);
	}
	/**
	 * Update the layoutState by measuring the DOM layout. This
	 * should be called after resetting any layout-affecting transforms.
	 */
	function updateLayoutMeasurement(visualElement) {
	    if (visualElement.shouldResetTransform())
	        return;
	    var layoutState = visualElement.getLayoutState();
	    visualElement.notifyBeforeLayoutMeasure(layoutState.layout);
	    layoutState.isHydrated = true;
	    layoutState.layout = visualElement.measureViewportBox();
	    layoutState.layoutCorrected = copyAxisBox(layoutState.layout);
	    visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);
	    sync.update(function () { return visualElement.rebaseProjectionTarget(); });
	}
	/**
	 * Record the viewport box as it was before an expected mutation/re-render
	 */
	function snapshotViewportBox(visualElement,nc) {
	    if (visualElement.shouldResetTransform())
	        return;
	    if (!nc) visualElement.prevViewportBox = visualElement.measureViewportBox(false);
	    /**
	     * Update targetBox to match the prevViewportBox. This is just to ensure
	     * that targetBox is affected by scroll in the same way as the measured box
	     */
	    visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);
	}

	/** 
	based on framer-motion@4.1.15,
	Copyright (c) 2018 Framer B.V.
	*/

	var unresolvedJobs = new Set();
	function pushJob(stack, job, pointer) {
	    if (!stack[pointer])
	        stack[pointer] = [];
	    stack[pointer].push(job);
	}
	function batchLayout(callback) {
	    unresolvedJobs.add(callback);
	    return function () { return unresolvedJobs.delete(callback); };
	}
	function flushLayout() {
	    if (!unresolvedJobs.size)
	        return;
	    var pointer = 0;
	    var reads = [[]];
	    var writes = [];
	    var setRead = function (job) { return pushJob(reads, job, pointer); };
	    var setWrite = function (job) {
	        pushJob(writes, job, pointer);
	        pointer++;
	    };
	    /**
	     * Resolve jobs into their array stacks
	     */
	    unresolvedJobs.forEach(function (callback) {
	        callback(setRead, setWrite);
	        pointer = 0;
	    });
	    unresolvedJobs.clear();
	    sync.postRender(function () {
	        setTimeout(function () { return (false); }, 10);
	    });
	    /**
	     * Execute jobs
	     */
	    var numStacks = writes.length;
	    for (var i = 0; i <= numStacks; i++) {
	        reads[i] && reads[i].forEach(executeJob);
	        writes[i] && writes[i].forEach(executeJob);
	    }
	}
	var executeJob = function (job) { return job(); };

	/** 
	based on framer-motion@4.1.15,
	Copyright (c) 2018 Framer B.V.
	*/


	/**
	 * Default handlers for batching VisualElements
	 */
	var defaultHandler = {
	    layoutReady: function (child) { return child.notifyLayoutReady(); },
	};
	/**
	 * Create a batcher to process VisualElements
	 */
	function createBatcher() {
	    var queue = new Set();
	    return {
	        add: function (child) { return queue.add(child); },
	        flush: function (_a) {
	            var _b = _a === void 0 ? defaultHandler : _a, layoutReady = _b.layoutReady, parent = _b.parent;
	            batchLayout(function (read, write) {
	                var order = Array.from(queue).sort(compareByDepth);
	                var ancestors = parent
	                    ? collectProjectingAncestors(parent)
	                    : [];
	                write(function () {
	                    var allElements = __spreadArray(__spreadArray([], __read(ancestors)), __read(order));
	                    allElements.forEach(function (element) { return element.resetTransform(); });
	                });
	                read(function () {
	                    order.forEach(updateLayoutMeasurement);
	                });
	                write(function () {
	                    ancestors.forEach(function (element) { return element.restoreTransform(); });
	                    order.forEach(layoutReady);
	                });
	                read(function () {
	                    /**
	                     * After all children have started animating, ensure any Entering components are set to Present.
	                     * If we add deferred animations (set up all animations and then start them in two loops) this
	                     * could be moved to the start loop. But it needs to happen after all the animations configs
	                     * are generated in AnimateSharedLayout as this relies on presence data
	                     */
	                    order.forEach(function (child) {
	                        if (child.isPresent)
	                            child.presence = Presence.Present;
	                    });
	                });
	                write(function () {
	                    /**
	                     * Starting these animations will have queued jobs on the frame loop. In some situations,
	                     * like when removing an element, these will be processed too late after the DOM is manipulated,
	                     * leaving a flash of incorrectly-projected content. By manually flushing these jobs
	                     * we ensure there's no flash.
	                     */
	                    flushSync.preRender();
	                    flushSync.render();
	                });
	                read(function () {
	                    /**
	                     * Schedule a callback at the end of the following frame to assign the latest projection
	                     * box to the prevViewportBox snapshot. Once global batching is in place this could be run
	                     * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level
	                     * child attempts to calculate its previous relative position against a prevViewportBox
	                     * it will be against its latest projection box instead, as the snapshot is useless beyond this
	                     * render.
	                     */
	                    sync.postRender(function () {
	                        return order.forEach(assignProjectionToSnapshot);
	                    });
	                    queue.clear();
	                });
	            });
	            // TODO: Need to find a layout-synchronous way of flushing this
	            flushLayout();
	        },
	    };
	}
	function assignProjectionToSnapshot(child) {
	    child.prevViewportBox = child.projection.target;
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/


	var SharedLayoutContext = (custom) => getDomContext("SharedLayout",custom)||writable(createBatcher());
	/**
	 * @internal
	 */
	var FramerTreeLayoutContext = ()=> writable(createBatcher());

	function isSharedLayout(context) {
	    return !!context.forceUpdate;
	}

	const LazyContext = (c) => getDomContext("Lazy",c) || writable({ strict: false });

	/* node_modules/svelte-motion/src/context/MotionContext/MotionContext.svelte generated by Svelte v4.2.10 */

	const MotionContext = c => getDomContext("Motion", c) || writable({});

	/* node_modules/svelte-motion/src/motion/utils/UseVisualElement.svelte generated by Svelte v4.2.10 */

	const get_default_slot_changes$m = dirty => ({
		visualElement: dirty & /*visualElement*/ 1
	});

	const get_default_slot_context$m = ctx => ({ visualElement: /*visualElement*/ ctx[0] });

	function create_fragment$W(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[19].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], get_default_slot_context$m);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, visualElement*/ 262145)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[18],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, get_default_slot_changes$m),
							get_default_slot_context$m
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$W.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	const ssr = false;

	function instance$W($$self, $$props, $$invalidate) {
		let $presenceContext;
		let $config;
		let $lazyContext;
		let $layoutGroupId;
		let $mc;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UseVisualElement', slots, ['default']);
		let { createVisualElement = undefined, props, Component, visualState, isCustom } = $$props;
		const config = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
		validate_store(config, 'config');
		component_subscribe($$self, config, value => $$invalidate(15, $config = value));
		const presenceContext = getContext(PresenceContext) || PresenceContext(isCustom);
		validate_store(presenceContext, 'presenceContext');
		component_subscribe($$self, presenceContext, value => $$invalidate(14, $presenceContext = value));
		const lazyContext = getContext(LazyContext) || LazyContext(isCustom);
		validate_store(lazyContext, 'lazyContext');
		component_subscribe($$self, lazyContext, value => $$invalidate(20, $lazyContext = value));
		const mc = getContext(MotionContext) || MotionContext(isCustom);
		validate_store(mc, 'mc');
		component_subscribe($$self, mc, value => $$invalidate(17, $mc = value));
		let parent = get_store_value(mc).visualElement;
		const layoutGroupId = getContext(LayoutGroupContext) || LayoutGroupContext(isCustom);
		validate_store(layoutGroupId, 'layoutGroupId');
		component_subscribe($$self, layoutGroupId, value => $$invalidate(16, $layoutGroupId = value));

		let layoutId = $layoutGroupId && props.layoutId !== undefined
		? $layoutGroupId + "-" + props.layoutId
		: props.layoutId;

		let visualElementRef = undefined;

		/**
	 * If we haven't preloaded a renderer, check to see if we have one lazy-loaded
	 */
		if (!createVisualElement) {
			createVisualElement = $lazyContext.renderer;
		}

		let visualElement = visualElementRef;

		afterUpdate(() => {
			tick().then(() => {
				visualElement.animationState?.animateChanges();
			});
		});

		onDestroy(() => {
			visualElement?.notifyUnmount();
		});

		$$self.$$.on_mount.push(function () {
			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<UseVisualElement> was created without expected prop 'props'");
			}

			if (Component === undefined && !('Component' in $$props || $$self.$$.bound[$$self.$$.props['Component']])) {
				console.warn("<UseVisualElement> was created without expected prop 'Component'");
			}

			if (visualState === undefined && !('visualState' in $$props || $$self.$$.bound[$$self.$$.props['visualState']])) {
				console.warn("<UseVisualElement> was created without expected prop 'visualState'");
			}

			if (isCustom === undefined && !('isCustom' in $$props || $$self.$$.bound[$$self.$$.props['isCustom']])) {
				console.warn("<UseVisualElement> was created without expected prop 'isCustom'");
			}
		});

		const writable_props = ['createVisualElement', 'props', 'Component', 'visualState', 'isCustom'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UseVisualElement> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('createVisualElement' in $$props) $$invalidate(6, createVisualElement = $$props.createVisualElement);
			if ('props' in $$props) $$invalidate(7, props = $$props.props);
			if ('Component' in $$props) $$invalidate(8, Component = $$props.Component);
			if ('visualState' in $$props) $$invalidate(9, visualState = $$props.visualState);
			if ('isCustom' in $$props) $$invalidate(10, isCustom = $$props.isCustom);
			if ('$$scope' in $$props) $$invalidate(18, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			ssr,
			afterUpdate,
			getContext,
			onDestroy,
			tick,
			PresenceContext,
			LazyContext,
			MotionConfigContext,
			LayoutGroupContext,
			MotionContext,
			isPresent,
			get: get_store_value,
			createVisualElement,
			props,
			Component,
			visualState,
			isCustom,
			config,
			presenceContext,
			lazyContext,
			mc,
			parent,
			layoutGroupId,
			layoutId,
			visualElementRef,
			visualElement,
			$presenceContext,
			$config,
			$lazyContext,
			$layoutGroupId,
			$mc
		});

		$$self.$inject_state = $$props => {
			if ('createVisualElement' in $$props) $$invalidate(6, createVisualElement = $$props.createVisualElement);
			if ('props' in $$props) $$invalidate(7, props = $$props.props);
			if ('Component' in $$props) $$invalidate(8, Component = $$props.Component);
			if ('visualState' in $$props) $$invalidate(9, visualState = $$props.visualState);
			if ('isCustom' in $$props) $$invalidate(10, isCustom = $$props.isCustom);
			if ('parent' in $$props) $$invalidate(11, parent = $$props.parent);
			if ('layoutId' in $$props) $$invalidate(12, layoutId = $$props.layoutId);
			if ('visualElementRef' in $$props) $$invalidate(13, visualElementRef = $$props.visualElementRef);
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*$mc*/ 131072) {
				$$invalidate(11, parent = $mc.visualElement);
			}

			if ($$self.$$.dirty & /*$layoutGroupId, props*/ 65664) {
				$$invalidate(12, layoutId = $layoutGroupId && props.layoutId !== undefined
				? $layoutGroupId + "-" + props.layoutId
				: props.layoutId);
			}

			if ($$self.$$.dirty & /*visualElementRef, createVisualElement, Component, visualState, parent, props, layoutId, $presenceContext*/ 31680) {
				if (!visualElementRef && createVisualElement) {
					$$invalidate(13, visualElementRef = createVisualElement(Component, {
						visualState,
						parent,
						props: { ...props, layoutId },
						presenceId: $presenceContext?.id,
						blockInitialAnimation: $presenceContext?.initial === false
					}));
				}
			}

			if ($$self.$$.dirty & /*visualElementRef*/ 8192) {
				$$invalidate(0, visualElement = visualElementRef);
			}

			if ($$self.$$.dirty & /*visualElement, $config, props, layoutId, $presenceContext, parent*/ 55425) {
				if (visualElement) {
					visualElement.setProps({ ...$config, ...props, layoutId });
					$$invalidate(0, visualElement.isPresent = isPresent($presenceContext), visualElement);
					$$invalidate(0, visualElement.isPresenceRoot = !parent || parent.presenceId !== $presenceContext?.id, visualElement);

					/**
	 * Fire a render to ensure the latest state is reflected on-screen.
	 */
					visualElement.syncRender();
				}
			}
		};

		return [
			visualElement,
			config,
			presenceContext,
			lazyContext,
			mc,
			layoutGroupId,
			createVisualElement,
			props,
			Component,
			visualState,
			isCustom,
			parent,
			layoutId,
			visualElementRef,
			$presenceContext,
			$config,
			$layoutGroupId,
			$mc,
			$$scope,
			slots
		];
	}

	class UseVisualElement extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$W, create_fragment$W, safe_not_equal, {
				createVisualElement: 6,
				props: 7,
				Component: 8,
				visualState: 9,
				isCustom: 10
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UseVisualElement",
				options,
				id: create_fragment$W.name
			});
		}

		get createVisualElement() {
			throw new Error("<UseVisualElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set createVisualElement(value) {
			throw new Error("<UseVisualElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get props() {
			throw new Error("<UseVisualElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<UseVisualElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get Component() {
			throw new Error("<UseVisualElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set Component(value) {
			throw new Error("<UseVisualElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get visualState() {
			throw new Error("<UseVisualElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualState(value) {
			throw new Error("<UseVisualElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isCustom() {
			throw new Error("<UseVisualElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isCustom(value) {
			throw new Error("<UseVisualElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UseVisualElement$1 = UseVisualElement;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var createDefinition = function (propNames) { return ({
	    isEnabled: function (props) { return propNames.some(function (name) { return !!props[name]; }); },
	}); };
	var featureDefinitions = {
	    measureLayout: createDefinition(["layout", "layoutId", "drag"]),
	    animation: createDefinition([
	        "animate",
	        "exit",
	        "variants",
	        "whileHover",
	        "whileTap",
	        "whileFocus",
	        "whileDrag",
	    ]),
	    exit: createDefinition(["exit"]),
	    drag: createDefinition(["drag", "dragControls"]),
	    focus: createDefinition(["whileFocus"]),
	    hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
	    tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
	    pan: createDefinition([
	        "onPan",
	        "onPanStart",
	        "onPanSessionStart",
	        "onPanEnd",
	    ]),
	    layoutAnimation: createDefinition(["layout", "layoutId"]),
	};
	function loadFeatures(features) {
	    for (var key in features) {
	        var Component = features[key];
	        if (Component !== null){
	            featureDefinitions[key].Component = Component;
	        }
	    }
	}

	/* node_modules/svelte-motion/src/motion/features/UseFeatures.svelte generated by Svelte v4.2.10 */

	const { Object: Object_1$2 } = globals;
	const get_default_slot_changes$l = dirty => ({ features: dirty & /*features*/ 2 });
	const get_default_slot_context$l = ctx => ({ features: /*features*/ ctx[1] });

	// (40:0) {#if visualElement}
	function create_if_block$k(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[4].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], get_default_slot_context$l);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, features*/ 10)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[3],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, get_default_slot_changes$l),
							get_default_slot_context$l
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$k.name,
			type: "if",
			source: "(40:0) {#if visualElement}",
			ctx
		});

		return block;
	}

	function create_fragment$V(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*visualElement*/ ctx[0] && create_if_block$k(ctx);

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (/*visualElement*/ ctx[0]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*visualElement*/ 1) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$k(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$V.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$V($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UseFeatures', slots, ['default']);
		const featureNames = Object.keys(featureDefinitions);
		const numFeatures = featureNames.length;
		let { visualElement, props } = $$props;
		let features = [];

		$$self.$$.on_mount.push(function () {
			if (visualElement === undefined && !('visualElement' in $$props || $$self.$$.bound[$$self.$$.props['visualElement']])) {
				console.warn("<UseFeatures> was created without expected prop 'visualElement'");
			}

			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<UseFeatures> was created without expected prop 'props'");
			}
		});

		const writable_props = ['visualElement', 'props'];

		Object_1$2.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UseFeatures> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('props' in $$props) $$invalidate(2, props = $$props.props);
			if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			featureDefinitions,
			featureNames,
			numFeatures,
			visualElement,
			props,
			features
		});

		$$self.$inject_state = $$props => {
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('props' in $$props) $$invalidate(2, props = $$props.props);
			if ('features' in $$props) $$invalidate(1, features = $$props.features);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*props, features, visualElement*/ 7) {
				// If this is a static component, or we're rendering on the server, we don't load
				// any feature components
				// Decide which features we should render and add them to the returned array
				{
					$$invalidate(1, features = []);

					for (let i = 0; i < numFeatures; i++) {
						const name = featureNames[i];
						const { isEnabled, Component } = featureDefinitions[name];

						/**
	 * It might be possible in the future to use this moment to
	 * dynamically request functionality. In initial tests this
	 * was producing a lot of duplication amongst bundles.
	 */
						if (isEnabled(props) && Component) {
							features.push({
								Component,
								key: name,
								props,
								visualElement
							});
						}
					}
				}
			}
		};

		return [visualElement, features, props, $$scope, slots];
	}

	class UseFeatures extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$V, create_fragment$V, safe_not_equal, { visualElement: 0, props: 2 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UseFeatures",
				options,
				id: create_fragment$V.name
			});
		}

		get visualElement() {
			throw new Error("<UseFeatures>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualElement(value) {
			throw new Error("<UseFeatures>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get props() {
			throw new Error("<UseFeatures>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<UseFeatures>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UseFeatures$1 = UseFeatures;

	/* node_modules/svelte-motion/src/context/MotionContext/MotionContextProvider.svelte generated by Svelte v4.2.10 */

	function create_fragment$U(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[2],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$U.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$U($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('MotionContextProvider', slots, ['default']);
		let { value, isCustom } = $$props;
		let store = writable(value);
		setContext(MotionContext, store);
		setDomContext("Motion", isCustom, store);

		// Since useMotionRef is not called on destroy, the visual element is unmounted here
		onDestroy(() => {
			value?.visualElement?.unmount();
		});

		$$self.$$.on_mount.push(function () {
			if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
				console.warn("<MotionContextProvider> was created without expected prop 'value'");
			}

			if (isCustom === undefined && !('isCustom' in $$props || $$self.$$.bound[$$self.$$.props['isCustom']])) {
				console.warn("<MotionContextProvider> was created without expected prop 'isCustom'");
			}
		});

		const writable_props = ['value', 'isCustom'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MotionContextProvider> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('isCustom' in $$props) $$invalidate(1, isCustom = $$props.isCustom);
			if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			onDestroy,
			setContext,
			writable,
			setDomContext,
			MotionContext,
			value,
			isCustom,
			store
		});

		$$self.$inject_state = $$props => {
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('isCustom' in $$props) $$invalidate(1, isCustom = $$props.isCustom);
			if ('store' in $$props) $$invalidate(4, store = $$props.store);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*value*/ 1) {
				store.set(value);
			}
		};

		return [value, isCustom, $$scope, slots];
	}

	class MotionContextProvider extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$U, create_fragment$U, safe_not_equal, { value: 0, isCustom: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "MotionContextProvider",
				options,
				id: create_fragment$U.name
			});
		}

		get value() {
			throw new Error("<MotionContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set value(value) {
			throw new Error("<MotionContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isCustom() {
			throw new Error("<MotionContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isCustom(value) {
			throw new Error("<MotionContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var MotionContextProvider$1 = MotionContextProvider;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	var createHtmlRenderState = function () { return ({
	    style: {},
	    transform: {},
	    transformKeys: [],
	    transformOrigin: {},
	    vars: {},
	}); };

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var createSvgRenderState = function () { return (__assign(__assign({}, createHtmlRenderState()), { attrs: {} })); };

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * A list of all transformable axes. We'll use this list to generated a version
	 * of each axes for each transform.
	 */
	var transformAxes = ["", "X", "Y", "Z"];
	/**
	 * An ordered array of each transformable value. By default, transform values
	 * will be sorted to this order.
	 */
	var order = ["translate", "scale", "rotate", "skew"];
	/**
	 * Generate a list of every possible transform key.
	 */
	var transformProps = ["transformPerspective", "x", "y", "z"];
	order.forEach(function (operationKey) {
	    return transformAxes.forEach(function (axesKey) {
	        return transformProps.push(operationKey + axesKey);
	    });
	});
	/**
	 * A function to use with Array.sort to sort transform keys by their default order.
	 */
	function sortTransformProps(a, b) {
	    return transformProps.indexOf(a) - transformProps.indexOf(b);
	}
	/**
	 * A quick lookup for transform props.
	 */
	var transformPropSet = new Set(transformProps);
	function isTransformProp(key) {
	    return transformPropSet.has(key);
	}
	/**
	 * A quick lookup for transform origin props
	 */
	var transformOriginProps = new Set(["originX", "originY", "originZ"]);
	function isTransformOriginProp(key) {
	    return transformOriginProps.has(key);
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	function isForcedMotionValue(key, _a) {
	    var layout = _a.layout, layoutId = _a.layoutId;
	    return (isTransformProp(key) ||
	        isTransformOriginProp(key) ||
	        ((layout || layoutId !== undefined) && !!valueScaleCorrection[key]));
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var translateAlias = {
	    x: "translateX",
	    y: "translateY",
	    z: "translateZ",
	    transformPerspective: "perspective",
	};
	/**
	 * Build a CSS transform style from individual x/y/scale etc properties.
	 *
	 * This outputs with a default order of transforms/scales/rotations, this can be customised by
	 * providing a transformTemplate function.
	 */
	function buildTransform(_a, _b, transformIsDefault, transformTemplate) {
	    var transform = _a.transform, transformKeys = _a.transformKeys;
	    var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;
	    // The transform string we're going to build into.
	    var transformString = "";
	    // Transform keys into their default order - this will determine the output order.
	    transformKeys.sort(sortTransformProps);
	    // Track whether the defined transform has a defined z so we don't add a
	    // second to enable hardware acceleration
	    var transformHasZ = false;
	    // Loop over each transform and build them into transformString
	    var numTransformKeys = transformKeys.length;
	    for (var i = 0; i < numTransformKeys; i++) {
	        var key = transformKeys[i];
	        transformString += (translateAlias[key] || key) + "(" + transform[key] + ") ";
	        if (key === "z")
	            transformHasZ = true;
	    }
	    if (!transformHasZ && enableHardwareAcceleration) {
	        transformString += "translateZ(0)";
	    }
	    else {
	        transformString = transformString.trim();
	    }
	    // If we have a custom `transform` template, pass our transform values and
	    // generated transformString to that before returning
	    if (transformTemplate) {
	        transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
	    }
	    else if (allowTransformNone && transformIsDefault) {
	        transformString = "none";
	    }
	    return transformString;
	}
	/**
	 * Build a transformOrigin style. Uses the same defaults as the browser for
	 * undefined origins.
	 */
	function buildTransformOrigin(_a) {
	    var _b = _a.originX, originX = _b === void 0 ? "50%" : _b, _c = _a.originY, originY = _c === void 0 ? "50%" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;
	    return originX + " " + originY + " " + originZ;
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	/**
	 * Returns true if the provided key is a CSS variable
	 */
	function isCSSVariable$1(key) {
	    return key.startsWith("--");
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	/**
	 * Provided a value and a ValueType, returns the value as that value type.
	 */
	var getValueAsType = function (value, type) {
	    return type && typeof value === "number"
	        ? type.transform(value)
	        : value;
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	function buildHTMLStyles(state, latestValues, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {
	    var _a;
	    var style = state.style, vars = state.vars, transform = state.transform, transformKeys = state.transformKeys, transformOrigin = state.transformOrigin;
	    // Empty the transformKeys array. As we're throwing out refs to its items
	    // this might not be as cheap as suspected. Maybe using the array as a buffer
	    // with a manual incrementation would be better.
	    transformKeys.length = 0;
	    // Track whether we encounter any transform or transformOrigin values.
	    var hasTransform = false;
	    var hasTransformOrigin = false;
	    // Does the calculated transform essentially equal "none"?
	    var transformIsNone = true;
	    /**
	     * Loop over all our latest animated values and decide whether to handle them
	     * as a style or CSS variable.
	     *
	     * Transforms and transform origins are kept seperately for further processing.
	     */
	    for (var key in latestValues) {
	        var value = latestValues[key];
	        /**
	         * If this is a CSS variable we don't do any further processing.
	         */
	        if (isCSSVariable$1(key)) {
	            vars[key] = value;
	            continue;
	        }
	        // Convert the value to its default value type, ie 0 -> "0px"
	        var valueType = numberValueTypes[key];
	        var valueAsType = getValueAsType(value, valueType);
	        if (isTransformProp(key)) {
	            // If this is a transform, flag to enable further transform processing
	            hasTransform = true;
	            transform[key] = valueAsType;
	            transformKeys.push(key);
	            // If we already know we have a non-default transform, early return
	            if (!transformIsNone)
	                continue;
	            // Otherwise check to see if this is a default transform
	            if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0))
	                transformIsNone = false;
	        }
	        else if (isTransformOriginProp(key)) {
	            transformOrigin[key] = valueAsType;
	            // If this is a transform origin, flag and enable further transform-origin processing
	            hasTransformOrigin = true;
	        }
	        else {
	            /**
	             * If layout projection is on, and we need to perform scale correction for this
	             * value type, perform it.
	             */
	            if (layoutState &&
	                projection &&
	                layoutState.isHydrated &&
	                valueScaleCorrection[key]) {
	                var correctedValue = valueScaleCorrection[key].process(value, layoutState, projection);
	                /**
	                 * Scale-correctable values can define a number of other values to break
	                 * down into. For instance borderRadius needs applying to borderBottomLeftRadius etc
	                 */
	                var applyTo = valueScaleCorrection[key].applyTo;
	                if (applyTo) {
	                    var num = applyTo.length;
	                    for (var i = 0; i < num; i++) {
	                        style[applyTo[i]] = correctedValue;
	                    }
	                }
	                else {
	                    style[key] = correctedValue;
	                }
	            }
	            else {
	                style[key] = valueAsType;
	            }
	        }
	    }
	    if (layoutState &&
	        projection &&
	        buildProjectionTransform &&
	        buildProjectionTransformOrigin) {
	        style.transform = buildProjectionTransform(layoutState.deltaFinal, layoutState.treeScale, hasTransform ? transform : undefined);
	        if (transformTemplate) {
	            style.transform = transformTemplate(transform, style.transform);
	        }
	        style.transformOrigin = buildProjectionTransformOrigin(layoutState);
	    }
	    else {
	        if (hasTransform) {
	            style.transform = buildTransform(state, options, transformIsNone, transformTemplate);
	        }
	        if (hasTransformOrigin) {
	            style.transformOrigin = buildTransformOrigin(transformOrigin);
	        }
	    }
	}

	/* node_modules/svelte-motion/src/render/html/UseInitialMotionValues.svelte generated by Svelte v4.2.10 */
	const get_default_slot_changes$k = dirty => ({ styles: dirty & /*styles*/ 1 });
	const get_default_slot_context$k = ctx => ({ styles: /*styles*/ ctx[0] });

	function create_fragment$T(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[5].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], get_default_slot_context$k);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, styles*/ 17)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[4],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, get_default_slot_changes$k),
							get_default_slot_context$k
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$T.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$T($$self, $$props, $$invalidate) {
		let styles;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UseInitialMotionValues', slots, ['default']);
		let { visualState, isStatic, props } = $$props;

		const memo = () => {
			let state = createHtmlRenderState();
			buildHTMLStyles(state, visualState, undefined, undefined, { enableHardwareAcceleration: !isStatic }, props.transformTemplate);
			const { vars, style } = state;
			return { ...vars, ...style };
		};

		$$self.$$.on_mount.push(function () {
			if (visualState === undefined && !('visualState' in $$props || $$self.$$.bound[$$self.$$.props['visualState']])) {
				console.warn("<UseInitialMotionValues> was created without expected prop 'visualState'");
			}

			if (isStatic === undefined && !('isStatic' in $$props || $$self.$$.bound[$$self.$$.props['isStatic']])) {
				console.warn("<UseInitialMotionValues> was created without expected prop 'isStatic'");
			}

			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<UseInitialMotionValues> was created without expected prop 'props'");
			}
		});

		const writable_props = ['visualState', 'isStatic', 'props'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UseInitialMotionValues> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('visualState' in $$props) $$invalidate(1, visualState = $$props.visualState);
			if ('isStatic' in $$props) $$invalidate(2, isStatic = $$props.isStatic);
			if ('props' in $$props) $$invalidate(3, props = $$props.props);
			if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			buildHTMLStyles,
			createHtmlRenderState,
			visualState,
			isStatic,
			props,
			memo,
			styles
		});

		$$self.$inject_state = $$props => {
			if ('visualState' in $$props) $$invalidate(1, visualState = $$props.visualState);
			if ('isStatic' in $$props) $$invalidate(2, isStatic = $$props.isStatic);
			if ('props' in $$props) $$invalidate(3, props = $$props.props);
			if ('styles' in $$props) $$invalidate(0, styles = $$props.styles);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*visualState*/ 2) {
				$$invalidate(0, styles = memo());
			}
		};

		return [styles, visualState, isStatic, props, $$scope, slots];
	}

	class UseInitialMotionValues extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$T, create_fragment$T, safe_not_equal, { visualState: 1, isStatic: 2, props: 3 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UseInitialMotionValues",
				options,
				id: create_fragment$T.name
			});
		}

		get visualState() {
			throw new Error("<UseInitialMotionValues>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualState(value) {
			throw new Error("<UseInitialMotionValues>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isStatic() {
			throw new Error("<UseInitialMotionValues>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isStatic(value) {
			throw new Error("<UseInitialMotionValues>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get props() {
			throw new Error("<UseInitialMotionValues>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<UseInitialMotionValues>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UseInitialMotionValues$1 = UseInitialMotionValues;

	/* node_modules/svelte-motion/src/render/html/UseStyle.svelte generated by Svelte v4.2.10 */

	const { Object: Object_1$1 } = globals;
	const get_default_slot_changes$j = dirty => ({ styles: dirty & /*s1, props, style*/ 522 });

	const get_default_slot_context$j = ctx => ({
		styles: /*toStyle*/ ctx[4](/*s1*/ ctx[9], /*props*/ ctx[1], /*style*/ ctx[3])
	});

	// (41:0) <UseInitialMotionValues {props} {visualState} {isStatic} let:styles={s1}>
	function create_default_slot$l(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[6].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context$j);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, s1, props, style*/ 650)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[7],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, get_default_slot_changes$j),
							get_default_slot_context$j
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$l.name,
			type: "slot",
			source: "(41:0) <UseInitialMotionValues {props} {visualState} {isStatic} let:styles={s1}>",
			ctx
		});

		return block;
	}

	function create_fragment$S(ctx) {
		let useinitialmotionvalues;
		let current;

		useinitialmotionvalues = new UseInitialMotionValues$1({
				props: {
					props: /*props*/ ctx[1],
					visualState: /*visualState*/ ctx[0],
					isStatic: /*isStatic*/ ctx[2],
					$$slots: {
						default: [
							create_default_slot$l,
							({ styles: s1 }) => ({ 9: s1 }),
							({ styles: s1 }) => s1 ? 512 : 0
						]
					},
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(useinitialmotionvalues.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(useinitialmotionvalues, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const useinitialmotionvalues_changes = {};
				if (dirty & /*props*/ 2) useinitialmotionvalues_changes.props = /*props*/ ctx[1];
				if (dirty & /*visualState*/ 1) useinitialmotionvalues_changes.visualState = /*visualState*/ ctx[0];
				if (dirty & /*isStatic*/ 4) useinitialmotionvalues_changes.isStatic = /*isStatic*/ ctx[2];

				if (dirty & /*$$scope, s1, props, style*/ 650) {
					useinitialmotionvalues_changes.$$scope = { dirty, ctx };
				}

				useinitialmotionvalues.$set(useinitialmotionvalues_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(useinitialmotionvalues.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(useinitialmotionvalues.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(useinitialmotionvalues, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$S.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function copyRawValuesOnly(target, source, props) {
		for (const key in source) {
			if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
				target[key] = source[key];
			}
		}
	}

	function instance$S($$self, $$props, $$invalidate) {
		let styleProp;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UseStyle', slots, ['default']);
		let { visualState, props, isStatic } = $$props;
		let style = {};

		/**
	 * Copy non-Motion Values straight into style
	 */
		const cRVO = copyRawValuesOnly;

		const toStyle = s1 => {
			Object.assign(style, s1);

			if (props.transformValues) {
				$$invalidate(3, style = props.transformValues(style));
			}

			return style;
		};

		$$self.$$.on_mount.push(function () {
			if (visualState === undefined && !('visualState' in $$props || $$self.$$.bound[$$self.$$.props['visualState']])) {
				console.warn("<UseStyle> was created without expected prop 'visualState'");
			}

			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<UseStyle> was created without expected prop 'props'");
			}

			if (isStatic === undefined && !('isStatic' in $$props || $$self.$$.bound[$$self.$$.props['isStatic']])) {
				console.warn("<UseStyle> was created without expected prop 'isStatic'");
			}
		});

		const writable_props = ['visualState', 'props', 'isStatic'];

		Object_1$1.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UseStyle> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('visualState' in $$props) $$invalidate(0, visualState = $$props.visualState);
			if ('props' in $$props) $$invalidate(1, props = $$props.props);
			if ('isStatic' in $$props) $$invalidate(2, isStatic = $$props.isStatic);
			if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			copyRawValuesOnly,
			isMotionValue,
			isForcedMotionValue,
			UseInitialMotionValues: UseInitialMotionValues$1,
			visualState,
			props,
			isStatic,
			style,
			cRVO,
			toStyle,
			styleProp
		});

		$$self.$inject_state = $$props => {
			if ('visualState' in $$props) $$invalidate(0, visualState = $$props.visualState);
			if ('props' in $$props) $$invalidate(1, props = $$props.props);
			if ('isStatic' in $$props) $$invalidate(2, isStatic = $$props.isStatic);
			if ('style' in $$props) $$invalidate(3, style = $$props.style);
			if ('styleProp' in $$props) $$invalidate(5, styleProp = $$props.styleProp);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*props*/ 2) {
				$$invalidate(5, styleProp = props.style || {});
			}

			if ($$self.$$.dirty & /*style, styleProp, props*/ 42) {
				cRVO(style, styleProp, props);
			}
		};

		return [visualState, props, isStatic, style, toStyle, styleProp, slots, $$scope];
	}

	class UseStyle extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$S, create_fragment$S, safe_not_equal, { visualState: 0, props: 1, isStatic: 2 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UseStyle",
				options,
				id: create_fragment$S.name
			});
		}

		get visualState() {
			throw new Error("<UseStyle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualState(value) {
			throw new Error("<UseStyle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get props() {
			throw new Error("<UseStyle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<UseStyle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isStatic() {
			throw new Error("<UseStyle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isStatic(value) {
			throw new Error("<UseStyle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UseStyle$1 = UseStyle;

	/* node_modules/svelte-motion/src/render/html/UseHTMLProps.svelte generated by Svelte v4.2.10 */

	const get_default_slot_changes$i = dirty => ({
		visualProps: dirty & /*styles, props*/ 65
	});

	const get_default_slot_context$i = ctx => ({
		visualProps: /*getHTMLProps*/ ctx[3](/*styles*/ ctx[6], /*props*/ ctx[0])
	});

	// (36:0) <UseStyle let:styles {visualState} {props} {isStatic}>
	function create_default_slot$k(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[4].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], get_default_slot_context$i);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, styles, props*/ 97)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[5],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, get_default_slot_changes$i),
							get_default_slot_context$i
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$k.name,
			type: "slot",
			source: "(36:0) <UseStyle let:styles {visualState} {props} {isStatic}>",
			ctx
		});

		return block;
	}

	function create_fragment$R(ctx) {
		let usestyle;
		let current;

		usestyle = new UseStyle$1({
				props: {
					visualState: /*visualState*/ ctx[1],
					props: /*props*/ ctx[0],
					isStatic: /*isStatic*/ ctx[2],
					$$slots: {
						default: [
							create_default_slot$k,
							({ styles }) => ({ 6: styles }),
							({ styles }) => styles ? 64 : 0
						]
					},
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(usestyle.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(usestyle, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const usestyle_changes = {};
				if (dirty & /*visualState*/ 2) usestyle_changes.visualState = /*visualState*/ ctx[1];
				if (dirty & /*props*/ 1) usestyle_changes.props = /*props*/ ctx[0];
				if (dirty & /*isStatic*/ 4) usestyle_changes.isStatic = /*isStatic*/ ctx[2];

				if (dirty & /*$$scope, styles, props*/ 97) {
					usestyle_changes.$$scope = { dirty, ctx };
				}

				usestyle.$set(usestyle_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(usestyle.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(usestyle.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(usestyle, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$R.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$R($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UseHTMLProps', slots, ['default']);
		let { props, visualState, isStatic } = $$props;

		const getHTMLProps = (style, props) => {
			let htmlProps = {};

			if (Boolean(props.drag)) {
				// Disable the ghost element when a user drags
				htmlProps.draggable = false;

				// Disable text selection
				style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";

				// Disable scrolling on the draggable direction
				style.touchAction = props.drag === true
				? "none"
				: `pan-${props.drag === "x" ? "y" : "x"}`;
			}

			htmlProps.style = style;
			return htmlProps;
		};

		$$self.$$.on_mount.push(function () {
			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<UseHTMLProps> was created without expected prop 'props'");
			}

			if (visualState === undefined && !('visualState' in $$props || $$self.$$.bound[$$self.$$.props['visualState']])) {
				console.warn("<UseHTMLProps> was created without expected prop 'visualState'");
			}

			if (isStatic === undefined && !('isStatic' in $$props || $$self.$$.bound[$$self.$$.props['isStatic']])) {
				console.warn("<UseHTMLProps> was created without expected prop 'isStatic'");
			}
		});

		const writable_props = ['props', 'visualState', 'isStatic'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UseHTMLProps> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('props' in $$props) $$invalidate(0, props = $$props.props);
			if ('visualState' in $$props) $$invalidate(1, visualState = $$props.visualState);
			if ('isStatic' in $$props) $$invalidate(2, isStatic = $$props.isStatic);
			if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			UseStyle: UseStyle$1,
			props,
			visualState,
			isStatic,
			getHTMLProps
		});

		$$self.$inject_state = $$props => {
			if ('props' in $$props) $$invalidate(0, props = $$props.props);
			if ('visualState' in $$props) $$invalidate(1, visualState = $$props.visualState);
			if ('isStatic' in $$props) $$invalidate(2, isStatic = $$props.isStatic);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [props, visualState, isStatic, getHTMLProps, slots, $$scope];
	}

	class UseHTMLProps extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$R, create_fragment$R, safe_not_equal, { props: 0, visualState: 1, isStatic: 2 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UseHTMLProps",
				options,
				id: create_fragment$R.name
			});
		}

		get props() {
			throw new Error("<UseHTMLProps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<UseHTMLProps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get visualState() {
			throw new Error("<UseHTMLProps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualState(value) {
			throw new Error("<UseHTMLProps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isStatic() {
			throw new Error("<UseHTMLProps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isStatic(value) {
			throw new Error("<UseHTMLProps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UseHTMLProps$1 = UseHTMLProps;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	function calcOrigin(origin, offset, size) {
	    return typeof origin === "string"
	        ? origin
	        : px.transform(offset + size * origin);
	}
	/**
	 * The SVG transform origin defaults are different to CSS and is less intuitive,
	 * so we use the measured dimensions of the SVG to reconcile these.
	 */
	function calcSVGTransformOrigin(dimensions, originX, originY) {
	    var pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
	    var pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
	    return pxOriginX + " " + pxOriginY;
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	// Convert a progress 0-1 to a pixels value based on the provided length
	var progressToPixels = function (progress, length) {
	    return px.transform(progress * length);
	};
	var dashKeys = {
	    offset: "stroke-dashoffset",
	    array: "stroke-dasharray",
	};
	var camelKeys = {
	    offset: "strokeDashoffset",
	    array: "strokeDasharray",
	};
	/**
	 * Build SVG path properties. Uses the path's measured length to convert
	 * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset
	 * and stroke-dasharray attributes.
	 *
	 * This function is mutative to reduce per-frame GC.
	 */
	function buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {
	    if (spacing === void 0) { spacing = 1; }
	    if (offset === void 0) { offset = 0; }
	    if (useDashCase === void 0) { useDashCase = true; }
	    // We use dash case when setting attributes directly to the DOM node and camel case
	    // when defining props on a React component.
	    var keys = useDashCase ? dashKeys : camelKeys;
	    // Build the dash offset
	    attrs[keys.offset] = progressToPixels(-offset, totalLength);
	    // Build the dash array
	    var pathLength = progressToPixels(length, totalLength);
	    var pathSpacing = progressToPixels(spacing, totalLength);
	    attrs[keys.array] = pathLength + " " + pathSpacing;
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * Build SVG visual attrbutes, like cx and style.transform
	 */
	function buildSVGAttrs(state, _a, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {
	    var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, 
	    // This is object creation, which we try to avoid per-frame.
	    latest = __rest(_a, ["attrX", "attrY", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);
	    buildHTMLStyles(state, latest, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin);
	    state.attrs = state.style;
	    state.style = {};
	    var attrs = state.attrs, style = state.style, dimensions = state.dimensions, totalPathLength = state.totalPathLength;
	    /**
	     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs
	     * and copy it into style.
	     */
	    if (attrs.transform) {
	        if (dimensions)
	            style.transform = attrs.transform;
	        delete attrs.transform;
	    }
	    // Parse transformOrigin
	    if (dimensions &&
	        (originX !== undefined || originY !== undefined || style.transform)) {
	        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);
	    }
	    // Treat x/y not as shortcuts but as actual attributes
	    if (attrX !== undefined)
	        attrs.x = attrX;
	    if (attrY !== undefined)
	        attrs.y = attrY;
	    // Build SVG path if one has been measured
	    if (totalPathLength !== undefined && pathLength !== undefined) {
	        buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);
	    }
	}

	/* node_modules/svelte-motion/src/render/svg/UseSVGProps.svelte generated by Svelte v4.2.10 */
	const get_default_slot_changes$h = dirty => ({ visualProps: dirty & /*visualProps*/ 1 });
	const get_default_slot_context$h = ctx => ({ visualProps: /*visualProps*/ ctx[0] });

	function create_fragment$Q(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[4].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], get_default_slot_context$h);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, visualProps*/ 9)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[3],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, get_default_slot_changes$h),
							get_default_slot_context$h
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$Q.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$Q($$self, $$props, $$invalidate) {
		let visualProps;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UseSVGProps', slots, ['default']);
		let { visualState, props } = $$props;

		let memo = () => {
			const state = createSvgRenderState();
			buildSVGAttrs(state, visualState, undefined, undefined, { enableHardwareAcceleration: false }, props.transformTemplate);

			return {
				...state.attrs,
				style: { ...state.style }
			};
		};

		$$self.$$.on_mount.push(function () {
			if (visualState === undefined && !('visualState' in $$props || $$self.$$.bound[$$self.$$.props['visualState']])) {
				console.warn("<UseSVGProps> was created without expected prop 'visualState'");
			}

			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<UseSVGProps> was created without expected prop 'props'");
			}
		});

		const writable_props = ['visualState', 'props'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UseSVGProps> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('visualState' in $$props) $$invalidate(1, visualState = $$props.visualState);
			if ('props' in $$props) $$invalidate(2, props = $$props.props);
			if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			createSvgRenderState,
			copyRawValuesOnly,
			buildSVGAttrs,
			visualState,
			props,
			memo,
			visualProps
		});

		$$self.$inject_state = $$props => {
			if ('visualState' in $$props) $$invalidate(1, visualState = $$props.visualState);
			if ('props' in $$props) $$invalidate(2, props = $$props.props);
			if ('memo' in $$props) $$invalidate(5, memo = $$props.memo);
			if ('visualProps' in $$props) $$invalidate(0, visualProps = $$props.visualProps);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*visualState*/ 2) {
				$$invalidate(0, visualProps = memo(visualState));
			}

			if ($$self.$$.dirty & /*props, visualProps*/ 5) {
				if (props.style) {
					const rawStyles = {};
					copyRawValuesOnly(rawStyles, props.style, props);
					$$invalidate(0, visualProps.style = { ...rawStyles, ...visualProps.style }, visualProps);
				}
			}
		};

		return [visualProps, visualState, props, $$scope, slots];
	}

	class UseSVGProps extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$Q, create_fragment$Q, safe_not_equal, { visualState: 1, props: 2 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UseSVGProps",
				options,
				id: create_fragment$Q.name
			});
		}

		get visualState() {
			throw new Error("<UseSVGProps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualState(value) {
			throw new Error("<UseSVGProps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get props() {
			throw new Error("<UseSVGProps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<UseSVGProps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UseSVGProps$1 = UseSVGProps;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var shouldForward = function (key) { return !isValidMotionProp(key); };
	/**
	 * Emotion and Styled Components both allow users to pass through arbitrary props to their components
	 * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which
	 * of these should be passed to the underlying DOM node.
	 *
	 * However, when styling a Motion component `styled(MotionDiv)`, both packages pass through *all* props
	 * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props
	 * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of
	 * `@emotion/is-prop-valid`, however to fix this problem we need to use it.
	 *
	 * By making it an optionalDependency we can offer this functionality only in the situations where it's
	 * actually required.
	 */
	try {
	    var emotionIsPropValid_1 = require("@emotion/is-prop-valid").default;
	    shouldForward = function (key) {
	        // Handle events explicitly as Emotion validates them all as true
	        if (key.startsWith("on")) {
	            return !isValidMotionProp(key);
	        }
	        else {
	            return emotionIsPropValid_1(key);
	        }
	    };
	}
	catch (_a) {
	    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.
	}
	function filterProps(props, isDom, forwardMotionProps) {
	    var filteredProps = {};
	    for (var key in props) {
	        if (shouldForward(key) ||
	            (forwardMotionProps === true && isValidMotionProp(key)) ||
	            (!isDom && !isValidMotionProp(key))) {
	            filteredProps[key] = props[key];
	        }
	    }
	    return filteredProps;
	}

	/* node_modules/svelte-motion/src/render/dom/UseRender.svelte generated by Svelte v4.2.10 */

	const get_default_slot_changes$g = dirty => ({
		props: dirty & /*filteredProps, visualProps*/ 2064
	});

	const get_default_slot_context$g = ctx => ({
		motion: /*motion*/ ctx[5],
		props: {
			.../*filteredProps*/ ctx[4],
			.../*visualProps*/ ctx[11]
		}
	});

	// (33:0) <svelte:component     this={Component === 'SVG' ? UseSVGProps : UseHTMLProps}     {visualState}     {isStatic}     {props}     let:visualProps>
	function create_default_slot$j(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[9].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], get_default_slot_context$g);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, filteredProps, visualProps*/ 3088)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[10],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, get_default_slot_changes$g),
							get_default_slot_context$g
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$j.name,
			type: "slot",
			source: "(33:0) <svelte:component     this={Component === 'SVG' ? UseSVGProps : UseHTMLProps}     {visualState}     {isStatic}     {props}     let:visualProps>",
			ctx
		});

		return block;
	}

	function create_fragment$P(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;

		var switch_value = /*Component*/ ctx[2] === 'SVG'
		? UseSVGProps$1
		: UseHTMLProps$1;

		function switch_props(ctx, dirty) {
			return {
				props: {
					visualState: /*visualState*/ ctx[1],
					isStatic: /*isStatic*/ ctx[3],
					props: /*props*/ ctx[0],
					$$slots: {
						default: [
							create_default_slot$j,
							({ visualProps }) => ({ 11: visualProps }),
							({ visualProps }) => visualProps ? 2048 : 0
						]
					},
					$$scope: { ctx }
				},
				$$inline: true
			};
		}

		if (switch_value) {
			switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
		}

		const block = {
			c: function create() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert_dev(target, switch_instance_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*Component*/ 4 && switch_value !== (switch_value = /*Component*/ ctx[2] === 'SVG'
				? UseSVGProps$1
				: UseHTMLProps$1)) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = {};
					if (dirty & /*visualState*/ 2) switch_instance_changes.visualState = /*visualState*/ ctx[1];
					if (dirty & /*isStatic*/ 8) switch_instance_changes.isStatic = /*isStatic*/ ctx[3];
					if (dirty & /*props*/ 1) switch_instance_changes.props = /*props*/ ctx[0];

					if (dirty & /*$$scope, filteredProps, visualProps*/ 3088) {
						switch_instance_changes.$$scope = { dirty, ctx };
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i: function intro(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$P.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$P($$self, $$props, $$invalidate) {
		let filteredProps;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UseRender', slots, ['default']);
		let { props, visualState, Component, forwardMotionProps = false, isStatic, ref, targetEl = undefined } = $$props;

		const motion = node => {
			ref(node);
		};

		$$self.$$.on_mount.push(function () {
			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<UseRender> was created without expected prop 'props'");
			}

			if (visualState === undefined && !('visualState' in $$props || $$self.$$.bound[$$self.$$.props['visualState']])) {
				console.warn("<UseRender> was created without expected prop 'visualState'");
			}

			if (Component === undefined && !('Component' in $$props || $$self.$$.bound[$$self.$$.props['Component']])) {
				console.warn("<UseRender> was created without expected prop 'Component'");
			}

			if (isStatic === undefined && !('isStatic' in $$props || $$self.$$.bound[$$self.$$.props['isStatic']])) {
				console.warn("<UseRender> was created without expected prop 'isStatic'");
			}

			if (ref === undefined && !('ref' in $$props || $$self.$$.bound[$$self.$$.props['ref']])) {
				console.warn("<UseRender> was created without expected prop 'ref'");
			}
		});

		const writable_props = [
			'props',
			'visualState',
			'Component',
			'forwardMotionProps',
			'isStatic',
			'ref',
			'targetEl'
		];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UseRender> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('props' in $$props) $$invalidate(0, props = $$props.props);
			if ('visualState' in $$props) $$invalidate(1, visualState = $$props.visualState);
			if ('Component' in $$props) $$invalidate(2, Component = $$props.Component);
			if ('forwardMotionProps' in $$props) $$invalidate(6, forwardMotionProps = $$props.forwardMotionProps);
			if ('isStatic' in $$props) $$invalidate(3, isStatic = $$props.isStatic);
			if ('ref' in $$props) $$invalidate(7, ref = $$props.ref);
			if ('targetEl' in $$props) $$invalidate(8, targetEl = $$props.targetEl);
			if ('$$scope' in $$props) $$invalidate(10, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			UseSVGProps: UseSVGProps$1,
			UseHTMLProps: UseHTMLProps$1,
			filterProps,
			props,
			visualState,
			Component,
			forwardMotionProps,
			isStatic,
			ref,
			targetEl,
			motion,
			filteredProps
		});

		$$self.$inject_state = $$props => {
			if ('props' in $$props) $$invalidate(0, props = $$props.props);
			if ('visualState' in $$props) $$invalidate(1, visualState = $$props.visualState);
			if ('Component' in $$props) $$invalidate(2, Component = $$props.Component);
			if ('forwardMotionProps' in $$props) $$invalidate(6, forwardMotionProps = $$props.forwardMotionProps);
			if ('isStatic' in $$props) $$invalidate(3, isStatic = $$props.isStatic);
			if ('ref' in $$props) $$invalidate(7, ref = $$props.ref);
			if ('targetEl' in $$props) $$invalidate(8, targetEl = $$props.targetEl);
			if ('filteredProps' in $$props) $$invalidate(4, filteredProps = $$props.filteredProps);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*props, Component, forwardMotionProps*/ 69) {
				$$invalidate(4, filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps));
			}

			if ($$self.$$.dirty & /*targetEl*/ 256) {
				if (targetEl) {
					motion(targetEl);
				}
			}
		};

		return [
			props,
			visualState,
			Component,
			isStatic,
			filteredProps,
			motion,
			forwardMotionProps,
			ref,
			targetEl,
			slots,
			$$scope
		];
	}

	class UseRender extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$P, create_fragment$P, safe_not_equal, {
				props: 0,
				visualState: 1,
				Component: 2,
				forwardMotionProps: 6,
				isStatic: 3,
				ref: 7,
				targetEl: 8
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UseRender",
				options,
				id: create_fragment$P.name
			});
		}

		get props() {
			throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get visualState() {
			throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualState(value) {
			throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get Component() {
			throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set Component(value) {
			throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get forwardMotionProps() {
			throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set forwardMotionProps(value) {
			throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isStatic() {
			throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isStatic(value) {
			throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get ref() {
			throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set ref(value) {
			throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get targetEl() {
			throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set targetEl(value) {
			throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UseRender$1 = UseRender;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * Measure and return the element bounding box.
	 *
	 * We convert the box into an AxisBox2D to make it easier to work with each axis
	 * individually and programmatically.
	 *
	 * This function optionally accepts a transformPagePoint function which allows us to compensate
	 * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.
	 */
	function getBoundingBox(element, transformPagePoint) {
	    var box = element.getBoundingClientRect();
	    return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	//import { invariant } from 'hey-listen';

	function isCSSVariable(value) {
	    return typeof value === "string" && value.startsWith("var(--");
	}
	/**
	 * Parse Framer's special CSS variable format into a CSS token and a fallback.
	 *
	 * ```
	 * `var(--foo, #fff)` => [`--foo`, '#fff']
	 * ```
	 *
	 * @param current
	 */
	var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
	function parseCSSVariable(current) {
	    var match = cssVariableRegex.exec(current);
	    if (!match)
	        return [,];
	    var _a = __read(match, 3), token = _a[1], fallback = _a[2];
	    return [token, fallback];
	}
	function getVariableValue(current, element, depth) {
	    //invariant(depth <= maxDepth, "Max CSS variable fallback depth detected in property \"" + current + "\". This may indicate a circular fallback dependency.");
	    var _a = __read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];
	    // No CSS variable detected
	    if (!token)
	        return;
	    // Attempt to read this CSS variable off the element
	    var resolved = window.getComputedStyle(element).getPropertyValue(token);
	    if (resolved) {
	        return resolved.trim();
	    }
	    else if (isCSSVariable(fallback)) {
	        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.
	        return getVariableValue(fallback, element);
	    }
	    else {
	        return fallback;
	    }
	}
	/**
	 * Resolve CSS variables from
	 *
	 * @internal
	 */
	function resolveCSSVariables(visualElement, _a, transitionEnd) {
	    var _b;
	    var target = __rest(_a, []);
	    var element = visualElement.getInstance();
	    if (!(element instanceof HTMLElement))
	        return { target: target, transitionEnd: transitionEnd };
	    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`
	    // only if they change but I think this reads clearer and this isn't a performance-critical path.
	    if (transitionEnd) {
	        transitionEnd = __assign({}, transitionEnd);
	    }
	    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved
	    visualElement.forEachValue(function (value) {
	        var current = value.get();
	        if (!isCSSVariable(current))
	            return;
	        var resolved = getVariableValue(current, element);
	        if (resolved)
	            value.set(resolved);
	    });
	    // Cycle through every target property and resolve CSS variables. Currently
	    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`
	    for (var key in target) {
	        var current = target[key];
	        if (!isCSSVariable(current))
	            continue;
	        var resolved = getVariableValue(current, element);
	        if (!resolved)
	            continue;
	        // Clone target if it hasn't already been
	        target[key] = resolved;
	        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved
	        // CSS variable. This will ensure that after the animation the component will reflect
	        // changes in the value of the CSS variable.
	        if (transitionEnd)
	            (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : (transitionEnd[key] = current);
	    }
	    return { target: target, transitionEnd: transitionEnd };
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var positionalKeys = new Set([
	    "width",
	    "height",
	    "top",
	    "left",
	    "right",
	    "bottom",
	    "x",
	    "y",
	]);
	var isPositionalKey = function (key) { return positionalKeys.has(key); };
	var hasPositionalKey = function (target) {
	    return Object.keys(target).some(isPositionalKey);
	};
	var setAndResetVelocity = function (value, to) {
	    // Looks odd but setting it twice doesn't render, it'll just
	    // set both prev and current to the latest value
	    value.set(to, false);
	    value.set(to);
	};
	var isNumOrPxType = function (v) {
	    return v === number || v === px;
	};
	var BoundingBoxDimension;
	(function (BoundingBoxDimension) {
	    BoundingBoxDimension["width"] = "width";
	    BoundingBoxDimension["height"] = "height";
	    BoundingBoxDimension["left"] = "left";
	    BoundingBoxDimension["right"] = "right";
	    BoundingBoxDimension["top"] = "top";
	    BoundingBoxDimension["bottom"] = "bottom";
	})(BoundingBoxDimension || (BoundingBoxDimension = {}));
	var getPosFromMatrix = function (matrix, pos) {
	    return parseFloat(matrix.split(", ")[pos]);
	};
	var getTranslateFromMatrix = function (pos2, pos3) { return function (_bbox, _a) {
	    var transform = _a.transform;
	    if (transform === "none" || !transform)
	        return 0;
	    var matrix3d = transform.match(/^matrix3d\((.+)\)$/);
	    if (matrix3d) {
	        return getPosFromMatrix(matrix3d[1], pos3);
	    }
	    else {
	        var matrix = transform.match(/^matrix\((.+)\)$/);
	        if (matrix) {
	            return getPosFromMatrix(matrix[1], pos2);
	        }
	        else {
	            return 0;
	        }
	    }
	}; };
	var transformKeys = new Set(["x", "y", "z"]);
	var nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });
	function removeNonTranslationalTransform(visualElement) {
	    var removedTransforms = [];
	    nonTranslationalTransformKeys.forEach(function (key) {
	        var value = visualElement.getValue(key);
	        if (value !== undefined) {
	            removedTransforms.push([key, value.get()]);
	            value.set(key.startsWith("scale") ? 1 : 0);
	        }
	    });
	    // Apply changes to element before measurement
	    if (removedTransforms.length)
	        visualElement.syncRender();
	    return removedTransforms;
	}
	var positionalValues = {
	    // Dimensions
	    width: function (_a) {
	        var x = _a.x;
	        return x.max - x.min;
	    },
	    height: function (_a) {
	        var y = _a.y;
	        return y.max - y.min;
	    },
	    top: function (_bbox, _a) {
	        var top = _a.top;
	        return parseFloat(top);
	    },
	    left: function (_bbox, _a) {
	        var left = _a.left;
	        return parseFloat(left);
	    },
	    bottom: function (_a, _b) {
	        var y = _a.y;
	        var top = _b.top;
	        return parseFloat(top) + (y.max - y.min);
	    },
	    right: function (_a, _b) {
	        var x = _a.x;
	        var left = _b.left;
	        return parseFloat(left) + (x.max - x.min);
	    },
	    // Transform
	    x: getTranslateFromMatrix(4, 13),
	    y: getTranslateFromMatrix(5, 14),
	};
	var convertChangedValueTypes = function (target, visualElement, changedKeys) {
	    var originBbox = visualElement.measureViewportBox();
	    var element = visualElement.getInstance();
	    var elementComputedStyle = getComputedStyle(element);
	    var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;
	    var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform };
	    // If the element is currently set to display: "none", make it visible before
	    // measuring the target bounding box
	    if (display === "none") {
	        visualElement.setStaticValue("display", target.display || "block");
	    }
	    // Apply the latest values (as set in checkAndConvertChangedValueTypes)
	    visualElement.syncRender();
	    var targetBbox = visualElement.measureViewportBox();
	    changedKeys.forEach(function (key) {
	        // Restore styles to their **calculated computed style**, not their actual
	        // originally set style. This allows us to animate between equivalent pixel units.
	        var value = visualElement.getValue(key);
	        setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));
	        target[key] = positionalValues[key](targetBbox, elementComputedStyle);
	    });
	    return target;
	};
	var checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {
	    if (origin === void 0) { origin = {}; }
	    if (transitionEnd === void 0) { transitionEnd = {}; }
	    target = __assign({}, target);
	    transitionEnd = __assign({}, transitionEnd);
	    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
	    // We want to remove any transform values that could affect the element's bounding box before
	    // it's measured. We'll reapply these later.
	    var removedTransformValues = [];
	    var hasAttemptedToRemoveTransformValues = false;
	    var changedValueTypeKeys = [];
	    targetPositionalKeys.forEach(function (key) {
	        var value = visualElement.getValue(key);
	        if (!visualElement.hasValue(key))
	            return;
	        var from = origin[key];
	        var to = target[key];
	        var fromType = findDimensionValueType(from);
	        var toType;
	        // TODO: The current implementation of this basically throws an error
	        // if you try and do value conversion via keyframes. There's probably
	        // a way of doing this but the performance implications would need greater scrutiny,
	        // as it'd be doing multiple resize-remeasure operations.
	        if (isKeyframesTarget(to)) {
	            var numKeyframes = to.length;
	            for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {
	                if (!toType) {
	                    toType = findDimensionValueType(to[i]);
	                    //invariant(toType === fromType ||
	                    //    (isNumOrPxType(fromType) && isNumOrPxType(toType)), "Keyframes must be of the same dimension as the current value");
	                }
	                //else {
	                ///    invariant(findDimensionValueType(to[i]) === toType, "All keyframes must be of the same type");
	                //}
	            }
	        }
	        else {
	            toType = findDimensionValueType(to);
	        }
	        if (fromType !== toType) {
	            // If they're both just number or px, convert them both to numbers rather than
	            // relying on resize/remeasure to convert (which is wasteful in this situation)
	            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
	                var current = value.get();
	                if (typeof current === "string") {
	                    value.set(parseFloat(current));
	                }
	                if (typeof to === "string") {
	                    target[key] = parseFloat(to);
	                }
	                else if (Array.isArray(to) && toType === px) {
	                    target[key] = to.map(parseFloat);
	                }
	            }
	            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&
	                (toType === null || toType === void 0 ? void 0 : toType.transform) &&
	                (from === 0 || to === 0)) {
	                // If one or the other value is 0, it's safe to coerce it to the
	                // type of the other without measurement
	                if (from === 0) {
	                    value.set(toType.transform(from));
	                }
	                else {
	                    target[key] = fromType.transform(to);
	                }
	            }
	            else {
	                // If we're going to do value conversion via DOM measurements, we first
	                // need to remove non-positional transform values that could affect the bbox measurements.
	                if (!hasAttemptedToRemoveTransformValues) {
	                    removedTransformValues = removeNonTranslationalTransform(visualElement);
	                    hasAttemptedToRemoveTransformValues = true;
	                }
	                changedValueTypeKeys.push(key);
	                transitionEnd[key] =
	                    transitionEnd[key] !== undefined
	                        ? transitionEnd[key]
	                        : target[key];
	                setAndResetVelocity(value, to);
	            }
	        }
	    });
	    if (changedValueTypeKeys.length) {
	        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);
	        // If we removed transform values, reapply them before the next render
	        if (removedTransformValues.length) {
	            removedTransformValues.forEach(function (_a) {
	                var _b = __read(_a, 2), key = _b[0], value = _b[1];
	                visualElement.getValue(key).set(value);
	            });
	        }
	        // Reapply original values
	        visualElement.syncRender();
	        return { target: convertedTarget, transitionEnd: transitionEnd };
	    }
	    else {
	        return { target: target, transitionEnd: transitionEnd };
	    }
	};
	/**
	 * Convert value types for x/y/width/height/top/left/bottom/right
	 *
	 * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`
	 *
	 * @internal
	 */
	function unitConversion(visualElement, target, origin, transitionEnd) {
	    return hasPositionalKey(target)
	        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)
	        : { target: target, transitionEnd: transitionEnd };
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * Parse a DOM variant to make it animatable. This involves resolving CSS variables
	 * and ensuring animations like "20%" => "calc(50vw)" are performed in pixels.
	 */
	var parseDomVariant = function (visualElement, target, origin, transitionEnd) {
	    var resolved = resolveCSSVariables(visualElement, target, transitionEnd);
	    target = resolved.target;
	    transitionEnd = resolved.transitionEnd;
	    return unitConversion(visualElement, target, origin, transitionEnd);
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	function scrapeMotionValuesFromProps$1(props) {
	    var style = props.style;
	    var newValues = {};
	    for (var key in style) {
	        if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {
	            newValues[key] = style[key];
	        }
	    }
	    return newValues;
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	function renderHTML(element, _a) {
	    var style = _a.style, vars = _a.vars;
	    // Directly assign style into the Element's style prop. In tests Object.assign is the
	    // fastest way to assign styles.
	    Object.assign(element.style, style);
	    // Loop over any CSS variables and assign those.
	    for (var key in vars) {
	        element.style.setProperty(key, vars[key]);
	    }
	}

	/** 
	based on framer-motion@4.1.15,
	Copyright (c) 2018 Framer B.V.
	*/

	function getComputedStyle$1(element) {
	    return window.getComputedStyle(element);
	}
	var htmlConfig = {
	    treeType: "dom",
	    readValueFromInstance: function (domElement, key) {
	        if (isTransformProp(key)) {
	            var defaultType = getDefaultValueType(key);
	            return defaultType ? defaultType.default || 0 : 0;
	        }
	        else {
	            var computedStyle = getComputedStyle$1(domElement);
	            return ((isCSSVariable$1(key)
	                ? computedStyle.getPropertyValue(key)
	                : computedStyle[key]) || 0);
	        }
	    },
	    sortNodePosition: function (a, b) {
	        /**
	         * compareDocumentPosition returns a bitmask, by using the bitwise &
	         * we're returning true if 2 in that bitmask is set to true. 2 is set
	         * to true if b preceeds a.
	         */
	        return a.compareDocumentPosition(b) & 2 ? 1 : -1;
	    },
	    getBaseTarget: function (props, key) {
	        var _a;
	        return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];
	    },
	    measureViewportBox: function (element, _a) {
	        var transformPagePoint = _a.transformPagePoint;
	        return getBoundingBox(element, transformPagePoint);
	    },
	    /**
	     * Reset the transform on the current Element. This is called as part
	     * of a batched process across the entire layout tree. To remove this write
	     * cycle it'd be interesting to see if it's possible to "undo" all the current
	     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms
	     * works
	     */
	    resetTransform: function (element, domElement, props) {
	        var transformTemplate = props.transformTemplate;
	        domElement.style.transform = transformTemplate
	            ? transformTemplate({}, "")
	            : "none";
	        // Ensure that whatever happens next, we restore our transform on the next frame
	        element.scheduleRender();
	    },
	    restoreTransform: function (instance, mutableState) {
	        instance.style.transform = mutableState.style.transform;
	    },
	    removeValueFromRenderState: function (key, _a) {
	        var vars = _a.vars, style = _a.style;
	        delete vars[key];
	        delete style[key];
	    },
	    /**
	     * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`
	     * can be animated by Motion.
	     */
	    makeTargetAnimatable: function (element, _a, _b, isMounted) {
	        var transformValues = _b.transformValues;
	        if (isMounted === void 0) { isMounted = true; }
	        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, ["transition", "transitionEnd"]);
	        var origin = getOrigin(target, transition || {}, element);
	        /**
	         * If Framer has provided a function to convert `Color` etc value types, convert them
	         */
	        if (transformValues) {
	            if (transitionEnd)
	                transitionEnd = transformValues(transitionEnd);
	            if (target)
	                target = transformValues(target);
	            if (origin)
	                origin = transformValues(origin);
	        }
	        if (isMounted) {
	            checkTargetForNewValues(element, target, origin);
	            var parsed = parseDomVariant(element, target, origin, transitionEnd);
	            transitionEnd = parsed.transitionEnd;
	            target = parsed.target;
	        }
	        return __assign({ transition: transition,
	            transitionEnd: transitionEnd }, target);
	    },
	    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
	    build: function (element, renderState, latestValues, projection, layoutState, options, props) {
	        if (element.isVisible !== undefined) {
	            renderState.style.visibility = element.isVisible
	                ? "visible"
	                : "hidden";
	        }
	        var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;
	        buildHTMLStyles(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform
	            ? buildLayoutProjectionTransformOrigin
	            : undefined);
	    },
	    render: renderHTML,
	};
	var htmlVisualElement = visualElement(htmlConfig);

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	function scrapeMotionValuesFromProps(props) {
	    var newValues = scrapeMotionValuesFromProps$1(props);
	    for (var key in props) {
	        if (isMotionValue(props[key])) {
	            var targetKey = key === "x" || key === "y" ? "attr" + key.toUpperCase() : key;
	            newValues[targetKey] = props[key];
	        }
	    }
	    return newValues;
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
	var REPLACE_TEMPLATE = "$1-$2";
	/**
	 * Convert camelCase to dash-case properties.
	 */
	var camelToDash = function (str) {
	    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	/**
	 * A set of attribute names that are always read/written as camel case.
	 */
	var camelCaseAttributes = new Set([
	    "baseFrequency",
	    "diffuseConstant",
	    "kernelMatrix",
	    "kernelUnitLength",
	    "keySplines",
	    "keyTimes",
	    "limitingConeAngle",
	    "markerHeight",
	    "markerWidth",
	    "numOctaves",
	    "targetX",
	    "targetY",
	    "surfaceScale",
	    "specularConstant",
	    "specularExponent",
	    "stdDeviation",
	    "tableValues",
	    "viewBox",
	]);

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	function renderSVG(element, renderState) {
	    renderHTML(element, renderState);
	    for (var key in renderState.attrs) {
	        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
	    }
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var svgVisualElement = visualElement(__assign(__assign({}, htmlConfig), { getBaseTarget: function (props, key) {
	        return props[key];
	    },
	    readValueFromInstance: function (domElement, key) {
	        var _a;
	        if (isTransformProp(key)) {
	            return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;
	        }
	        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
	        return domElement.getAttribute(key);
	    },
	    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,
	    build: function (_element, renderState, latestValues, projection, layoutState, options, props) {
	        var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;
	        buildSVGAttrs(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform
	            ? buildLayoutProjectionTransformOrigin
	            : undefined);
	    }, render: renderSVG }));

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/


	var createDomVisualElement = function (Component, options) {
	   
	    return Component === "SVG"
	        ? svgVisualElement(options, { enableHardwareAcceleration: false })
	        : htmlVisualElement(options, { enableHardwareAcceleration: true });
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var svgMotionConfig = {
	        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,
	        createRenderState: createSvgRenderState,
	        onMount: function (props, instance, _a) {
	            var renderState = _a.renderState, latestValues = _a.latestValues;
	            try {
	                renderState.dimensions =
	                    typeof instance.getBBox ===
	                        "function"
	                        ? instance.getBBox()
	                        : instance.getBoundingClientRect();
	            }
	            catch (e) {
	                // Most likely trying to measure an unrendered element under Firefox
	                renderState.dimensions = {
	                    x: 0,
	                    y: 0,
	                    width: 0,
	                    height: 0,
	                };
	            }
	            if (isPath(instance)) {
	                renderState.totalPathLength = instance.getTotalLength();
	            }
	            buildSVGAttrs(renderState, latestValues, undefined, undefined, { enableHardwareAcceleration: false }, props.transformTemplate);
	            // TODO: Replace with direct assignment
	            renderSVG(instance, renderState);
	        },
	    };
	function isPath(element) {
	    return element.tagName === "path";
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	var htmlMotionConfig = {
	        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
	        createRenderState: createHtmlRenderState,   
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/


	function getCurrentTreeVariants(props, context) {
	    if (checkIfControllingVariants(props)) {
	        var initial = props.initial, animate = props.animate;
	        return {
	            initial: initial === false || isVariantLabel(initial)
	                ? initial
	                : undefined,
	            animate: isVariantLabel(animate) ? animate : undefined,
	        };
	    }
	    return props.inherit !== false ? (context||{}) : {};
	}

	/* node_modules/svelte-motion/src/context/MotionContext/UseCreateMotionContext.svelte generated by Svelte v4.2.10 */
	const get_default_slot_changes$f = dirty => ({ value: dirty & /*value*/ 1 });
	const get_default_slot_context$f = ctx => ({ value: /*value*/ ctx[0] });

	function create_fragment$O(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[9].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context$f);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, value*/ 257)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[8],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, get_default_slot_changes$f),
							get_default_slot_context$f
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$O.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$O($$self, $$props, $$invalidate) {
		let $mc;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UseCreateMotionContext', slots, ['default']);
		let { props, isStatic, isCustom } = $$props;
		let mc = getContext(MotionContext) || MotionContext(isCustom);
		validate_store(mc, 'mc');
		component_subscribe($$self, mc, value => $$invalidate(7, $mc = value));
		let { initial, animate } = getCurrentTreeVariants(props, get_store_value(mc));

		const variantLabelsAsDependency = prop => {
			return Array.isArray(prop) ? prop.join(" ") : prop;
		};

		const memo = () => {
			return { initial, animate };
		};

		/**
	 * Only break memoisation in static mode
	 */
		let value = memo();

		$$self.$$.on_mount.push(function () {
			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<UseCreateMotionContext> was created without expected prop 'props'");
			}

			if (isStatic === undefined && !('isStatic' in $$props || $$self.$$.bound[$$self.$$.props['isStatic']])) {
				console.warn("<UseCreateMotionContext> was created without expected prop 'isStatic'");
			}

			if (isCustom === undefined && !('isCustom' in $$props || $$self.$$.bound[$$self.$$.props['isCustom']])) {
				console.warn("<UseCreateMotionContext> was created without expected prop 'isCustom'");
			}
		});

		const writable_props = ['props', 'isStatic', 'isCustom'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UseCreateMotionContext> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('props' in $$props) $$invalidate(2, props = $$props.props);
			if ('isStatic' in $$props) $$invalidate(3, isStatic = $$props.isStatic);
			if ('isCustom' in $$props) $$invalidate(4, isCustom = $$props.isCustom);
			if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			getContext,
			get: get_store_value,
			MotionContext,
			getCurrentTreeVariants,
			props,
			isStatic,
			isCustom,
			mc,
			initial,
			animate,
			variantLabelsAsDependency,
			memo,
			value,
			$mc
		});

		$$self.$inject_state = $$props => {
			if ('props' in $$props) $$invalidate(2, props = $$props.props);
			if ('isStatic' in $$props) $$invalidate(3, isStatic = $$props.isStatic);
			if ('isCustom' in $$props) $$invalidate(4, isCustom = $$props.isCustom);
			if ('mc' in $$props) $$invalidate(1, mc = $$props.mc);
			if ('initial' in $$props) $$invalidate(5, initial = $$props.initial);
			if ('animate' in $$props) $$invalidate(6, animate = $$props.animate);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*props, $mc*/ 132) {
				$$invalidate(5, { initial, animate } = getCurrentTreeVariants(props, $mc), initial, (($$invalidate(6, animate), $$invalidate(2, props)), $$invalidate(7, $mc)));
			}

			if ($$self.$$.dirty & /*isStatic, initial, animate*/ 104) {
				if (isStatic) {
					$$invalidate(0, value = memo(variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)));
				}
			}
		};

		return [value, mc, props, isStatic, isCustom, initial, animate, $mc, $$scope, slots];
	}

	class UseCreateMotionContext extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$O, create_fragment$O, safe_not_equal, { props: 2, isStatic: 3, isCustom: 4 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UseCreateMotionContext",
				options,
				id: create_fragment$O.name
			});
		}

		get props() {
			throw new Error("<UseCreateMotionContext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<UseCreateMotionContext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isStatic() {
			throw new Error("<UseCreateMotionContext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isStatic(value) {
			throw new Error("<UseCreateMotionContext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isCustom() {
			throw new Error("<UseCreateMotionContext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isCustom(value) {
			throw new Error("<UseCreateMotionContext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UseCreateMotionContext$1 = UseCreateMotionContext;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself
	 *
	 * TODO: Remove and move to library
	 *
	 * @internal
	 */
	function resolveMotionValue(value) {
	    var unwrappedValue = isMotionValue(value) ? value.get() : value;
	    return isCustomValue(unwrappedValue)
	        ? unwrappedValue.toValue()
	        : unwrappedValue;
	}

	/* node_modules/svelte-motion/src/motion/utils/UseVisualState.svelte generated by Svelte v4.2.10 */
	const get_default_slot_changes$e = dirty => ({ state: dirty & /*state*/ 1 });
	const get_default_slot_context$e = ctx => ({ state: /*state*/ ctx[0] });

	function create_fragment$N(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[10].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], get_default_slot_context$e);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, state*/ 513)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[9],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, get_default_slot_changes$e),
							get_default_slot_context$e
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$N.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	const makeState = ({ scrapeMotionValuesFromProps, createRenderState, onMount }, props, context, presenceContext) => {
		const state = {
			latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),
			renderState: createRenderState()
		};

		if (onMount) {
			state.mount = instance => onMount(props, instance, state);
		}

		return state;
	};

	function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
		const values = {};
		const blockInitialAnimation = presenceContext?.initial === false;
		const motionValues = scrapeMotionValues(props);

		for (const key in motionValues) {
			values[key] = resolveMotionValue(motionValues[key]);
		}

		let { initial, animate } = props;
		const isControllingVariants = checkIfControllingVariants(props);
		const isVariantNode = checkIfVariantNode(props);

		if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {
			initial !== null && initial !== void 0
			? initial
			: initial = context.initial;

			animate !== null && animate !== void 0
			? animate
			: animate = context.animate;
		}

		const variantToSet = blockInitialAnimation || initial === false
		? animate
		: initial;

		if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
			const list = Array.isArray(variantToSet)
			? variantToSet
			: [variantToSet];

			list.forEach(definition => {
				const resolved = resolveVariantFromProps(props, definition);
				if (!resolved) return;
				const { transitionEnd, transition, ...target } = resolved;
				for (const key in target) values[key] = target[key];
				for (const key in transitionEnd) values[key] = transitionEnd[key];
			});
		}

		return values;
	}

	function instance$N($$self, $$props, $$invalidate) {
		let $presenceContext;
		let $context;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UseVisualState', slots, ['default']);
		let { config, props, isStatic, isCustom } = $$props;
		const context = getContext(MotionContext) || MotionContext(isCustom);
		validate_store(context, 'context');
		component_subscribe($$self, context, value => $$invalidate(8, $context = value));
		const presenceContext = getContext(PresenceContext) || PresenceContext(isCustom);
		validate_store(presenceContext, 'presenceContext');
		component_subscribe($$self, presenceContext, value => $$invalidate(7, $presenceContext = value));
		let state = makeState(config, props, get_store_value(context), get_store_value(presenceContext));
		const ms = makeState;

		$$self.$$.on_mount.push(function () {
			if (config === undefined && !('config' in $$props || $$self.$$.bound[$$self.$$.props['config']])) {
				console.warn("<UseVisualState> was created without expected prop 'config'");
			}

			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<UseVisualState> was created without expected prop 'props'");
			}

			if (isStatic === undefined && !('isStatic' in $$props || $$self.$$.bound[$$self.$$.props['isStatic']])) {
				console.warn("<UseVisualState> was created without expected prop 'isStatic'");
			}

			if (isCustom === undefined && !('isCustom' in $$props || $$self.$$.bound[$$self.$$.props['isCustom']])) {
				console.warn("<UseVisualState> was created without expected prop 'isCustom'");
			}
		});

		const writable_props = ['config', 'props', 'isStatic', 'isCustom'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UseVisualState> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('config' in $$props) $$invalidate(3, config = $$props.config);
			if ('props' in $$props) $$invalidate(4, props = $$props.props);
			if ('isStatic' in $$props) $$invalidate(5, isStatic = $$props.isStatic);
			if ('isCustom' in $$props) $$invalidate(6, isCustom = $$props.isCustom);
			if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			resolveMotionValue,
			checkIfControllingVariants,
			checkIfVariantNode,
			resolveVariantFromProps,
			isAnimationControls,
			makeState,
			makeLatestValues,
			getContext,
			get: get_store_value,
			PresenceContext,
			MotionContext,
			config,
			props,
			isStatic,
			isCustom,
			context,
			presenceContext,
			state,
			ms,
			$presenceContext,
			$context
		});

		$$self.$inject_state = $$props => {
			if ('config' in $$props) $$invalidate(3, config = $$props.config);
			if ('props' in $$props) $$invalidate(4, props = $$props.props);
			if ('isStatic' in $$props) $$invalidate(5, isStatic = $$props.isStatic);
			if ('isCustom' in $$props) $$invalidate(6, isCustom = $$props.isCustom);
			if ('state' in $$props) $$invalidate(0, state = $$props.state);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*isStatic, config, props, $context, $presenceContext*/ 440) {
				if (isStatic) {
					$$invalidate(0, state = ms(config, props, $context, $presenceContext));
				}
			}
		};

		return [
			state,
			context,
			presenceContext,
			config,
			props,
			isStatic,
			isCustom,
			$presenceContext,
			$context,
			$$scope,
			slots
		];
	}

	class UseVisualState extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$N, create_fragment$N, safe_not_equal, {
				config: 3,
				props: 4,
				isStatic: 5,
				isCustom: 6
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UseVisualState",
				options,
				id: create_fragment$N.name
			});
		}

		get config() {
			throw new Error("<UseVisualState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set config(value) {
			throw new Error("<UseVisualState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get props() {
			throw new Error("<UseVisualState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<UseVisualState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isStatic() {
			throw new Error("<UseVisualState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isStatic(value) {
			throw new Error("<UseVisualState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isCustom() {
			throw new Error("<UseVisualState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isCustom(value) {
			throw new Error("<UseVisualState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UseVisualState$1 = UseVisualState;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	function isRefObject(ref) {
	    return (typeof ref === "object" &&
	        Object.prototype.hasOwnProperty.call(ref, "current"));
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/


	/**
	 * Creates a ref function that, when called, hydrates the provided
	 * external ref and VisualElement.
	 */
	function useMotionRef(visualState, visualElement, externalRef) {
	    return function (instance) {
	        var _a;
	        instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));
	        if (visualElement) {
	            instance
	                ? visualElement.mount(instance)
	                : visualElement.unmount();
	        }
	        if (externalRef) {
	            if (typeof externalRef === "function") {
	                externalRef(instance);
	            }
	            else if (isRefObject(externalRef)) {
	                externalRef.current = instance;
	            }
	        }
	    }
	}

	/* node_modules/svelte-motion/src/motion/Motion.svelte generated by Svelte v4.2.10 */

	function get_each_context$4(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[21] = list[i];
		return child_ctx;
	}

	const get_default_slot_changes$d = dirty => ({
		motion: dirty & /*motion*/ 16777216,
		props: dirty & /*renderProps*/ 33554432
	});

	const get_default_slot_context$d = ctx => ({
		motion: /*motion*/ ctx[24],
		props: /*renderProps*/ ctx[25]
	});

	// (193:24) <UseRender                             {Component}                             props={motionProps}                             ref={useMotionRef(visualState, context.visualElement, externalRef)}                             {visualState}                             {isStatic}                             {forwardMotionProps}                             let:motion                             let:props={renderProps}>
	function create_default_slot_6$2(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[14].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], get_default_slot_context$d);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, motion, renderProps*/ 50364416)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[15],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, get_default_slot_changes$d),
							get_default_slot_context$d
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_6$2.name,
			type: "slot",
			source: "(193:24) <UseRender                             {Component}                             props={motionProps}                             ref={useMotionRef(visualState, context.visualElement, externalRef)}                             {visualState}                             {isStatic}                             {forwardMotionProps}                             let:motion                             let:props={renderProps}>",
			ctx
		});

		return block;
	}

	// (192:20) <MotionContextProvider value={context} {isCustom}>
	function create_default_slot_5$2(ctx) {
		let userender;
		let current;

		userender = new UseRender$1({
				props: {
					Component: /*Component*/ ctx[6],
					props: /*motionProps*/ ctx[4],
					ref: useMotionRef(/*visualState*/ ctx[18], /*context*/ ctx[17].visualElement, /*externalRef*/ ctx[1]),
					visualState: /*visualState*/ ctx[18],
					isStatic: /*isStatic*/ ctx[3],
					forwardMotionProps: /*forwardMotionProps*/ ctx[0],
					$$slots: {
						default: [
							create_default_slot_6$2,
							({ motion, props: renderProps }) => ({ 24: motion, 25: renderProps }),
							({ motion, props: renderProps }) => (motion ? 16777216 : 0) | (renderProps ? 33554432 : 0)
						]
					},
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(userender.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(userender, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const userender_changes = {};
				if (dirty & /*motionProps*/ 16) userender_changes.props = /*motionProps*/ ctx[4];
				if (dirty & /*visualState, context, externalRef*/ 393218) userender_changes.ref = useMotionRef(/*visualState*/ ctx[18], /*context*/ ctx[17].visualElement, /*externalRef*/ ctx[1]);
				if (dirty & /*visualState*/ 262144) userender_changes.visualState = /*visualState*/ ctx[18];
				if (dirty & /*isStatic*/ 8) userender_changes.isStatic = /*isStatic*/ ctx[3];
				if (dirty & /*forwardMotionProps*/ 1) userender_changes.forwardMotionProps = /*forwardMotionProps*/ ctx[0];

				if (dirty & /*$$scope, motion, renderProps*/ 50364416) {
					userender_changes.$$scope = { dirty, ctx };
				}

				userender.$set(userender_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(userender.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(userender.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(userender, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_5$2.name,
			type: "slot",
			source: "(192:20) <MotionContextProvider value={context} {isCustom}>",
			ctx
		});

		return block;
	}

	// (206:20) {#if mounted}
	function create_if_block$j(ctx) {
		let each_blocks = [];
		let each_1_lookup = new Map();
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like_dev(/*_features*/ ctx[20]);
		const get_key = ctx => /*feat*/ ctx[21].key;
		validate_each_keys(ctx, each_value, get_each_context$4, get_key);

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$4(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$4(key, child_ctx));
		}

		const block = {
			c: function create() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m: function mount(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert_dev(target, each_1_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty & /*_features, isCustom*/ 1048608) {
					each_value = ensure_array_like_dev(/*_features*/ ctx[20]);
					group_outros();
					validate_each_keys(ctx, each_value, get_each_context$4, get_key);
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$4, each_1_anchor, get_each_context$4);
					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(each_1_anchor);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d(detaching);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$j.name,
			type: "if",
			source: "(206:20) {#if mounted}",
			ctx
		});

		return block;
	}

	// (207:24) {#each _features as feat (feat.key)}
	function create_each_block$4(key_1, ctx) {
		let first;
		let switch_instance;
		let switch_instance_anchor;
		let current;
		var switch_value = /*feat*/ ctx[21].Component;

		function switch_props(ctx, dirty) {
			return {
				props: {
					props: /*feat*/ ctx[21].props,
					visualElement: /*feat*/ ctx[21].visualElement,
					isCustom: /*isCustom*/ ctx[5]
				},
				$$inline: true
			};
		}

		if (switch_value) {
			switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
		}

		const block = {
			key: key_1,
			first: null,
			c: function create() {
				first = empty();
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
				this.first = first;
			},
			m: function mount(target, anchor) {
				insert_dev(target, first, anchor);
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert_dev(target, switch_instance_anchor, anchor);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty & /*_features*/ 1048576 && switch_value !== (switch_value = /*feat*/ ctx[21].Component)) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = {};
					if (dirty & /*_features*/ 1048576) switch_instance_changes.props = /*feat*/ ctx[21].props;
					if (dirty & /*_features*/ 1048576) switch_instance_changes.visualElement = /*feat*/ ctx[21].visualElement;
					switch_instance.$set(switch_instance_changes);
				}
			},
			i: function intro(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(first);
					detach_dev(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$4.name,
			type: "each",
			source: "(207:24) {#each _features as feat (feat.key)}",
			ctx
		});

		return block;
	}

	// (188:16) <UseFeatures                     visualElement={setContext(context, visualElement)}                     props={motionProps}                     let:features={_features}>
	function create_default_slot_4$2(ctx) {
		let motioncontextprovider;
		let t;
		let if_block_anchor;
		let current;

		motioncontextprovider = new MotionContextProvider$1({
				props: {
					value: /*context*/ ctx[17],
					isCustom: /*isCustom*/ ctx[5],
					$$slots: { default: [create_default_slot_5$2] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		let if_block = /*mounted*/ ctx[2] && create_if_block$j(ctx);

		const block = {
			c: function create() {
				create_component(motioncontextprovider.$$.fragment);
				t = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				mount_component(motioncontextprovider, target, anchor);
				insert_dev(target, t, anchor);
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const motioncontextprovider_changes = {};
				if (dirty & /*context*/ 131072) motioncontextprovider_changes.value = /*context*/ ctx[17];

				if (dirty & /*$$scope, motionProps, visualState, context, externalRef, isStatic, forwardMotionProps*/ 426011) {
					motioncontextprovider_changes.$$scope = { dirty, ctx };
				}

				motioncontextprovider.$set(motioncontextprovider_changes);

				if (/*mounted*/ ctx[2]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*mounted*/ 4) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$j(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(motioncontextprovider.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(motioncontextprovider.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
					detach_dev(if_block_anchor);
				}

				destroy_component(motioncontextprovider, detaching);
				if (if_block) if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_4$2.name,
			type: "slot",
			source: "(188:16) <UseFeatures                     visualElement={setContext(context, visualElement)}                     props={motionProps}                     let:features={_features}>",
			ctx
		});

		return block;
	}

	// (181:12) <UseVisualElement                 {Component}                 {visualState}                 {createVisualElement}                 props={motionProps}                 {isCustom}                 let:visualElement>
	function create_default_slot_3$4(ctx) {
		let usefeatures;
		let current;

		usefeatures = new UseFeatures$1({
				props: {
					visualElement: /*setContext*/ ctx[10](/*context*/ ctx[17], /*visualElement*/ ctx[19]),
					props: /*motionProps*/ ctx[4],
					$$slots: {
						default: [
							create_default_slot_4$2,
							({ features: _features }) => ({ 20: _features }),
							({ features: _features }) => _features ? 1048576 : 0
						]
					},
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(usefeatures.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(usefeatures, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const usefeatures_changes = {};
				if (dirty & /*context, visualElement*/ 655360) usefeatures_changes.visualElement = /*setContext*/ ctx[10](/*context*/ ctx[17], /*visualElement*/ ctx[19]);
				if (dirty & /*motionProps*/ 16) usefeatures_changes.props = /*motionProps*/ ctx[4];

				if (dirty & /*$$scope, _features, mounted, context, motionProps, visualState, externalRef, isStatic, forwardMotionProps*/ 1474591) {
					usefeatures_changes.$$scope = { dirty, ctx };
				}

				usefeatures.$set(usefeatures_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(usefeatures.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(usefeatures.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(usefeatures, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_3$4.name,
			type: "slot",
			source: "(181:12) <UseVisualElement                 {Component}                 {visualState}                 {createVisualElement}                 props={motionProps}                 {isCustom}                 let:visualElement>",
			ctx
		});

		return block;
	}

	// (175:8) <UseVisualState             config={visualStateConfig}             props={motionProps}             {isStatic}             {isCustom}             let:state={visualState}>
	function create_default_slot_2$4(ctx) {
		let usevisualelement;
		let current;

		usevisualelement = new UseVisualElement$1({
				props: {
					Component: /*Component*/ ctx[6],
					visualState: /*visualState*/ ctx[18],
					createVisualElement: /*createVisualElement*/ ctx[7],
					props: /*motionProps*/ ctx[4],
					isCustom: /*isCustom*/ ctx[5],
					$$slots: {
						default: [
							create_default_slot_3$4,
							({ visualElement }) => ({ 19: visualElement }),
							({ visualElement }) => visualElement ? 524288 : 0
						]
					},
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(usevisualelement.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(usevisualelement, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const usevisualelement_changes = {};
				if (dirty & /*visualState*/ 262144) usevisualelement_changes.visualState = /*visualState*/ ctx[18];
				if (dirty & /*motionProps*/ 16) usevisualelement_changes.props = /*motionProps*/ ctx[4];

				if (dirty & /*$$scope, context, visualElement, motionProps, mounted, visualState, externalRef, isStatic, forwardMotionProps*/ 950303) {
					usevisualelement_changes.$$scope = { dirty, ctx };
				}

				usevisualelement.$set(usevisualelement_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(usevisualelement.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(usevisualelement.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(usevisualelement, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_2$4.name,
			type: "slot",
			source: "(175:8) <UseVisualState             config={visualStateConfig}             props={motionProps}             {isStatic}             {isCustom}             let:state={visualState}>",
			ctx
		});

		return block;
	}

	// (174:4) <UseCreateMotionContext props={motionProps} {isStatic} let:value={context} {isCustom}>
	function create_default_slot_1$6(ctx) {
		let usevisualstate;
		let current;

		usevisualstate = new UseVisualState$1({
				props: {
					config: /*visualStateConfig*/ ctx[8],
					props: /*motionProps*/ ctx[4],
					isStatic: /*isStatic*/ ctx[3],
					isCustom: /*isCustom*/ ctx[5],
					$$slots: {
						default: [
							create_default_slot_2$4,
							({ state: visualState }) => ({ 18: visualState }),
							({ state: visualState }) => visualState ? 262144 : 0
						]
					},
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(usevisualstate.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(usevisualstate, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const usevisualstate_changes = {};
				if (dirty & /*motionProps*/ 16) usevisualstate_changes.props = /*motionProps*/ ctx[4];
				if (dirty & /*isStatic*/ 8) usevisualstate_changes.isStatic = /*isStatic*/ ctx[3];

				if (dirty & /*$$scope, visualState, motionProps, context, mounted, externalRef, isStatic, forwardMotionProps*/ 426015) {
					usevisualstate_changes.$$scope = { dirty, ctx };
				}

				usevisualstate.$set(usevisualstate_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(usevisualstate.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(usevisualstate.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(usevisualstate, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_1$6.name,
			type: "slot",
			source: "(174:4) <UseCreateMotionContext props={motionProps} {isStatic} let:value={context} {isCustom}>",
			ctx
		});

		return block;
	}

	// (173:0) <ScaleCorrectionProvider {isCustom}>
	function create_default_slot$i(ctx) {
		let usecreatemotioncontext;
		let current;

		usecreatemotioncontext = new UseCreateMotionContext$1({
				props: {
					props: /*motionProps*/ ctx[4],
					isStatic: /*isStatic*/ ctx[3],
					isCustom: /*isCustom*/ ctx[5],
					$$slots: {
						default: [
							create_default_slot_1$6,
							({ value: context }) => ({ 17: context }),
							({ value: context }) => context ? 131072 : 0
						]
					},
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(usecreatemotioncontext.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(usecreatemotioncontext, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const usecreatemotioncontext_changes = {};
				if (dirty & /*motionProps*/ 16) usecreatemotioncontext_changes.props = /*motionProps*/ ctx[4];
				if (dirty & /*isStatic*/ 8) usecreatemotioncontext_changes.isStatic = /*isStatic*/ ctx[3];

				if (dirty & /*$$scope, motionProps, isStatic, context, mounted, externalRef, forwardMotionProps*/ 163871) {
					usecreatemotioncontext_changes.$$scope = { dirty, ctx };
				}

				usecreatemotioncontext.$set(usecreatemotioncontext_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(usecreatemotioncontext.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(usecreatemotioncontext.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(usecreatemotioncontext, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$i.name,
			type: "slot",
			source: "(173:0) <ScaleCorrectionProvider {isCustom}>",
			ctx
		});

		return block;
	}

	function create_fragment$M(ctx) {
		let scalecorrectionprovider;
		let current;

		scalecorrectionprovider = new ScaleCorrectionProvider$1({
				props: {
					isCustom: /*isCustom*/ ctx[5],
					$$slots: { default: [create_default_slot$i] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(scalecorrectionprovider.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(scalecorrectionprovider, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const scalecorrectionprovider_changes = {};

				if (dirty & /*$$scope, motionProps, isStatic, mounted, externalRef, forwardMotionProps*/ 32799) {
					scalecorrectionprovider_changes.$$scope = { dirty, ctx };
				}

				scalecorrectionprovider.$set(scalecorrectionprovider_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(scalecorrectionprovider.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(scalecorrectionprovider.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(scalecorrectionprovider, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$M.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$M($$self, $$props, $$invalidate) {
		let motionProps;
		let isStatic;
		const omit_props_names = ["isSVG","forwardMotionProps","externalRef","targetEl"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let $a;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Motion', slots, ['default']);
		let { isSVG = false, forwardMotionProps = false, externalRef = undefined, targetEl = undefined } = $$props;
		const isCustom = targetEl;
		let Component = isSVG ? "SVG" : "DOM";
		let createVisualElement = createDomVisualElement;
		let visualStateConfig = isSVG ? svgMotionConfig : htmlMotionConfig;

		/**
	 * If a component is static, we only visually update it as a
	 * result of a React re-render, rather than any interactions or animations.
	 * If this component or any ancestor is static, we disable hardware acceleration
	 * and don't load any additional functionality.
	 */
		const a = getContext(MotionConfigContext) || MotionConfigContext(isCustom);

		validate_store(a, 'a');
		component_subscribe($$self, a, value => $$invalidate(13, $a = value));
		let mounted = false;

		const setContext = (c, v) => {
			c.visualElement = v;
			return v;
		};

		onMount(() => $$invalidate(2, mounted = true));

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('isSVG' in $$new_props) $$invalidate(11, isSVG = $$new_props.isSVG);
			if ('forwardMotionProps' in $$new_props) $$invalidate(0, forwardMotionProps = $$new_props.forwardMotionProps);
			if ('externalRef' in $$new_props) $$invalidate(1, externalRef = $$new_props.externalRef);
			if ('targetEl' in $$new_props) $$invalidate(12, targetEl = $$new_props.targetEl);
			if ('$$scope' in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			MotionConfigContext,
			UseVisualElement: UseVisualElement$1,
			UseFeatures: UseFeatures$1,
			MotionContextProvider: MotionContextProvider$1,
			getContext,
			onMount,
			UseRender: UseRender$1,
			createDomVisualElement,
			svgMotionConfig,
			htmlMotionConfig,
			UseCreateMotionContext: UseCreateMotionContext$1,
			UseVisualState: UseVisualState$1,
			useMotionRef,
			ScaleCorrectionProvider: ScaleCorrectionProvider$1,
			isSVG,
			forwardMotionProps,
			externalRef,
			targetEl,
			isCustom,
			Component,
			createVisualElement,
			visualStateConfig,
			a,
			mounted,
			setContext,
			isStatic,
			motionProps,
			$a
		});

		$$self.$inject_state = $$new_props => {
			if ('isSVG' in $$props) $$invalidate(11, isSVG = $$new_props.isSVG);
			if ('forwardMotionProps' in $$props) $$invalidate(0, forwardMotionProps = $$new_props.forwardMotionProps);
			if ('externalRef' in $$props) $$invalidate(1, externalRef = $$new_props.externalRef);
			if ('targetEl' in $$props) $$invalidate(12, targetEl = $$new_props.targetEl);
			if ('Component' in $$props) $$invalidate(6, Component = $$new_props.Component);
			if ('createVisualElement' in $$props) $$invalidate(7, createVisualElement = $$new_props.createVisualElement);
			if ('visualStateConfig' in $$props) $$invalidate(8, visualStateConfig = $$new_props.visualStateConfig);
			if ('mounted' in $$props) $$invalidate(2, mounted = $$new_props.mounted);
			if ('isStatic' in $$props) $$invalidate(3, isStatic = $$new_props.isStatic);
			if ('motionProps' in $$props) $$invalidate(4, motionProps = $$new_props.motionProps);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			$$invalidate(4, motionProps = $$restProps); /*{
	    initial,
	    style,
	    transformTemplate,
	    transformValues,
	    //AnimationProps
	    animate,
	    exit,
	    variants,
	    transition,
	    //VisualElementLifecycles
	    onViewportBoxUpdate,
	    onBeforeLayoutMeasure,
	    onLayoutMeasure,
	    onUpdate,
	    onAnimationStart,
	    onAnimationComplete,
	    onLayoutAnimationComplete,
	    //GestureHandlers
	    // PanHandlers
	    onPan,
	    onPanStart,
	    onPanSessionStart,
	    onPanEnd,
	    // TapHandlers
	    onTap,
	    onTapStart,
	    onTapCancel,
	    whileTap,
	    //HoverHandlers
	    whileHover,
	    onHoverStart,
	    onHoverEnd,
	    //FocusHandlers
	    whileFocus,
	    //DraggableProps
	    drag,
	    whileDrag,
	    dragDirectionLock,
	    dragPropagation,
	    dragConstraints,
	    dragElastic,
	    dragMomentum,
	    dragTransition,
	    dragControls,
	    dragListener,
	    onMeasureDragConstraints,
	    _dragX,
	    _dragY,
	    //DragHandlers
	    onDragStart,
	    onDragEnd,
	    onDrag,
	    onDirectionLock,
	    onDragTransitionEnd,
	    // LayoutProps
	    layout,
	    layoutId,
	    //MotionAdvancedProps
	    custom,
	    inherit,
	    ...(isSVG ? $$restProps : {}),
	};*/

			if ($$self.$$.dirty & /*$a*/ 8192) {
				$$invalidate(3, { isStatic } = $a || {}, isStatic);
			}
		};

		return [
			forwardMotionProps,
			externalRef,
			mounted,
			isStatic,
			motionProps,
			isCustom,
			Component,
			createVisualElement,
			visualStateConfig,
			a,
			setContext,
			isSVG,
			targetEl,
			$a,
			slots,
			$$scope
		];
	}

	class Motion extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$M, create_fragment$M, safe_not_equal, {
				isSVG: 11,
				forwardMotionProps: 0,
				externalRef: 1,
				targetEl: 12
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Motion",
				options,
				id: create_fragment$M.name
			});
		}

		get isSVG() {
			throw new Error("<Motion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isSVG(value) {
			throw new Error("<Motion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get forwardMotionProps() {
			throw new Error("<Motion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set forwardMotionProps(value) {
			throw new Error("<Motion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get externalRef() {
			throw new Error("<Motion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set externalRef(value) {
			throw new Error("<Motion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get targetEl() {
			throw new Error("<Motion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set targetEl(value) {
			throw new Error("<Motion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var Motion$1 = Motion;

	/* node_modules/svelte-motion/src/events/UseDomEvent.svelte generated by Svelte v4.2.10 */

	function create_fragment$L(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[5].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[4],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$L.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function addDomEvent(target, eventName, handler, options) {
		target.addEventListener(eventName, handler, options);

		return function () {
			return target.removeEventListener(eventName, handler, options);
		};
	}

	function instance$L($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UseDomEvent', slots, ['default']);
		let { ref, eventName, handler = undefined, options = undefined } = $$props;

		let cleanup = () => {
			
		};

		const effect = () => {
			cleanup();

			if (!ref) {
				return () => {
					
				};
			}

			const element = ref.current;

			if (handler && element) {
				return addDomEvent(element, eventName, handler, options);
			}

			return () => {
				
			};
		};

		onDestroy(cleanup);

		$$self.$$.on_mount.push(function () {
			if (ref === undefined && !('ref' in $$props || $$self.$$.bound[$$self.$$.props['ref']])) {
				console.warn("<UseDomEvent> was created without expected prop 'ref'");
			}

			if (eventName === undefined && !('eventName' in $$props || $$self.$$.bound[$$self.$$.props['eventName']])) {
				console.warn("<UseDomEvent> was created without expected prop 'eventName'");
			}
		});

		const writable_props = ['ref', 'eventName', 'handler', 'options'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UseDomEvent> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
			if ('eventName' in $$props) $$invalidate(1, eventName = $$props.eventName);
			if ('handler' in $$props) $$invalidate(2, handler = $$props.handler);
			if ('options' in $$props) $$invalidate(3, options = $$props.options);
			if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			addDomEvent,
			onDestroy,
			ref,
			eventName,
			handler,
			options,
			cleanup,
			effect
		});

		$$self.$inject_state = $$props => {
			if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
			if ('eventName' in $$props) $$invalidate(1, eventName = $$props.eventName);
			if ('handler' in $$props) $$invalidate(2, handler = $$props.handler);
			if ('options' in $$props) $$invalidate(3, options = $$props.options);
			if ('cleanup' in $$props) cleanup = $$props.cleanup;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*ref, eventName, handler, options*/ 15) {
				cleanup = effect();
			}
		};

		return [ref, eventName, handler, options, $$scope, slots];
	}

	class UseDomEvent extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$L, create_fragment$L, safe_not_equal, {
				ref: 0,
				eventName: 1,
				handler: 2,
				options: 3
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UseDomEvent",
				options,
				id: create_fragment$L.name
			});
		}

		get ref() {
			throw new Error("<UseDomEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set ref(value) {
			throw new Error("<UseDomEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get eventName() {
			throw new Error("<UseDomEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set eventName(value) {
			throw new Error("<UseDomEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get handler() {
			throw new Error("<UseDomEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set handler(value) {
			throw new Error("<UseDomEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get options() {
			throw new Error("<UseDomEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set options(value) {
			throw new Error("<UseDomEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UseDomEvent$1 = UseDomEvent;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	function isMouseEvent(event) {
	    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.
	    if (typeof PointerEvent !== "undefined" && event instanceof PointerEvent) {
	        return !!(event.pointerType === "mouse");
	    }
	    return event instanceof MouseEvent;
	}
	function isTouchEvent(event) {
	    var hasTouches = !!event.touches;
	    return hasTouches;
	}

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/


	/**
	 * Filters out events not attached to the primary pointer (currently left mouse button)
	 * @param eventHandler
	 */
	function filterPrimaryPointer(eventHandler) {
	    return function (event) {
	        var isMouseEvent = event instanceof MouseEvent;
	        var isPrimaryPointer = !isMouseEvent ||
	            (isMouseEvent && event.button === 0);
	        if (isPrimaryPointer) {
	            eventHandler(event);
	        }
	    };
	}
	var defaultPagePoint = { pageX: 0, pageY: 0 };
	function pointFromTouch(e, pointType) {
	    if (pointType === void 0) { pointType = "page"; }
	    var primaryTouch = e.touches[0] || e.changedTouches[0];
	    var point = primaryTouch || defaultPagePoint;
	    return {
	        x: point[pointType + "X"],
	        y: point[pointType + "Y"],
	    };
	}
	function pointFromMouse(point, pointType) {
	    if (pointType === void 0) { pointType = "page"; }
	    return {
	        x: point[pointType + "X"],
	        y: point[pointType + "Y"],
	    };
	}
	function extractEventInfo(event, pointType) {
	    if (pointType === void 0) { pointType = "page"; }
	    return {
	        point: isTouchEvent(event)
	            ? pointFromTouch(event, pointType)
	            : pointFromMouse(event, pointType),
	    };
	}
	function getViewportPointFromEvent(event) {
	    return extractEventInfo(event, "client");
	}
	var wrapHandler = function (handler, shouldFilterPrimaryPointer) {
	    if (shouldFilterPrimaryPointer === void 0) { shouldFilterPrimaryPointer = false; }
	    var listener = function (event) {
	        return handler(event, extractEventInfo(event));
	    };
	    return shouldFilterPrimaryPointer
	        ? filterPrimaryPointer(listener)
	        : listener;
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	var isBrowser$1 = typeof window !== "undefined";

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/


	// We check for event support via functions in case they've been mocked by a testing suite.
	var supportsPointerEvents = function () {
	    return isBrowser$1 && window.onpointerdown === null;
	};
	var supportsTouchEvents = function () {
	    return isBrowser$1 && window.ontouchstart === null;
	};
	var supportsMouseEvents = function () {
	    return isBrowser$1 && window.onmousedown === null;
	};

	/* node_modules/svelte-motion/src/events/UsePointerEvent.svelte generated by Svelte v4.2.10 */

	// (65:0) <UseDomEvent {ref}   eventName={getPointerEventName(eventName)} handler={handler && wrapHandler(handler, eventName === "pointerdown")} {options}>
	function create_default_slot$h(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[4].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[5],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$h.name,
			type: "slot",
			source: "(65:0) <UseDomEvent {ref}   eventName={getPointerEventName(eventName)} handler={handler && wrapHandler(handler, eventName === \\\"pointerdown\\\")} {options}>",
			ctx
		});

		return block;
	}

	function create_fragment$K(ctx) {
		let usedomevent;
		let current;

		usedomevent = new UseDomEvent$1({
				props: {
					ref: /*ref*/ ctx[0],
					eventName: getPointerEventName(/*eventName*/ ctx[1]),
					handler: /*handler*/ ctx[2] && wrapHandler(/*handler*/ ctx[2], /*eventName*/ ctx[1] === "pointerdown"),
					options: /*options*/ ctx[3],
					$$slots: { default: [create_default_slot$h] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(usedomevent.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(usedomevent, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const usedomevent_changes = {};
				if (dirty & /*ref*/ 1) usedomevent_changes.ref = /*ref*/ ctx[0];
				if (dirty & /*eventName*/ 2) usedomevent_changes.eventName = getPointerEventName(/*eventName*/ ctx[1]);
				if (dirty & /*handler, eventName*/ 6) usedomevent_changes.handler = /*handler*/ ctx[2] && wrapHandler(/*handler*/ ctx[2], /*eventName*/ ctx[1] === "pointerdown");
				if (dirty & /*options*/ 8) usedomevent_changes.options = /*options*/ ctx[3];

				if (dirty & /*$$scope*/ 32) {
					usedomevent_changes.$$scope = { dirty, ctx };
				}

				usedomevent.$set(usedomevent_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(usedomevent.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(usedomevent.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(usedomevent, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$K.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	const mouseEventNames = {
		pointerdown: "mousedown",
		pointermove: "mousemove",
		pointerup: "mouseup",
		pointercancel: "mousecancel",
		pointerover: "mouseover",
		pointerout: "mouseout",
		pointerenter: "mouseenter",
		pointerleave: "mouseleave"
	};

	const touchEventNames = {
		pointerdown: "touchstart",
		pointermove: "touchmove",
		pointerup: "touchend",
		pointercancel: "touchcancel"
	};

	function getPointerEventName(name) {
		if (supportsPointerEvents()) {
			return name;
		} else if (supportsTouchEvents()) {
			return touchEventNames[name];
		} else if (supportsMouseEvents()) {
			return mouseEventNames[name];
		}

		return name;
	}

	function addPointerEvent(target, eventName, handler, options) {
		return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === "pointerdown"), options);
	}

	function instance$K($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UsePointerEvent', slots, ['default']);
		let { ref, eventName, handler = undefined, options = undefined } = $$props;

		$$self.$$.on_mount.push(function () {
			if (ref === undefined && !('ref' in $$props || $$self.$$.bound[$$self.$$.props['ref']])) {
				console.warn("<UsePointerEvent> was created without expected prop 'ref'");
			}

			if (eventName === undefined && !('eventName' in $$props || $$self.$$.bound[$$self.$$.props['eventName']])) {
				console.warn("<UsePointerEvent> was created without expected prop 'eventName'");
			}
		});

		const writable_props = ['ref', 'eventName', 'handler', 'options'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UsePointerEvent> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
			if ('eventName' in $$props) $$invalidate(1, eventName = $$props.eventName);
			if ('handler' in $$props) $$invalidate(2, handler = $$props.handler);
			if ('options' in $$props) $$invalidate(3, options = $$props.options);
			if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			UseDomEvent: UseDomEvent$1,
			supportsPointerEvents,
			supportsTouchEvents,
			supportsMouseEvents,
			mouseEventNames,
			touchEventNames,
			getPointerEventName,
			addPointerEvent,
			wrapHandler,
			addDomEvent,
			ref,
			eventName,
			handler,
			options
		});

		$$self.$inject_state = $$props => {
			if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
			if ('eventName' in $$props) $$invalidate(1, eventName = $$props.eventName);
			if ('handler' in $$props) $$invalidate(2, handler = $$props.handler);
			if ('options' in $$props) $$invalidate(3, options = $$props.options);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [ref, eventName, handler, options, slots, $$scope];
	}

	class UsePointerEvent extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$K, create_fragment$K, safe_not_equal, {
				ref: 0,
				eventName: 1,
				handler: 2,
				options: 3
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UsePointerEvent",
				options,
				id: create_fragment$K.name
			});
		}

		get ref() {
			throw new Error("<UsePointerEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set ref(value) {
			throw new Error("<UsePointerEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get eventName() {
			throw new Error("<UsePointerEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set eventName(value) {
			throw new Error("<UsePointerEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get handler() {
			throw new Error("<UsePointerEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set handler(value) {
			throw new Error("<UsePointerEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get options() {
			throw new Error("<UsePointerEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set options(value) {
			throw new Error("<UsePointerEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UsePointerEvent$1 = UsePointerEvent;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * @internal
	 */
	var PanSession = /** @class */ (function () {
	    function PanSession(event, handlers, _a) {
	        var _this = this;
	        var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;
	        /**
	         * @internal
	         */
	        this.startEvent = null;
	        /**
	         * @internal
	         */
	        this.lastMoveEvent = null;
	        /**
	         * @internal
	         */
	        this.lastMoveEventInfo = null;
	        /**
	         * @internal
	         */
	        this.handlers = {};
	        this.updatePoint = function () {
	            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))
	                return;
	            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);
	            var isPanStarted = _this.startEvent !== null;
	            // Only start panning if the offset is larger than 3 pixels. If we make it
	            // any larger than this we'll want to reset the pointer history
	            // on the first update to avoid visual snapping to the cursoe.
	            var isDistancePastThreshold = distance$1(info.offset, { x: 0, y: 0 }) >= 3;
	            if (!isPanStarted && !isDistancePastThreshold)
	                return;
	            var point = info.point;
	            var timestamp = getFrameData().timestamp;
	            _this.history.push(__assign(__assign({}, point), { timestamp: timestamp }));
	            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;
	            if (!isPanStarted) {
	                onStart && onStart(_this.lastMoveEvent, info);
	                _this.startEvent = _this.lastMoveEvent;
	            }
	            onMove && onMove(_this.lastMoveEvent, info);
	        };
	        this.handlePointerMove = function (event, info) {
	            _this.lastMoveEvent = event;
	            _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);
	            // Because Safari doesn't trigger mouseup events when it's above a `<select>`
	            if (isMouseEvent(event) && event.buttons === 0) {
	                _this.handlePointerUp(event, info);
	                return;
	            }
	            // Throttle mouse move event to once per frame
	            sync.update(_this.updatePoint, true);
	        };
	        this.handlePointerUp = function (event, info) {
	            _this.end();
	            var _a = _this.handlers, onEnd = _a.onEnd, onSessionEnd = _a.onSessionEnd;
	            var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);
	            if (_this.startEvent && onEnd) {
	                onEnd(event, panInfo);
	            }
	            onSessionEnd && onSessionEnd(event, panInfo);
	        };
	        // If we have more than one touch, don't start detecting this gesture
	        if (isTouchEvent(event) && event.touches.length > 1)
	            return;
	        this.handlers = handlers;
	        this.transformPagePoint = transformPagePoint;
	        var info = extractEventInfo(event);
	        var initialInfo = transformPoint(info, this.transformPagePoint);
	        var point = initialInfo.point;
	        var timestamp = getFrameData().timestamp;
	        this.history = [__assign(__assign({}, point), { timestamp: timestamp })];
	        var onSessionStart = handlers.onSessionStart;
	        onSessionStart &&
	            onSessionStart(event, getPanInfo(initialInfo, this.history));
	        this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
	    }
	    PanSession.prototype.updateHandlers = function (handlers) {
	        this.handlers = handlers;
	    };
	    PanSession.prototype.end = function () {
	        this.removeListeners && this.removeListeners();
	        cancelSync.update(this.updatePoint);
	    };
	    return PanSession;
	}());
	function transformPoint(info, transformPagePoint) {
	    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
	}
	function subtractPoint(a, b) {
	    return { x: a.x - b.x, y: a.y - b.y };
	}
	function getPanInfo(_a, history) {
	    var point = _a.point;
	    return {
	        point: point,
	        delta: subtractPoint(point, lastDevicePoint(history)),
	        offset: subtractPoint(point, startDevicePoint(history)),
	        velocity: getVelocity(history, 0.1),
	    };
	}
	function startDevicePoint(history) {
	    return history[0];
	}
	function lastDevicePoint(history) {
	    return history[history.length - 1];
	}
	function getVelocity(history, timeDelta) {
	    if (history.length < 2) {
	        return { x: 0, y: 0 };
	    }
	    var i = history.length - 1;
	    var timestampedPoint = null;
	    var lastPoint = lastDevicePoint(history);
	    while (i >= 0) {
	        timestampedPoint = history[i];
	        if (lastPoint.timestamp - timestampedPoint.timestamp >
	            secondsToMilliseconds(timeDelta)) {
	            break;
	        }
	        i--;
	    }
	    if (!timestampedPoint) {
	        return { x: 0, y: 0 };
	    }
	    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;
	    if (time === 0) {
	        return { x: 0, y: 0 };
	    }
	    var currentVelocity = {
	        x: (lastPoint.x - timestampedPoint.x) / time,
	        y: (lastPoint.y - timestampedPoint.y) / time,
	    };
	    if (currentVelocity.x === Infinity) {
	        currentVelocity.x = 0;
	    }
	    if (currentVelocity.y === Infinity) {
	        currentVelocity.y = 0;
	    }
	    return currentVelocity;
	}

	/* node_modules/svelte-motion/src/gestures/UsePanGesture.svelte generated by Svelte v4.2.10 */

	// (61:0) <UsePointerEvent ref={visualElement} eventName="pointerdown" handler={hasPanEvents && onPointerDown}>
	function create_default_slot$g(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[11].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[12],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$g.name,
			type: "slot",
			source: "(61:0) <UsePointerEvent ref={visualElement} eventName=\\\"pointerdown\\\" handler={hasPanEvents && onPointerDown}>",
			ctx
		});

		return block;
	}

	function create_fragment$J(ctx) {
		let usepointerevent;
		let current;

		usepointerevent = new UsePointerEvent$1({
				props: {
					ref: /*visualElement*/ ctx[0],
					eventName: "pointerdown",
					handler: /*hasPanEvents*/ ctx[1] && /*onPointerDown*/ ctx[3],
					$$slots: { default: [create_default_slot$g] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(usepointerevent.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(usepointerevent, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const usepointerevent_changes = {};
				if (dirty & /*visualElement*/ 1) usepointerevent_changes.ref = /*visualElement*/ ctx[0];
				if (dirty & /*hasPanEvents*/ 2) usepointerevent_changes.handler = /*hasPanEvents*/ ctx[1] && /*onPointerDown*/ ctx[3];

				if (dirty & /*$$scope*/ 4096) {
					usepointerevent_changes.$$scope = { dirty, ctx };
				}

				usepointerevent.$set(usepointerevent_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(usepointerevent.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(usepointerevent.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(usepointerevent, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$J.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$J($$self, $$props, $$invalidate) {
		let hasPanEvents;
		let $mcc;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UsePanGesture', slots, ['default']);
		let { props, visualElement, isCustom } = $$props;
		let { onPan, onPanStart, onPanEnd, onPanSessionStart } = props;
		let panSession = null;
		const mcc = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
		validate_store(mcc, 'mcc');
		component_subscribe($$self, mcc, value => $$invalidate(10, $mcc = value));
		let { transformPagePoint } = get_store_value(mcc);

		let handlers = {
			onSessionStart: onPanSessionStart,
			onStart: onPanStart,
			onMove: onPan,
			onEnd: (event, info) => {
				panSession = null;
				onPanEnd && onPanEnd(event, info);
			}
		};

		function onPointerDown(event) {
			panSession = new PanSession(event, handlers, { transformPagePoint });
		}

		afterUpdate(() => {
			if (panSession !== null) {
				panSession.updateHandlers(handlers);
			}
		});

		onDestroy(() => panSession && panSession.end());

		$$self.$$.on_mount.push(function () {
			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<UsePanGesture> was created without expected prop 'props'");
			}

			if (visualElement === undefined && !('visualElement' in $$props || $$self.$$.bound[$$self.$$.props['visualElement']])) {
				console.warn("<UsePanGesture> was created without expected prop 'visualElement'");
			}

			if (isCustom === undefined && !('isCustom' in $$props || $$self.$$.bound[$$self.$$.props['isCustom']])) {
				console.warn("<UsePanGesture> was created without expected prop 'isCustom'");
			}
		});

		const writable_props = ['props', 'visualElement', 'isCustom'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UsePanGesture> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('props' in $$props) $$invalidate(4, props = $$props.props);
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('isCustom' in $$props) $$invalidate(5, isCustom = $$props.isCustom);
			if ('$$scope' in $$props) $$invalidate(12, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			MotionConfigContext,
			PanSession,
			afterUpdate,
			getContext,
			onDestroy,
			UsePointerEvent: UsePointerEvent$1,
			get: get_store_value,
			props,
			visualElement,
			isCustom,
			onPan,
			onPanStart,
			onPanEnd,
			onPanSessionStart,
			panSession,
			mcc,
			transformPagePoint,
			handlers,
			onPointerDown,
			hasPanEvents,
			$mcc
		});

		$$self.$inject_state = $$props => {
			if ('props' in $$props) $$invalidate(4, props = $$props.props);
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('isCustom' in $$props) $$invalidate(5, isCustom = $$props.isCustom);
			if ('onPan' in $$props) $$invalidate(6, onPan = $$props.onPan);
			if ('onPanStart' in $$props) $$invalidate(7, onPanStart = $$props.onPanStart);
			if ('onPanEnd' in $$props) $$invalidate(8, onPanEnd = $$props.onPanEnd);
			if ('onPanSessionStart' in $$props) $$invalidate(9, onPanSessionStart = $$props.onPanSessionStart);
			if ('panSession' in $$props) panSession = $$props.panSession;
			if ('transformPagePoint' in $$props) transformPagePoint = $$props.transformPagePoint;
			if ('handlers' in $$props) handlers = $$props.handlers;
			if ('hasPanEvents' in $$props) $$invalidate(1, hasPanEvents = $$props.hasPanEvents);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*props*/ 16) {
				$$invalidate(6, { onPan, onPanStart, onPanEnd, onPanSessionStart } = props, onPan, ($$invalidate(7, onPanStart), $$invalidate(4, props)), ($$invalidate(8, onPanEnd), $$invalidate(4, props)), ($$invalidate(9, onPanSessionStart), $$invalidate(4, props)));
			}

			if ($$self.$$.dirty & /*onPan, onPanStart, onPanEnd, onPanSessionStart*/ 960) {
				$$invalidate(1, hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart);
			}

			if ($$self.$$.dirty & /*$mcc*/ 1024) {
				({ transformPagePoint } = $mcc);
			}

			if ($$self.$$.dirty & /*onPanSessionStart, onPanStart, onPan, onPanEnd*/ 960) {
				handlers = {
					onSessionStart: onPanSessionStart,
					onStart: onPanStart,
					onMove: onPan,
					onEnd: (event, info) => {
						panSession = null;
						onPanEnd && onPanEnd(event, info);
					}
				};
			}
		};

		return [
			visualElement,
			hasPanEvents,
			mcc,
			onPointerDown,
			props,
			isCustom,
			onPan,
			onPanStart,
			onPanEnd,
			onPanSessionStart,
			$mcc,
			slots,
			$$scope
		];
	}

	class UsePanGesture extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$J, create_fragment$J, safe_not_equal, { props: 4, visualElement: 0, isCustom: 5 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UsePanGesture",
				options,
				id: create_fragment$J.name
			});
		}

		get props() {
			throw new Error("<UsePanGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<UsePanGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get visualElement() {
			throw new Error("<UsePanGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualElement(value) {
			throw new Error("<UsePanGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isCustom() {
			throw new Error("<UsePanGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isCustom(value) {
			throw new Error("<UsePanGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UsePanGesture$1 = UsePanGesture;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * Recursively traverse up the tree to check whether the provided child node
	 * is the parent or a descendant of it.
	 *
	 * @param parent - Element to find
	 * @param child - Element to test against parent
	 */
	var isNodeOrChild = function (parent, child) {
	    if (!child) {
	        return false;
	    }
	    else if (parent === child) {
	        return true;
	    }
	    else {
	        return isNodeOrChild(parent, child.parentElement);
	    }
	};

	/** 
	based on framer-motion@4.1.17,
	Copyright (c) 2018 Framer B.V.
	*/

	function createLock(name) {
	    var lock = null;
	    return function () {
	        var openLock = function () {
	            lock = null;
	        };
	        
	        if (lock === null) {
	            lock = name;
	            return openLock;
	        }
	        return false;
	    };
	}
	var globalHorizontalLock = createLock("dragHorizontal");
	var globalVerticalLock = createLock("dragVertical");
	function getGlobalLock(drag) {
	    var lock = false;
	    if (drag === "y") {
	        
	        lock = globalVerticalLock();
	    }
	    else if (drag === "x") {
	        
	        lock = globalHorizontalLock();
	    }
	    else {
	        var openHorizontal_1 = globalHorizontalLock();
	        var openVertical_1 = globalVerticalLock();
	        if (openHorizontal_1 && openVertical_1) {
	            lock = function () {
	                openHorizontal_1();
	                openVertical_1();
	            };
	        }
	        else {
	            // Release the locks because we don't use them
	            if (openHorizontal_1)
	                openHorizontal_1();
	            if (openVertical_1)
	                openVertical_1();
	        }
	    }
	    return lock;
	}
	function isDragActive() {
	    // Check the gesture lock - if we get it, it means no drag gesture is active
	    // and we can safely fire the tap gesture.
	    var openGestureLock = getGlobalLock(true);
	    if (!openGestureLock)
	        return true;
	    openGestureLock();
	    return false;
	}

	/* node_modules/svelte-motion/src/gestures/UseTapGesture.svelte generated by Svelte v4.2.10 */

	// (73:0) <UsePointerEvent     ref={visualElement}     eventName="pointerdown"     handler={hasPressListeners ? onPointerDown : undefined}>
	function create_default_slot$f(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[8].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[9],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$f.name,
			type: "slot",
			source: "(73:0) <UsePointerEvent     ref={visualElement}     eventName=\\\"pointerdown\\\"     handler={hasPressListeners ? onPointerDown : undefined}>",
			ctx
		});

		return block;
	}

	function create_fragment$I(ctx) {
		let usepointerevent;
		let current;

		usepointerevent = new UsePointerEvent$1({
				props: {
					ref: /*visualElement*/ ctx[0],
					eventName: "pointerdown",
					handler: /*hasPressListeners*/ ctx[1]
					? /*onPointerDown*/ ctx[2]
					: undefined,
					$$slots: { default: [create_default_slot$f] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(usepointerevent.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(usepointerevent, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const usepointerevent_changes = {};
				if (dirty & /*visualElement*/ 1) usepointerevent_changes.ref = /*visualElement*/ ctx[0];

				if (dirty & /*hasPressListeners*/ 2) usepointerevent_changes.handler = /*hasPressListeners*/ ctx[1]
				? /*onPointerDown*/ ctx[2]
				: undefined;

				if (dirty & /*$$scope*/ 512) {
					usepointerevent_changes.$$scope = { dirty, ctx };
				}

				usepointerevent.$set(usepointerevent_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(usepointerevent.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(usepointerevent.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(usepointerevent, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$I.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$I($$self, $$props, $$invalidate) {
		let onTap;
		let onTapStart;
		let onTapCancel;
		let whileTap;
		let hasPressListeners;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UseTapGesture', slots, ['default']);
		let { props, visualElement } = $$props;
		let isPressing = false;
		let cancelPointerEndListeners = null;

		function removePointerEndListener() {
			cancelPointerEndListeners?.();
			cancelPointerEndListeners = null;
		}

		function checkPointerEnd() {
			removePointerEndListener();
			isPressing = false;
			visualElement.animationState?.setActive(AnimationType.Tap, false);
			return !isDragActive();
		}

		function onPointerUp(event, info) {
			if (!checkPointerEnd()) return;

			/**
	 * We only count this as a tap gesture if the event.target is the same
	 * as, or a child of, this component's element
	 */
			!isNodeOrChild(visualElement.getInstance(), event.target)
			? onTapCancel?.(event, info)
			: onTap?.(event, info);
		}

		function onPointerCancel(event, info) {
			if (!checkPointerEnd()) return;
			onTapCancel?.(event, info);
		}

		function onPointerDown(event, info) {
			if (isPressing) return;
			removePointerEndListener();
			isPressing = true;
			cancelPointerEndListeners = pipe(addPointerEvent(window, "pointerup", onPointerUp), addPointerEvent(window, "pointercancel", onPointerCancel));
			onTapStart?.(event, info);
			visualElement.animationState?.setActive(AnimationType.Tap, true);
		}

		onDestroy(removePointerEndListener);

		$$self.$$.on_mount.push(function () {
			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<UseTapGesture> was created without expected prop 'props'");
			}

			if (visualElement === undefined && !('visualElement' in $$props || $$self.$$.bound[$$self.$$.props['visualElement']])) {
				console.warn("<UseTapGesture> was created without expected prop 'visualElement'");
			}
		});

		const writable_props = ['props', 'visualElement'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UseTapGesture> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('props' in $$props) $$invalidate(3, props = $$props.props);
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			fixed,
			isNodeOrChild,
			pipe,
			isDragActive,
			onDestroy,
			UsePointerEvent: UsePointerEvent$1,
			addPointerEvent,
			AnimationType,
			props,
			visualElement,
			isPressing,
			cancelPointerEndListeners,
			removePointerEndListener,
			checkPointerEnd,
			onPointerUp,
			onPointerCancel,
			onPointerDown,
			onTapStart,
			onTapCancel,
			onTap,
			whileTap,
			hasPressListeners
		});

		$$self.$inject_state = $$props => {
			if ('props' in $$props) $$invalidate(3, props = $$props.props);
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('isPressing' in $$props) isPressing = $$props.isPressing;
			if ('cancelPointerEndListeners' in $$props) cancelPointerEndListeners = $$props.cancelPointerEndListeners;
			if ('onTapStart' in $$props) $$invalidate(4, onTapStart = $$props.onTapStart);
			if ('onTapCancel' in $$props) $$invalidate(5, onTapCancel = $$props.onTapCancel);
			if ('onTap' in $$props) $$invalidate(6, onTap = $$props.onTap);
			if ('whileTap' in $$props) $$invalidate(7, whileTap = $$props.whileTap);
			if ('hasPressListeners' in $$props) $$invalidate(1, hasPressListeners = $$props.hasPressListeners);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*props*/ 8) {
				$$invalidate(6, { onTap, onTapStart, onTapCancel, whileTap } = props, onTap, ($$invalidate(4, onTapStart), $$invalidate(3, props)), ($$invalidate(5, onTapCancel), $$invalidate(3, props)), ($$invalidate(7, whileTap), $$invalidate(3, props)));
			}

			if ($$self.$$.dirty & /*onTap, onTapStart, onTapCancel, whileTap*/ 240) {
				$$invalidate(1, hasPressListeners = onTap || onTapStart || onTapCancel || whileTap);
			}
		};

		return [
			visualElement,
			hasPressListeners,
			onPointerDown,
			props,
			onTapStart,
			onTapCancel,
			onTap,
			whileTap,
			slots,
			$$scope
		];
	}

	class UseTapGesture extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$I, create_fragment$I, safe_not_equal, { props: 3, visualElement: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UseTapGesture",
				options,
				id: create_fragment$I.name
			});
		}

		get props() {
			throw new Error("<UseTapGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<UseTapGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get visualElement() {
			throw new Error("<UseTapGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualElement(value) {
			throw new Error("<UseTapGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UseTapGesture$1 = UseTapGesture;

	/* node_modules/svelte-motion/src/gestures/UseHoverGesture.svelte generated by Svelte v4.2.10 */

	function create_fragment$H(ctx) {
		let usepointerevent0;
		let t0;
		let usepointerevent1;
		let t1;
		let current;

		usepointerevent0 = new UsePointerEvent$1({
				props: {
					ref: /*visualElement*/ ctx[0],
					eventName: "pointerenter",
					handler: /*onHoverStart*/ ctx[1] || /*whileHover*/ ctx[3]
					? createHoverEvent(/*visualElement*/ ctx[0], true, /*onHoverStart*/ ctx[1])
					: undefined
				},
				$$inline: true
			});

		usepointerevent1 = new UsePointerEvent$1({
				props: {
					ref: /*visualElement*/ ctx[0],
					eventName: "pointerleave",
					handler: /*onHoverEnd*/ ctx[2] || /*whileHover*/ ctx[3]
					? createHoverEvent(/*visualElement*/ ctx[0], false, /*onHoverEnd*/ ctx[2])
					: undefined
				},
				$$inline: true
			});

		const default_slot_template = /*#slots*/ ctx[6].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

		const block = {
			c: function create() {
				create_component(usepointerevent0.$$.fragment);
				t0 = space();
				create_component(usepointerevent1.$$.fragment);
				t1 = space();
				if (default_slot) default_slot.c();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(usepointerevent0, target, anchor);
				insert_dev(target, t0, anchor);
				mount_component(usepointerevent1, target, anchor);
				insert_dev(target, t1, anchor);

				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				const usepointerevent0_changes = {};
				if (dirty & /*visualElement*/ 1) usepointerevent0_changes.ref = /*visualElement*/ ctx[0];

				if (dirty & /*onHoverStart, whileHover, visualElement*/ 11) usepointerevent0_changes.handler = /*onHoverStart*/ ctx[1] || /*whileHover*/ ctx[3]
				? createHoverEvent(/*visualElement*/ ctx[0], true, /*onHoverStart*/ ctx[1])
				: undefined;

				usepointerevent0.$set(usepointerevent0_changes);
				const usepointerevent1_changes = {};
				if (dirty & /*visualElement*/ 1) usepointerevent1_changes.ref = /*visualElement*/ ctx[0];

				if (dirty & /*onHoverEnd, whileHover, visualElement*/ 13) usepointerevent1_changes.handler = /*onHoverEnd*/ ctx[2] || /*whileHover*/ ctx[3]
				? createHoverEvent(/*visualElement*/ ctx[0], false, /*onHoverEnd*/ ctx[2])
				: undefined;

				usepointerevent1.$set(usepointerevent1_changes);

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[5],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(usepointerevent0.$$.fragment, local);
				transition_in(usepointerevent1.$$.fragment, local);
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(usepointerevent0.$$.fragment, local);
				transition_out(usepointerevent1.$$.fragment, local);
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t0);
					detach_dev(t1);
				}

				destroy_component(usepointerevent0, detaching);
				destroy_component(usepointerevent1, detaching);
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$H.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function createHoverEvent(visualElement, isActive, callback) {
		return (event, info) => {
			if (!isMouseEvent(event) || isDragActive()) return;
			callback?.(event, info);
			visualElement.animationState?.setActive(AnimationType.Hover, isActive);
		};
	}

	function instance$H($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UseHoverGesture', slots, ['default']);
		let { props, visualElement } = $$props;
		let { onHoverStart, onHoverEnd, whileHover } = props;

		$$self.$$.on_mount.push(function () {
			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<UseHoverGesture> was created without expected prop 'props'");
			}

			if (visualElement === undefined && !('visualElement' in $$props || $$self.$$.bound[$$self.$$.props['visualElement']])) {
				console.warn("<UseHoverGesture> was created without expected prop 'visualElement'");
			}
		});

		const writable_props = ['props', 'visualElement'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UseHoverGesture> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('props' in $$props) $$invalidate(4, props = $$props.props);
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			isDragActive,
			createHoverEvent,
			UsePointerEvent: UsePointerEvent$1,
			AnimationType,
			isMouseEvent,
			props,
			visualElement,
			onHoverStart,
			onHoverEnd,
			whileHover
		});

		$$self.$inject_state = $$props => {
			if ('props' in $$props) $$invalidate(4, props = $$props.props);
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('onHoverStart' in $$props) $$invalidate(1, onHoverStart = $$props.onHoverStart);
			if ('onHoverEnd' in $$props) $$invalidate(2, onHoverEnd = $$props.onHoverEnd);
			if ('whileHover' in $$props) $$invalidate(3, whileHover = $$props.whileHover);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*props*/ 16) {
				$$invalidate(1, { onHoverStart, onHoverEnd, whileHover } = props, onHoverStart, ($$invalidate(2, onHoverEnd), $$invalidate(4, props)), ($$invalidate(3, whileHover), $$invalidate(4, props)));
			}
		};

		return [visualElement, onHoverStart, onHoverEnd, whileHover, props, $$scope, slots];
	}

	class UseHoverGesture extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$H, create_fragment$H, safe_not_equal, { props: 4, visualElement: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UseHoverGesture",
				options,
				id: create_fragment$H.name
			});
		}

		get props() {
			throw new Error("<UseHoverGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<UseHoverGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get visualElement() {
			throw new Error("<UseHoverGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualElement(value) {
			throw new Error("<UseHoverGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UseHoverGesture$1 = UseHoverGesture;

	/* node_modules/svelte-motion/src/gestures/UseFocusGesture.svelte generated by Svelte v4.2.10 */

	// (22:4) <UseDomEvent ref={visualElement} eventName="blur" handler={whileFocus ? onBlur : undefined}>
	function create_default_slot_1$5(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[5].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[6],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_1$5.name,
			type: "slot",
			source: "(22:4) <UseDomEvent ref={visualElement} eventName=\\\"blur\\\" handler={whileFocus ? onBlur : undefined}>",
			ctx
		});

		return block;
	}

	// (21:0) <UseDomEvent ref={visualElement} eventName="focus" handler={whileFocus ? onFocus : undefined}>
	function create_default_slot$e(ctx) {
		let usedomevent;
		let current;

		usedomevent = new UseDomEvent$1({
				props: {
					ref: /*visualElement*/ ctx[0],
					eventName: "blur",
					handler: /*whileFocus*/ ctx[1] ? /*onBlur*/ ctx[3] : undefined,
					$$slots: { default: [create_default_slot_1$5] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(usedomevent.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(usedomevent, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const usedomevent_changes = {};
				if (dirty & /*visualElement*/ 1) usedomevent_changes.ref = /*visualElement*/ ctx[0];
				if (dirty & /*whileFocus*/ 2) usedomevent_changes.handler = /*whileFocus*/ ctx[1] ? /*onBlur*/ ctx[3] : undefined;

				if (dirty & /*$$scope*/ 64) {
					usedomevent_changes.$$scope = { dirty, ctx };
				}

				usedomevent.$set(usedomevent_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(usedomevent.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(usedomevent.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(usedomevent, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$e.name,
			type: "slot",
			source: "(21:0) <UseDomEvent ref={visualElement} eventName=\\\"focus\\\" handler={whileFocus ? onFocus : undefined}>",
			ctx
		});

		return block;
	}

	function create_fragment$G(ctx) {
		let usedomevent;
		let current;

		usedomevent = new UseDomEvent$1({
				props: {
					ref: /*visualElement*/ ctx[0],
					eventName: "focus",
					handler: /*whileFocus*/ ctx[1] ? /*onFocus*/ ctx[2] : undefined,
					$$slots: { default: [create_default_slot$e] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(usedomevent.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(usedomevent, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const usedomevent_changes = {};
				if (dirty & /*visualElement*/ 1) usedomevent_changes.ref = /*visualElement*/ ctx[0];
				if (dirty & /*whileFocus*/ 2) usedomevent_changes.handler = /*whileFocus*/ ctx[1] ? /*onFocus*/ ctx[2] : undefined;

				if (dirty & /*$$scope, visualElement, whileFocus*/ 67) {
					usedomevent_changes.$$scope = { dirty, ctx };
				}

				usedomevent.$set(usedomevent_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(usedomevent.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(usedomevent.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(usedomevent, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$G.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$G($$self, $$props, $$invalidate) {
		let whileFocus;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UseFocusGesture', slots, ['default']);
		let { props, visualElement } = $$props;

		const onFocus = () => {
			visualElement.animationState?.setActive(AnimationType.Focus, true);
		};

		const onBlur = () => {
			visualElement.animationState?.setActive(AnimationType.Focus, false);
		};

		$$self.$$.on_mount.push(function () {
			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<UseFocusGesture> was created without expected prop 'props'");
			}

			if (visualElement === undefined && !('visualElement' in $$props || $$self.$$.bound[$$self.$$.props['visualElement']])) {
				console.warn("<UseFocusGesture> was created without expected prop 'visualElement'");
			}
		});

		const writable_props = ['props', 'visualElement'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UseFocusGesture> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('props' in $$props) $$invalidate(4, props = $$props.props);
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			UseDomEvent: UseDomEvent$1,
			AnimationType,
			props,
			visualElement,
			onFocus,
			onBlur,
			whileFocus
		});

		$$self.$inject_state = $$props => {
			if ('props' in $$props) $$invalidate(4, props = $$props.props);
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('whileFocus' in $$props) $$invalidate(1, whileFocus = $$props.whileFocus);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*props*/ 16) {
				$$invalidate(1, { whileFocus } = props, whileFocus);
			}
		};

		return [visualElement, whileFocus, onFocus, onBlur, props, slots, $$scope];
	}

	class UseFocusGesture extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$G, create_fragment$G, safe_not_equal, { props: 4, visualElement: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UseFocusGesture",
				options,
				id: create_fragment$G.name
			});
		}

		get props() {
			throw new Error("<UseFocusGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<UseFocusGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get visualElement() {
			throw new Error("<UseFocusGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualElement(value) {
			throw new Error("<UseFocusGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UseFocusGesture$1 = UseFocusGesture;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/


	const createMotionClass = (features)=>{
	    features && loadFeatures(features);
	    return Motion$1;           
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * @public
	 */
	const gestureAnimations = {
	    tap: UseTapGesture$1,
	    focus: UseFocusGesture$1,
	    hover: UseHoverGesture$1,
	};

	/** 
	based on framer-motion@4.1.17,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * Apply constraints to a point. These constraints are both physical along an
	 * axis, and an elastic factor that determines how much to constrain the point
	 * by if it does lie outside the defined parameters.
	 */
	function applyConstraints(point, _a, elastic) {
	    var min = _a.min, max = _a.max;
	    if (min !== undefined && point < min) {
	        // If we have a min point defined, and this is outside of that, constrain
	        point = elastic ? mix$1(min, point, elastic.min) : Math.max(point, min);
	    }
	    else if (max !== undefined && point > max) {
	        // If we have a max point defined, and this is outside of that, constrain
	        point = elastic ? mix$1(max, point, elastic.max) : Math.min(point, max);
	    }
	    return point;
	}
	/**
	 * Calculates a min projection point based on a pointer, pointer progress
	 * within the drag target, and constraints.
	 *
	 * For instance if an element was 100px width, we were dragging from 0.25
	 * along this axis, the pointer is at 200px, and there were no constraints,
	 * we would calculate a min projection point of 175px.
	 */
	function calcConstrainedMinPoint(point, length, progress, constraints, elastic) {
	    // Calculate a min point for this axis and apply it to the current pointer
	    var min = point - length * progress;
	    return constraints ? applyConstraints(min, constraints, elastic) : min;
	}
	/**
	 * Calculate constraints in terms of the viewport when defined relatively to the
	 * measured axis. This is measured from the nearest edge, so a max constraint of 200
	 * on an axis with a max value of 300 would return a constraint of 500 - axis length
	 */
	function calcRelativeAxisConstraints(axis, min, max) {
	    return {
	        min: min !== undefined ? axis.min + min : undefined,
	        max: max !== undefined
	            ? axis.max + max - (axis.max - axis.min)
	            : undefined,
	    };
	}
	/**
	 * Calculate constraints in terms of the viewport when
	 * defined relatively to the measured bounding box.
	 */
	function calcRelativeConstraints(layoutBox, _a) {
	    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;
	    return {
	        x: calcRelativeAxisConstraints(layoutBox.x, left, right),
	        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),
	    };
	}
	/**
	 * Calculate viewport constraints when defined as another viewport-relative axis
	 */
	function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
	    var _a;
	    var min = constraintsAxis.min - layoutAxis.min;
	    var max = constraintsAxis.max - layoutAxis.max;
	    // If the constraints axis is actually smaller than the layout axis then we can
	    // flip the constraints
	    if (constraintsAxis.max - constraintsAxis.min <
	        layoutAxis.max - layoutAxis.min) {
	        _a = __read([max, min], 2), min = _a[0], max = _a[1];
	    }
	    return {
	        min: layoutAxis.min + min,
	        max: layoutAxis.min + max,
	    };
	}
	/**
	 * Calculate viewport constraints when defined as another viewport-relative box
	 */
	function calcViewportConstraints(layoutBox, constraintsBox) {
	    return {
	        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
	        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),
	    };
	}
	/**
	 * Calculate the an axis position based on two axes and a progress value.
	 */
	function calcPositionFromProgress(axis, constraints, progress) {
	    var axisLength = axis.max - axis.min;
	    var min = mix$1(constraints.min, constraints.max - axisLength, progress);
	    return { min: min, max: min + axisLength };
	}
	/**
	 * Rebase the calculated viewport constraints relative to the layout.min point.
	 */
	function rebaseAxisConstraints(layout, constraints) {
	    var relativeConstraints = {};
	    if (constraints.min !== undefined) {
	        relativeConstraints.min = constraints.min - layout.min;
	    }
	    if (constraints.max !== undefined) {
	        relativeConstraints.max = constraints.max - layout.min;
	    }
	    return relativeConstraints;
	}
	var defaultElastic = 0.35;
	/**
	 * Accepts a dragElastic prop and returns resolved elastic values for each axis.
	 */
	function resolveDragElastic(dragElastic) {
	    if (dragElastic === false) {
	        dragElastic = 0;
	    }
	    else if (dragElastic === true) {
	        dragElastic = defaultElastic;
	    }
	    return {
	        x: resolveAxisElastic(dragElastic, "left", "right"),
	        y: resolveAxisElastic(dragElastic, "top", "bottom"),
	    };
	}
	function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
	    return {
	        min: resolvePointElastic(dragElastic, minLabel),
	        max: resolvePointElastic(dragElastic, maxLabel),
	    };
	}
	function resolvePointElastic(dragElastic, label) {
	    var _a;
	    return typeof dragElastic === "number"
	        ? dragElastic
	        : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;
	}

	/** 
	based on framer-motion@4.1.11,
	Copyright (c) 2018 Framer B.V.
	*/


	/**
	 * Returns a boolean stating whether or not we converted the projection
	 * to relative projection.
	 */
	function convertToRelativeProjection(visualElement, isLayoutDrag) {
	    if (isLayoutDrag === void 0) { isLayoutDrag = true; }
	    var projectionParent = visualElement.getProjectionParent();
	    if (!projectionParent)
	        return false;
	    var offset;
	    if (isLayoutDrag) {
	        offset = calcRelativeOffset(projectionParent.projection.target, visualElement.projection.target);
	        removeBoxTransforms(offset, projectionParent.getLatestValues());
	    }
	    else {
	        offset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);
	    }
	    eachAxis(function (axis) {
	        return visualElement.setProjectionTargetAxis(axis, offset[axis].min, offset[axis].max, true);
	    });
	    return true;
	}

	/** 
	based on framer-motion@4.1.15,
	Copyright (c) 2018 Framer B.V.
	*/

	var elementDragControls = new WeakMap();
	/**
	 *
	 */
	var lastPointerEvent;
	var VisualElementDragControls = /** @class */ (function () {
	    function VisualElementDragControls(_a) {
	        var visualElement = _a.visualElement;
	        /**
	         * Track whether we're currently dragging.
	         *
	         * @internal
	         */
	        this.isDragging = false;
	        /**
	         * The current direction of drag, or `null` if both.
	         *
	         * @internal
	         */
	        this.currentDirection = null;
	        /**
	         * The permitted boundaries of travel, in pixels.
	         *
	         * @internal
	         */
	        this.constraints = false;
	        /**
	         * The per-axis resolved elastic values.
	         *
	         * @internal
	         */
	        this.elastic = axisBox();
	        /**
	         * A reference to the host component's latest props.
	         *
	         * @internal
	         */
	        this.props = {};
	        /**
	         * @internal
	         */
	        this.hasMutatedConstraints = false;
	        /**
	         * Track the initial position of the cursor relative to the dragging element
	         * when dragging starts as a value of 0-1 on each axis. We then use this to calculate
	         * an ideal bounding box for the VisualElement renderer to project into every frame.
	         *
	         * @internal
	         */
	        this.cursorProgress = {
	            x: 0.5,
	            y: 0.5,
	        };
	        // When updating _dragX, or _dragY instead of the VisualElement,
	        // persist their values between drag gestures.
	        this.originPoint = {};
	        // This is a reference to the global drag gesture lock, ensuring only one component
	        // can "capture" the drag of one or both axes.
	        // TODO: Look into moving this into pansession?
	        this.openGlobalLock = null;
	        /**
	         * @internal
	         */
	        this.panSession = null;
	        this.visualElement = visualElement;
	        this.visualElement.enableLayoutProjection();
	        elementDragControls.set(visualElement, this);
	    }
	    /**
	     * Instantiate a PanSession for the drag gesture
	     *
	     * @public
	     */
	    VisualElementDragControls.prototype.start = function (originEvent, _a) {
	        var _this = this;
	        var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c, cursorProgress = _b.cursorProgress;
	        var onSessionStart = function (event) {
	            var _a;
	            // Stop any animations on both axis values immediately. This allows the user to throw and catch
	            // the component.
	            _this.stopMotion();
	            /**
	             * Save the initial point. We'll use this to calculate the pointer's position rather
	             * than the one we receive when the gesture actually starts. By then, the pointer will
	             * have already moved, and the perception will be of the pointer "slipping" across the element
	             */
	            var initialPoint = getViewportPointFromEvent(event).point;
	            (_a = _this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(_this);
	            _this.cancelLayout = batchLayout(function (read, write) {
	                var ancestors = collectProjectingAncestors(_this.visualElement);
	                var children = collectProjectingChildren(_this.visualElement);
	                var tree = __spreadArray(__spreadArray([], __read(ancestors)), __read(children));
	                var hasManuallySetCursorOrigin = false;
	                /**
	                 * Apply a simple lock to the projection target. This ensures no animations
	                 * can run on the projection box while this lock is active.
	                 */
	                _this.isLayoutDrag() && _this.visualElement.lockProjectionTarget();
	                write(function () {
	                    tree.forEach(function (element) { return element.resetTransform(); });
	                });
	                read(function () {
	                    updateLayoutMeasurement(_this.visualElement);
	                    children.forEach(updateLayoutMeasurement);
	                });
	                write(function () {
	                    tree.forEach(function (element) { return element.restoreTransform(); });
	                    if (snapToCursor) {
	                        hasManuallySetCursorOrigin = _this.snapToCursor(initialPoint);
	                    }
	                });
	                read(function () {
	                    var isRelativeDrag = Boolean(_this.getAxisMotionValue("x") && !_this.isExternalDrag());
	                    if (!isRelativeDrag) {
	                        _this.visualElement.rebaseProjectionTarget(true, _this.visualElement.measureViewportBox(false));
	                    }
	                    _this.visualElement.scheduleUpdateLayoutProjection();
	                    /**
	                     * When dragging starts, we want to find where the cursor is relative to the bounding box
	                     * of the element. Every frame, we calculate a new bounding box using this relative position
	                     * and let the visualElement renderer figure out how to reproject the element into this bounding
	                     * box.
	                     *
	                     * By doing it this way, rather than applying an x/y transform directly to the element,
	                     * we can ensure the component always visually sticks to the cursor as we'd expect, even
	                     * if the DOM element itself changes layout as a result of React updates the user might
	                     * make based on the drag position.
	                     */
	                    var projection = _this.visualElement.projection;
	                    eachAxis(function (axis) {
	                        if (!hasManuallySetCursorOrigin) {
	                            var _a = projection.target[axis], min = _a.min, max = _a.max;
	                            _this.cursorProgress[axis] = cursorProgress
	                                ? cursorProgress[axis]
	                                : progress(min, max, initialPoint[axis]);
	                        }
	                        /**
	                         * If we have external drag MotionValues, record their origin point. On pointermove
	                         * we'll apply the pan gesture offset directly to this value.
	                         */
	                        var axisValue = _this.getAxisMotionValue(axis);
	                        if (axisValue) {
	                            _this.originPoint[axis] = axisValue.get();
	                        }
	                    });
	                });
	                write(function () {
	                    flushSync.update();
	                    flushSync.preRender();
	                    flushSync.render();
	                    flushSync.postRender();
	                });
	                read(function () { return _this.resolveDragConstraints(); });
	            });
	        };
	        var onStart = function (event, info) {
	            var _a, _b, _c;
	            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession
	            var _d = _this.props, drag = _d.drag, dragPropagation = _d.dragPropagation;
	            if (drag && !dragPropagation) {
	                if (_this.openGlobalLock)
	                    _this.openGlobalLock();
	                _this.openGlobalLock = getGlobalLock(drag);
	                // If we don 't have the lock, don't start dragging
	                if (!_this.openGlobalLock)
	                    return;
	            }
	            flushLayout();
	            // Set current drag status
	            _this.isDragging = true;
	            _this.currentDirection = null;
	            // Fire onDragStart event
	            (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);
	            (_c = _this.visualElement.animationState) === null || _c === void 0 ? void 0 : _c.setActive(AnimationType.Drag, true);
	        };
	        var onMove = function (event, info) {
	            var _a, _b, _c, _d;
	            var _e = _this.props, dragPropagation = _e.dragPropagation, dragDirectionLock = _e.dragDirectionLock;
	            // If we didn't successfully receive the gesture lock, early return.
	            if (!dragPropagation && !_this.openGlobalLock)
	                return;
	            var offset = info.offset;
	            // Attempt to detect drag direction if directionLock is true
	            if (dragDirectionLock && _this.currentDirection === null) {
	                _this.currentDirection = getCurrentDirection(offset);
	                // If we've successfully set a direction, notify listener
	                if (_this.currentDirection !== null) {
	                    (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);
	                }
	                return;
	            }
	            // Update each point with the latest position
	            _this.updateAxis("x", info.point, offset);
	            _this.updateAxis("y", info.point, offset);
	            // Fire onDrag event
	            (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);
	            // Update the last pointer event
	            lastPointerEvent = event;
	        };
	        var onSessionEnd = function (event, info) {
	            return _this.stop(event, info);
	        };
	        var transformPagePoint = this.props.transformPagePoint;
	        this.panSession = new PanSession(originEvent, {
	            onSessionStart: onSessionStart,
	            onStart: onStart,
	            onMove: onMove,
	            onSessionEnd: onSessionEnd,
	        }, { transformPagePoint: transformPagePoint });
	    };
	    VisualElementDragControls.prototype.resolveDragConstraints = function () {
	        var _this = this;
	        var _a = this.props, dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;
	        var layout = this.visualElement.getLayoutState().layoutCorrected;
	        if (dragConstraints) {
	            this.constraints = isRefObject(dragConstraints)
	                ? this.resolveRefConstraints(layout, dragConstraints)
	                : calcRelativeConstraints(layout, dragConstraints);
	        }
	        else {
	            this.constraints = false;
	        }
	        this.elastic = resolveDragElastic(dragElastic);
	        /**
	         * If we're outputting to external MotionValues, we want to rebase the measured constraints
	         * from viewport-relative to component-relative.
	         */
	        if (this.constraints && !this.hasMutatedConstraints) {
	            eachAxis(function (axis) {
	                if (_this.getAxisMotionValue(axis)) {
	                    _this.constraints[axis] = rebaseAxisConstraints(layout[axis], _this.constraints[axis]);
	                }
	            });
	        }
	    };
	    VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {
	        var _a = this.props, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;
	        var constraintsElement = constraints.current;
	        this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);
	        var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);
	        /**
	         * If there's an onMeasureDragConstraints listener we call it and
	         * if different constraints are returned, set constraints to that
	         */
	        if (onMeasureDragConstraints) {
	            var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));
	            this.hasMutatedConstraints = !!userConstraints;
	            if (userConstraints) {
	                measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);
	            }
	        }
	        return measuredConstraints;
	    };
	    VisualElementDragControls.prototype.cancelDrag = function () {
	        var _a, _b;
	        this.visualElement.unlockProjectionTarget();
	        (_a = this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(this);
	        this.isDragging = false;
	        this.panSession && this.panSession.end();
	        this.panSession = null;
	        if (!this.props.dragPropagation && this.openGlobalLock) {
	            this.openGlobalLock();
	            this.openGlobalLock = null;
	        }
	        (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);
	    };
	    VisualElementDragControls.prototype.stop = function (event, info) {
	        var _a, _b, _c;
	        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();
	        this.panSession = null;
	        var isDragging = this.isDragging;
	        this.cancelDrag();
	        if (!isDragging)
	            return;
	        var velocity = info.velocity;
	        this.animateDragEnd(velocity);
	        (_c = (_b = this.props).onDragEnd) === null || _c === void 0 ? void 0 : _c.call(_b, event, info);
	    };
	    VisualElementDragControls.prototype.snapToCursor = function (point) {
	        var _this = this;
	        return eachAxis(function (axis) {
	            var drag = _this.props.drag;
	            // If we're not dragging this axis, do an early return.
	            if (!shouldDrag(axis, drag, _this.currentDirection))
	                return;
	            var axisValue = _this.getAxisMotionValue(axis);
	            if (axisValue) {
	                var box = _this.visualElement.getLayoutState().layout;
	                var length_1 = box[axis].max - box[axis].min;
	                var center = box[axis].min + length_1 / 2;
	                var offset = point[axis] - center;
	                _this.originPoint[axis] = point[axis];
	                axisValue.set(offset);
	            }
	            else {
	                _this.cursorProgress[axis] = 0.5;
	                return true;
	            }
	        }).includes(true);
	    };
	    /**
	     * Update the specified axis with the latest pointer information.
	     */
	    VisualElementDragControls.prototype.updateAxis = function (axis, point, offset) {
	        var drag = this.props.drag;
	        // If we're not dragging this axis, do an early return.
	        if (!shouldDrag(axis, drag, this.currentDirection))
	            return;
	        return this.getAxisMotionValue(axis)
	            ? this.updateAxisMotionValue(axis, offset)
	            : this.updateVisualElementAxis(axis, point);
	    };
	    VisualElementDragControls.prototype.updateAxisMotionValue = function (axis, offset) {
	        var axisValue = this.getAxisMotionValue(axis);
	        if (!offset || !axisValue)
	            return;
	        var nextValue = this.originPoint[axis] + offset[axis];
	        var update = this.constraints
	            ? applyConstraints(nextValue, this.constraints[axis], this.elastic[axis])
	            : nextValue;
	        axisValue.set(update);
	    };
	    VisualElementDragControls.prototype.updateVisualElementAxis = function (axis, point) {
	        var _a;
	        // Get the actual layout bounding box of the element
	        var axisLayout = this.visualElement.getLayoutState().layout[axis];
	        // Calculate its current length. In the future we might want to lerp this to animate
	        // between lengths if the layout changes as we change the DOM
	        var axisLength = axisLayout.max - axisLayout.min;
	        // Get the initial progress that the pointer sat on this axis on gesture start.
	        var axisProgress = this.cursorProgress[axis];
	        // Calculate a new min point based on the latest pointer position, constraints and elastic
	        var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], this.elastic[axis]);
	        // Update the axis viewport target with this new min and the length
	        this.visualElement.setProjectionTargetAxis(axis, min, min + axisLength);
	    };
	    VisualElementDragControls.prototype.setProps = function (_a) {
	        var _b = _a.drag, drag = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? defaultElastic : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = __rest(_a, ["drag", "dragDirectionLock", "dragPropagation", "dragConstraints", "dragElastic", "dragMomentum"]);
	        this.props = __assign({ drag: drag,
	            dragDirectionLock: dragDirectionLock,
	            dragPropagation: dragPropagation,
	            dragConstraints: dragConstraints,
	            dragElastic: dragElastic,
	            dragMomentum: dragMomentum }, remainingProps);
	    };
	    /**
	     * Drag works differently depending on which props are provided.
	     *
	     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
	     * - If the component will perform layout animations, we output the gesture to the component's
	     *      visual bounding box
	     * - Otherwise, we apply the delta to the x/y motion values.
	     */
	    VisualElementDragControls.prototype.getAxisMotionValue = function (axis) {
	        var _a = this.props, layout = _a.layout, layoutId = _a.layoutId;
	        var dragKey = "_drag" + axis.toUpperCase();
	        if (this.props[dragKey]) {
	            return this.props[dragKey];
	        }
	        else if (!layout && layoutId === undefined) {
	            return this.visualElement.getValue(axis, 0);
	        }
	    };
	    VisualElementDragControls.prototype.isLayoutDrag = function () {
	        return !this.getAxisMotionValue("x");
	    };
	    VisualElementDragControls.prototype.isExternalDrag = function () {
	        var _a = this.props, _dragX = _a._dragX, _dragY = _a._dragY;
	        return _dragX || _dragY;
	    };
	    VisualElementDragControls.prototype.animateDragEnd = function (velocity) {
	        var _this = this;
	        var _a = this.props, drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition;
	        /**
	         * Everything beyond the drag gesture should be performed with
	         * relative projection so children stay in sync with their parent element.
	         */
	        var isRelative = convertToRelativeProjection(this.visualElement, this.isLayoutDrag() && !this.isExternalDrag());
	        /**
	         * If we had previously resolved constraints relative to the viewport,
	         * we need to also convert those to a relative coordinate space for the animation
	         */
	        var constraints = this.constraints || {};
	        if (isRelative &&
	            Object.keys(constraints).length &&
	            this.isLayoutDrag()) {
	            var projectionParent = this.visualElement.getProjectionParent();
	            if (projectionParent) {
	                var relativeConstraints_1 = calcRelativeOffset(projectionParent.projection.targetFinal, constraints);
	                eachAxis(function (axis) {
	                    var _a = relativeConstraints_1[axis], min = _a.min, max = _a.max;
	                    constraints[axis] = {
	                        min: isNaN(min) ? undefined : min,
	                        max: isNaN(max) ? undefined : max,
	                    };
	                });
	            }
	        }
	        var momentumAnimations = eachAxis(function (axis) {
	            var _a;
	            if (!shouldDrag(axis, drag, _this.currentDirection)) {
	                return;
	            }
	            var transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};
	            /**
	             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame
	             * of spring animations so we should look into adding a disable spring option to `inertia`.
	             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`
	             * using the value of `dragElastic`.
	             */
	            var bounceStiffness = dragElastic ? 200 : 1000000;
	            var bounceDamping = dragElastic ? 40 : 10000000;
	            var inertia = __assign(__assign({ type: "inertia", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness,
	                bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition);
	            // If we're not animating on an externally-provided `MotionValue` we can use the
	            // component's animation controls which will handle interactions with whileHover (etc),
	            // otherwise we just have to animate the `MotionValue` itself.
	            return _this.getAxisMotionValue(axis)
	                ? _this.startAxisValueAnimation(axis, inertia)
	                : _this.visualElement.startLayoutAnimation(axis, inertia, isRelative);
	        });
	        // Run all animations and then resolve the new drag constraints.
	        return Promise.all(momentumAnimations).then(function () {
	            var _a, _b;
	            (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);
	        });
	    };
	    VisualElementDragControls.prototype.stopMotion = function () {
	        var _this = this;
	        eachAxis(function (axis) {
	            var axisValue = _this.getAxisMotionValue(axis);
	            axisValue
	                ? axisValue.stop()
	                : _this.visualElement.stopLayoutAnimation();
	        });
	    };
	    VisualElementDragControls.prototype.startAxisValueAnimation = function (axis, transition) {
	        var axisValue = this.getAxisMotionValue(axis);
	        if (!axisValue)
	            return;
	        var currentValue = axisValue.get();
	        axisValue.set(currentValue);
	        axisValue.set(currentValue); // Set twice to hard-reset velocity
	        return startAnimation(axis, axisValue, 0, transition);
	    };
	    VisualElementDragControls.prototype.scalePoint = function () {
	        var _this = this;
	        var _a = this.props, drag = _a.drag, dragConstraints = _a.dragConstraints;
	        if (!isRefObject(dragConstraints) || !this.constraintsBox)
	            return;
	        // Stop any current animations as there can be some visual glitching if we resize mid animation
	        this.stopMotion();
	        // Record the relative progress of the targetBox relative to the constraintsBox
	        var boxProgress = { x: 0, y: 0 };
	        eachAxis(function (axis) {
	            boxProgress[axis] = calcOrigin$1(_this.visualElement.projection.target[axis], _this.constraintsBox[axis]);
	        });
	        /**
	         * For each axis, calculate the current progress of the layout axis within the constraints.
	         * Then, using the latest layout and constraints measurements, reposition the new layout axis
	         * proportionally within the constraints.
	         */
	        this.updateConstraints(function () {
	            eachAxis(function (axis) {
	                if (!shouldDrag(axis, drag, null))
	                    return;
	                // Calculate the position of the targetBox relative to the constraintsBox using the
	                // previously calculated progress
	                var _a = calcPositionFromProgress(_this.visualElement.projection.target[axis], _this.constraintsBox[axis], boxProgress[axis]), min = _a.min, max = _a.max;
	                _this.visualElement.setProjectionTargetAxis(axis, min, max);
	            });
	        });
	        /**
	         * If any other draggable components are queuing the same tasks synchronously
	         * this will wait until they've all been scheduled before flushing.
	         */
	        setTimeout(flushLayout, 1);
	    };
	    VisualElementDragControls.prototype.updateConstraints = function (onReady) {
	        var _this = this;
	        this.cancelLayout = batchLayout(function (read, write) {
	            var ancestors = collectProjectingAncestors(_this.visualElement);
	            write(function () {
	                return ancestors.forEach(function (element) { return element.resetTransform(); });
	            });
	            read(function () { return updateLayoutMeasurement(_this.visualElement); });
	            write(function () {
	                return ancestors.forEach(function (element) { return element.restoreTransform(); });
	            });
	            read(function () {
	                _this.resolveDragConstraints();
	            });
	            if (onReady)
	                write(onReady);
	        });
	    };
	    VisualElementDragControls.prototype.mount = function (visualElement) {
	        var _this = this;
	        var element = visualElement.getInstance();
	        /**
	         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.
	         */
	        var stopPointerListener = addPointerEvent(element, "pointerdown", function (event) {
	            var _a = _this.props, drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;
	            drag && dragListener && _this.start(event);
	        });
	        /**
	         * Attach a window resize listener to scale the draggable target within its defined
	         * constraints as the window resizes.
	         */
	        var stopResizeListener = addDomEvent(window, "resize", function () {
	            _this.scalePoint();
	        });
	        /**
	         * Ensure drag constraints are resolved correctly relative to the dragging element
	         * whenever its layout changes.
	         */
	        var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {
	            if (_this.isDragging) {
	                _this.resolveDragConstraints();
	            }
	        });
	        /**
	         * If the previous component with this same layoutId was dragging at the time
	         * it was unmounted, we want to continue the same gesture on this component.
	         */
	        var prevDragCursor = visualElement.prevDragCursor;
	        if (prevDragCursor) {
	            this.start(lastPointerEvent, { cursorProgress: prevDragCursor });
	        }
	        /**
	         * Return a function that will teardown the drag gesture
	         */
	        return function () {
	            stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();
	            stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();
	            stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();
	            _this.cancelDrag();
	        };
	    };
	    return VisualElementDragControls;
	}());
	function shouldDrag(direction, drag, currentDirection) {
	    return ((drag === true || drag === direction) &&
	        (currentDirection === null || currentDirection === direction));
	}
	/**
	 * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower
	 * than the provided threshold, return `null`.
	 *
	 * @param offset - The x/y offset from origin.
	 * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.
	 */
	function getCurrentDirection(offset, lockThreshold) {
	    if (lockThreshold === void 0) { lockThreshold = 10; }
	    var direction = null;
	    if (Math.abs(offset.y) > lockThreshold) {
	        direction = "y";
	    }
	    else if (Math.abs(offset.x) > lockThreshold) {
	        direction = "x";
	    }
	    return direction;
	}

	/* node_modules/svelte-motion/src/gestures/drag/UseDrag.svelte generated by Svelte v4.2.10 */

	function create_fragment$F(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[7].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[6],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$F.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$F($$self, $$props, $$invalidate) {
		let $mcc;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UseDrag', slots, ['default']);
		let { visualElement, props, isCustom } = $$props;
		const mcc = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
		validate_store(mcc, 'mcc');
		component_subscribe($$self, mcc, value => $$invalidate(5, $mcc = value));
		let dragControls = new VisualElementDragControls({ visualElement });

		// If we've been provided a DragControls for manual control over the drag gesture,
		// subscribe this component to it on mount.
		let cleanup;

		const dragEffect = () => {
			if (cleanup) {
				cleanup();
			}

			if (groupDragControls) {
				cleanup = groupDragControls.subscribe(dragControls);
			}
		};

		let { dragControls: groupDragControls } = props;
		let { transformPagePoint } = get_store_value(mcc);
		dragControls.setProps({ ...props, transformPagePoint });

		onDestroy(() => {
			if (cleanup) {
				cleanup();
			}
		});

		onMount(() => dragControls.mount(visualElement));

		$$self.$$.on_mount.push(function () {
			if (visualElement === undefined && !('visualElement' in $$props || $$self.$$.bound[$$self.$$.props['visualElement']])) {
				console.warn("<UseDrag> was created without expected prop 'visualElement'");
			}

			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<UseDrag> was created without expected prop 'props'");
			}

			if (isCustom === undefined && !('isCustom' in $$props || $$self.$$.bound[$$self.$$.props['isCustom']])) {
				console.warn("<UseDrag> was created without expected prop 'isCustom'");
			}
		});

		const writable_props = ['visualElement', 'props', 'isCustom'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UseDrag> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('visualElement' in $$props) $$invalidate(1, visualElement = $$props.visualElement);
			if ('props' in $$props) $$invalidate(2, props = $$props.props);
			if ('isCustom' in $$props) $$invalidate(3, isCustom = $$props.isCustom);
			if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			MotionConfigContext,
			VisualElementDragControls,
			getContext,
			onDestroy,
			onMount,
			get: get_store_value,
			visualElement,
			props,
			isCustom,
			mcc,
			dragControls,
			cleanup,
			dragEffect,
			groupDragControls,
			transformPagePoint,
			$mcc
		});

		$$self.$inject_state = $$props => {
			if ('visualElement' in $$props) $$invalidate(1, visualElement = $$props.visualElement);
			if ('props' in $$props) $$invalidate(2, props = $$props.props);
			if ('isCustom' in $$props) $$invalidate(3, isCustom = $$props.isCustom);
			if ('dragControls' in $$props) $$invalidate(10, dragControls = $$props.dragControls);
			if ('cleanup' in $$props) cleanup = $$props.cleanup;
			if ('groupDragControls' in $$props) groupDragControls = $$props.groupDragControls;
			if ('transformPagePoint' in $$props) $$invalidate(4, transformPagePoint = $$props.transformPagePoint);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*props*/ 4) {
				({ dragControls: groupDragControls } = props);
			}

			if ($$self.$$.dirty & /*$mcc*/ 32) {
				//let {transformPagePoint} = get($mcc);
				$$invalidate(4, { transformPagePoint } = $mcc, transformPagePoint);
			}

			if ($$self.$$.dirty & /*props, transformPagePoint*/ 20) {
				//dragControls.setProps({ ...props, transformPagePoint })
				dragControls.setProps({ ...props, transformPagePoint });
			}
		};

		dragEffect();
		return [mcc, visualElement, props, isCustom, transformPagePoint, $mcc, $$scope, slots];
	}

	class UseDrag extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$F, create_fragment$F, safe_not_equal, { visualElement: 1, props: 2, isCustom: 3 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UseDrag",
				options,
				id: create_fragment$F.name
			});
		}

		get visualElement() {
			throw new Error("<UseDrag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualElement(value) {
			throw new Error("<UseDrag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get props() {
			throw new Error("<UseDrag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<UseDrag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isCustom() {
			throw new Error("<UseDrag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isCustom(value) {
			throw new Error("<UseDrag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var UseDrag$1 = UseDrag;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/


	/**
	 * @public
	 */
	const drag = {
	    pan: UsePanGesture$1,
	    drag: UseDrag$1
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	function pixelsToPercent(pixels, axis) {
	    return (pixels / (axis.max - axis.min)) * 100;
	}
	/**
	 * We always correct borderRadius as a percentage rather than pixels to reduce paints.
	 * For example, if you are projecting a box that is 100px wide with a 10px borderRadius
	 * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%
	 * borderRadius in both states. If we animate between the two in pixels that will trigger
	 * a paint each time. If we animate between the two in percentage we'll avoid a paint.
	 */
	function correctBorderRadius(latest, _layoutState, _a) {
	    var target = _a.target;
	    /**
	     * If latest is a string, if it's a percentage we can return immediately as it's
	     * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.
	     */
	    if (typeof latest === "string") {
	        if (px.test(latest)) {
	            latest = parseFloat(latest);
	        }
	        else {
	            return latest;
	        }
	    }
	    /**
	     * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that
	     * pixel value as a percentage of each axis
	     */
	    var x = pixelsToPercent(latest, target.x);
	    var y = pixelsToPercent(latest, target.y);
	    return x + "% " + y + "%";
	}
	var varToken = "_$css";
	function correctBoxShadow(latest, _a) {
	    var delta = _a.delta, treeScale = _a.treeScale;
	    var original = latest;
	    /**
	     * We need to first strip and store CSS variables from the string.
	     */
	    var containsCSSVariables = latest.includes("var(");
	    var cssVariables = [];
	    if (containsCSSVariables) {
	        latest = latest.replace(cssVariableRegex, function (match) {
	            cssVariables.push(match);
	            return varToken;
	        });
	    }
	    var shadow = complex.parse(latest);
	    // TODO: Doesn't support multiple shadows
	    if (shadow.length > 5)
	        return original;
	    var template = complex.createTransformer(latest);
	    var offset = typeof shadow[0] !== "number" ? 1 : 0;
	    // Calculate the overall context scale
	    var xScale = delta.x.scale * treeScale.x;
	    var yScale = delta.y.scale * treeScale.y;
	    shadow[0 + offset] /= xScale;
	    shadow[1 + offset] /= yScale;
	    /**
	     * Ideally we'd correct x and y scales individually, but because blur and
	     * spread apply to both we have to take a scale average and apply that instead.
	     * We could potentially improve the outcome of this by incorporating the ratio between
	     * the two scales.
	     */
	    var averageScale = mix$1(xScale, yScale, 0.5);
	    // Blur
	    if (typeof shadow[2 + offset] === "number")
	        shadow[2 + offset] /= averageScale;
	    // Spread
	    if (typeof shadow[3 + offset] === "number")
	        shadow[3 + offset] /= averageScale;
	    var output = template(shadow);
	    if (containsCSSVariables) {
	        var i_1 = 0;
	        output = output.replace(varToken, function () {
	            var cssVariable = cssVariables[i_1];
	            i_1++;
	            return cssVariable;
	        });
	    }
	    return output;
	}
	var borderCorrectionDefinition = {
	    process: correctBorderRadius,
	};
	var defaultScaleCorrectors = {
	    borderRadius: __assign(__assign({}, borderCorrectionDefinition), { applyTo: [
	            "borderTopLeftRadius",
	            "borderTopRightRadius",
	            "borderBottomLeftRadius",
	            "borderBottomRightRadius",
	        ] }),
	    borderTopLeftRadius: borderCorrectionDefinition,
	    borderTopRightRadius: borderCorrectionDefinition,
	    borderBottomLeftRadius: borderCorrectionDefinition,
	    borderBottomRightRadius: borderCorrectionDefinition,
	    boxShadow: {
	        process: correctBoxShadow,
	    },
	};

	/* node_modules/svelte-motion/src/motion/features/layout/Animate.svelte generated by Svelte v4.2.10 */

	function create_fragment$E(ctx) {
		const block = {
			c: noop$3,
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: noop$3,
			p: noop$3,
			i: noop$3,
			o: noop$3,
			d: noop$3
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$E.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	const progressTarget = 1000;

	function hasMoved(a, b) {
		return !isZeroBox(a) && !isZeroBox(b) && (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y));
	}

	const zeroAxis = { min: 0, max: 0 };

	function isZeroBox(a) {
		return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);
	}

	function axisIsEqual(a, b) {
		return a.min === b.min && a.max === b.max;
	}

	const defaultLayoutTransition = { duration: 0.45, ease: [0.4, 0, 0.1, 1] };

	function instance$E($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Animate', slots, []);
		let { visualElement, layout = undefined, safeToRemove } = $$props;

		/**
	 * A mutable object that tracks the target viewport box
	 * for the current animation frame.
	 */
		let frameTarget = axisBox();

		/**
	 * The current animation target, we use this to check whether to start
	 * a new animation or continue the existing one.
	 */
		let currentAnimationTarget = axisBox();

		/**
	 * Track whether we're animating this axis.
	 */
		let isAnimating = { x: false, y: false };

		let stopAxisAnimation = { x: undefined, y: undefined };
		let unsubLayoutReady;
		let isAnimatingTree = false;

		onMount(() => {
			$$invalidate(0, visualElement.animateMotionValue = startAnimation, visualElement);
			visualElement.enableLayoutProjection();
			unsubLayoutReady = visualElement.onLayoutUpdate(animateF);

			$$invalidate(
				0,
				visualElement.layoutSafeToRemove = function () {
					safeToRemove();
				},
				visualElement
			);

			addScaleCorrection(defaultScaleCorrectors);
		});

		onDestroy(() => {
			unsubLayoutReady();
			eachAxis(axis => stopAxisAnimation[axis]?.());
		});

		const animateF = (target, origin, { originBox, targetBox, visibilityAction, shouldStackAnimate, onComplete, ...config } = {}) => {
			/**
	 * Early return if we've been instructed not to animate this render.
	 */
			if (shouldStackAnimate === false) {
				isAnimatingTree = false;
				return safeToRemove();
			}

			/**
	 * Prioritise tree animations
	 */
			if (isAnimatingTree && shouldStackAnimate !== true) {
				return;
			} else if (shouldStackAnimate) {
				isAnimatingTree = true;
			}

			/**
	 * Allow the measured origin (prev bounding box) and target (actual layout) to be
	 * overridden by the provided config.
	 */
			origin = originBox || origin;

			target = targetBox || target;
			const boxHasMoved = hasMoved(origin, target);

			const animations = eachAxis(axis => {
				/**
	 * If layout is set to "position", we can resize the origin box based on the target
	 * box and only animate its position.
	 */
				if (layout === "position") {
					const targetLength = target[axis].max - target[axis].min;
					origin[axis].max = origin[axis].min + targetLength;
				}

				if (visualElement.projection.isTargetLocked) {
					return;
				} else if (visibilityAction !== undefined) {
					visualElement.setVisibility(visibilityAction === VisibilityAction.Show);
				} else if (boxHasMoved) {
					// If the box has moved, animate between it's current visual state and its
					// final state
					return animateAxis(axis, target[axis], origin[axis], config);
				} else {
					// If the box has remained in the same place, immediately set the axis target
					// to the final desired state
					return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max);
				}
			});

			// Force a render to ensure there's no flash of uncorrected bounding box.
			visualElement.syncRender();

			/**
	 * If this visualElement isn't present (ie it's been removed from the tree by the user but
	 * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations
	 * have successfully finished.
	 */
			return Promise.all(animations).then(() => {
				isAnimatingTree = false;
				onComplete && onComplete();
				visualElement.notifyLayoutAnimationComplete();
			});
		};

		/**
	 * TODO: This manually performs animations on the visualElement's layout progress
	 * values. It'd be preferable to amend the startLayoutAxisAnimation
	 * API to accept more custom animations like
	 */
		const animateAxis = (axis, target, origin, { transition: _transition } = {}) => {
			stopAxisAnimation[axis]?.();

			/**
	 * If we're not animating to a new target, don't run this animation
	 */
			if (isAnimating[axis] && axisIsEqual(target, currentAnimationTarget[axis])) {
				return;
			}

			stopAxisAnimation[axis]?.();
			isAnimating[axis] = true;
			const _frameTarget = frameTarget[axis];
			const layoutProgress = visualElement.getProjectionAnimationProgress()[axis];

			/**
	 * Set layout progress back to 0. We set it twice to hard-reset any velocity that might
	 * be re-incoporated into a subsequent spring animation.
	 */
			layoutProgress.clearListeners();

			layoutProgress.set(0);
			layoutProgress.set(0);

			/**
	 * Create an animation function to run once per frame. This will tween the visual bounding box from
	 * origin to target using the latest progress value.
	 */
			const frame = () => {
				// Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress
				const p = layoutProgress.get() / progressTarget;

				// Tween the axis and update the visualElement with the latest values
				tweenAxis(_frameTarget, origin, target, p);

				visualElement.setProjectionTargetAxis(axis, _frameTarget.min, _frameTarget.max);
			};

			// Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.
			frame();

			// Ensure that the layout delta is updated for this frame.
			//visualElement.updateLayoutProjection();
			// Create a function to stop animation on this specific axis
			const unsubscribeProgress = layoutProgress.onChange(frame);

			stopAxisAnimation[axis] = () => {
				isAnimating[axis] = false;
				layoutProgress.stop();
				unsubscribeProgress();
			};

			currentAnimationTarget[axis] = target;
			const layoutTransition = _transition || visualElement.getDefaultTransition() || defaultLayoutTransition;

			// Start the animation on this axis
			const animation = startAnimation(axis === "x" ? "layoutX" : "layoutY", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, "layout")).then(stopAxisAnimation[axis]);

			return animation;
		};

		$$self.$$.on_mount.push(function () {
			if (visualElement === undefined && !('visualElement' in $$props || $$self.$$.bound[$$self.$$.props['visualElement']])) {
				console.warn("<Animate> was created without expected prop 'visualElement'");
			}

			if (safeToRemove === undefined && !('safeToRemove' in $$props || $$self.$$.bound[$$self.$$.props['safeToRemove']])) {
				console.warn("<Animate> was created without expected prop 'safeToRemove'");
			}
		});

		const writable_props = ['visualElement', 'layout', 'safeToRemove'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Animate> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('layout' in $$props) $$invalidate(1, layout = $$props.layout);
			if ('safeToRemove' in $$props) $$invalidate(2, safeToRemove = $$props.safeToRemove);
		};

		$$self.$capture_state = () => ({
			progressTarget,
			hasMoved,
			zeroAxis,
			isZeroBox,
			axisIsEqual,
			defaultLayoutTransition,
			onDestroy,
			onMount,
			axisBox,
			eachAxis,
			startAnimation,
			getValueTransition,
			tweenAxis,
			addScaleCorrection,
			defaultScaleCorrectors,
			visualElement,
			layout,
			safeToRemove,
			frameTarget,
			currentAnimationTarget,
			isAnimating,
			stopAxisAnimation,
			unsubLayoutReady,
			isAnimatingTree,
			animateF,
			animateAxis
		});

		$$self.$inject_state = $$props => {
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('layout' in $$props) $$invalidate(1, layout = $$props.layout);
			if ('safeToRemove' in $$props) $$invalidate(2, safeToRemove = $$props.safeToRemove);
			if ('frameTarget' in $$props) frameTarget = $$props.frameTarget;
			if ('currentAnimationTarget' in $$props) currentAnimationTarget = $$props.currentAnimationTarget;
			if ('isAnimating' in $$props) isAnimating = $$props.isAnimating;
			if ('stopAxisAnimation' in $$props) stopAxisAnimation = $$props.stopAxisAnimation;
			if ('unsubLayoutReady' in $$props) unsubLayoutReady = $$props.unsubLayoutReady;
			if ('isAnimatingTree' in $$props) isAnimatingTree = $$props.isAnimatingTree;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [visualElement, layout, safeToRemove];
	}

	class Animate extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$E, create_fragment$E, safe_not_equal, {
				visualElement: 0,
				layout: 1,
				safeToRemove: 2
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Animate",
				options,
				id: create_fragment$E.name
			});
		}

		get visualElement() {
			throw new Error("<Animate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualElement(value) {
			throw new Error("<Animate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get layout() {
			throw new Error("<Animate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set layout(value) {
			throw new Error("<Animate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get safeToRemove() {
			throw new Error("<Animate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set safeToRemove(value) {
			throw new Error("<Animate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var Animate$1 = Animate;

	/* node_modules/svelte-motion/src/motion/features/layout/AnimateLayoutContextProvider.svelte generated by Svelte v4.2.10 */

	function create_fragment$D(ctx) {
		let animate;
		let current;

		animate = new Animate$1({
				props: {
					visualElement: /*visualElement*/ ctx[0],
					layout: /*layout*/ ctx[1],
					safeToRemove: /*$presence*/ ctx[2][1]
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(animate.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(animate, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const animate_changes = {};
				if (dirty & /*visualElement*/ 1) animate_changes.visualElement = /*visualElement*/ ctx[0];
				if (dirty & /*layout*/ 2) animate_changes.layout = /*layout*/ ctx[1];
				if (dirty & /*$presence*/ 4) animate_changes.safeToRemove = /*$presence*/ ctx[2][1];
				animate.$set(animate_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(animate.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(animate.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(animate, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$D.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$D($$self, $$props, $$invalidate) {
		let $presence;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('AnimateLayoutContextProvider', slots, []);
		let { visualElement, props, isCustom } = $$props;
		let { layout } = props;
		const presence = usePresence(isCustom);
		validate_store(presence, 'presence');
		component_subscribe($$self, presence, value => $$invalidate(2, $presence = value));

		$$self.$$.on_mount.push(function () {
			if (visualElement === undefined && !('visualElement' in $$props || $$self.$$.bound[$$self.$$.props['visualElement']])) {
				console.warn("<AnimateLayoutContextProvider> was created without expected prop 'visualElement'");
			}

			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<AnimateLayoutContextProvider> was created without expected prop 'props'");
			}

			if (isCustom === undefined && !('isCustom' in $$props || $$self.$$.bound[$$self.$$.props['isCustom']])) {
				console.warn("<AnimateLayoutContextProvider> was created without expected prop 'isCustom'");
			}
		});

		const writable_props = ['visualElement', 'props', 'isCustom'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AnimateLayoutContextProvider> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('props' in $$props) $$invalidate(4, props = $$props.props);
			if ('isCustom' in $$props) $$invalidate(5, isCustom = $$props.isCustom);
		};

		$$self.$capture_state = () => ({
			usePresence,
			Animate: Animate$1,
			visualElement,
			props,
			isCustom,
			layout,
			presence,
			$presence
		});

		$$self.$inject_state = $$props => {
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('props' in $$props) $$invalidate(4, props = $$props.props);
			if ('isCustom' in $$props) $$invalidate(5, isCustom = $$props.isCustom);
			if ('layout' in $$props) $$invalidate(1, layout = $$props.layout);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*props*/ 16) {
				$$invalidate(1, { layout } = props, layout);
			}
		};

		return [visualElement, layout, $presence, presence, props, isCustom];
	}

	class AnimateLayoutContextProvider extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$D, create_fragment$D, safe_not_equal, { visualElement: 0, props: 4, isCustom: 5 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "AnimateLayoutContextProvider",
				options,
				id: create_fragment$D.name
			});
		}

		get visualElement() {
			throw new Error("<AnimateLayoutContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualElement(value) {
			throw new Error("<AnimateLayoutContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get props() {
			throw new Error("<AnimateLayoutContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<AnimateLayoutContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isCustom() {
			throw new Error("<AnimateLayoutContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isCustom(value) {
			throw new Error("<AnimateLayoutContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var AnimateLayoutContextProvider$1 = AnimateLayoutContextProvider;

	/* node_modules/svelte-motion/src/motion/features/layout/Measure.svelte generated by Svelte v4.2.10 */

	function create_fragment$C(ctx) {
		const block = {
			c: noop$3,
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: noop$3,
			p: noop$3,
			i: noop$3,
			o: noop$3,
			d: noop$3
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$C.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$C($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Measure', slots, []);
		let { visualElement, syncLayout, framerSyncLayout, update } = $$props;
		const scaleCorrectionContext = getContext(ScaleCorrectionContext);
		const scaleCorrectionParentContext = getContext(ScaleCorrectionParentContext);

		onMount(() => {
			isSharedLayout(syncLayout) && syncLayout.register(visualElement);
			isSharedLayout(framerSyncLayout) && framerSyncLayout.register(visualElement);

			visualElement.onUnmount(() => {
				if (isSharedLayout(syncLayout)) {
					syncLayout.remove(visualElement);
				}

				if (isSharedLayout(framerSyncLayout)) {
					framerSyncLayout.remove(visualElement);
				}
			});
		});

		/**
	 * If this is a child of a SyncContext, notify it that it needs to re-render. It will then
	 * handle the snapshotting.
	 *
	 * If it is stand-alone component, add it to the batcher.
	 */
		let updated = false;

		const updater = (nc = false) => {
			if (updated) {
				return null;
			}

			updated = true;

			// in React the updater function is called on children first, in Svelte the child does not call it.
			get_store_value(scaleCorrectionContext).forEach(v => {
				v.updater?.(true);
			});

			if (isSharedLayout(syncLayout)) {
				syncLayout.syncUpdate();
			} else {
				snapshotViewportBox(visualElement, nc);
				syncLayout.add(visualElement);
			}

			return null;
		};

		if (update === undefined) {
			beforeUpdate(updater);
		}

		const afterU = (nc = false) => {
			updated = false;

			/* Second part of the updater calling in child layouts first.*/
			const scc = get_store_value(scaleCorrectionContext);

			scc.forEach((v, i) => {
				v.afterU?.(true);
			});

			if (!isSharedLayout(syncLayout)) {
				syncLayout.flush();
			}
		}; /**
	 * If this axis isn't animating as a result of this render we want to reset the targetBox
	 * to the measured box
	 */ //setCurrentViewportBox(visualElement);

		scaleCorrectionParentContext.update(v => v.concat([{ updater, afterU }]));
		afterUpdate(afterU);

		$$self.$$.on_mount.push(function () {
			if (visualElement === undefined && !('visualElement' in $$props || $$self.$$.bound[$$self.$$.props['visualElement']])) {
				console.warn("<Measure> was created without expected prop 'visualElement'");
			}

			if (syncLayout === undefined && !('syncLayout' in $$props || $$self.$$.bound[$$self.$$.props['syncLayout']])) {
				console.warn("<Measure> was created without expected prop 'syncLayout'");
			}

			if (framerSyncLayout === undefined && !('framerSyncLayout' in $$props || $$self.$$.bound[$$self.$$.props['framerSyncLayout']])) {
				console.warn("<Measure> was created without expected prop 'framerSyncLayout'");
			}

			if (update === undefined && !('update' in $$props || $$self.$$.bound[$$self.$$.props['update']])) {
				console.warn("<Measure> was created without expected prop 'update'");
			}
		});

		const writable_props = ['visualElement', 'syncLayout', 'framerSyncLayout', 'update'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Measure> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('syncLayout' in $$props) $$invalidate(1, syncLayout = $$props.syncLayout);
			if ('framerSyncLayout' in $$props) $$invalidate(2, framerSyncLayout = $$props.framerSyncLayout);
			if ('update' in $$props) $$invalidate(3, update = $$props.update);
		};

		$$self.$capture_state = () => ({
			afterUpdate,
			beforeUpdate,
			getContext,
			onMount,
			get: get_store_value,
			ScaleCorrectionContext,
			ScaleCorrectionParentContext,
			isSharedLayout,
			snapshotViewportBox,
			visualElement,
			syncLayout,
			framerSyncLayout,
			update,
			scaleCorrectionContext,
			scaleCorrectionParentContext,
			updated,
			updater,
			afterU
		});

		$$self.$inject_state = $$props => {
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('syncLayout' in $$props) $$invalidate(1, syncLayout = $$props.syncLayout);
			if ('framerSyncLayout' in $$props) $$invalidate(2, framerSyncLayout = $$props.framerSyncLayout);
			if ('update' in $$props) $$invalidate(3, update = $$props.update);
			if ('updated' in $$props) updated = $$props.updated;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*update*/ 8) {
				update !== undefined && updater(update);
			}
		};

		return [visualElement, syncLayout, framerSyncLayout, update];
	}

	class Measure extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$C, create_fragment$C, safe_not_equal, {
				visualElement: 0,
				syncLayout: 1,
				framerSyncLayout: 2,
				update: 3
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Measure",
				options,
				id: create_fragment$C.name
			});
		}

		get visualElement() {
			throw new Error("<Measure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualElement(value) {
			throw new Error("<Measure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get syncLayout() {
			throw new Error("<Measure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set syncLayout(value) {
			throw new Error("<Measure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get framerSyncLayout() {
			throw new Error("<Measure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set framerSyncLayout(value) {
			throw new Error("<Measure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get update() {
			throw new Error("<Measure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set update(value) {
			throw new Error("<Measure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var Measure$1 = Measure;

	/* node_modules/svelte-motion/src/motion/features/layout/MeasureContextProvider.svelte generated by Svelte v4.2.10 */

	function create_fragment$B(ctx) {
		let measure;
		let current;

		measure = new Measure$1({
				props: {
					syncLayout: /*$syncLayout*/ ctx[2],
					framerSyncLayout: /*$framerSyncLayout*/ ctx[3],
					visualElement: /*visualElement*/ ctx[0],
					update: /*update*/ ctx[1]
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(measure.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(measure, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const measure_changes = {};
				if (dirty & /*$syncLayout*/ 4) measure_changes.syncLayout = /*$syncLayout*/ ctx[2];
				if (dirty & /*$framerSyncLayout*/ 8) measure_changes.framerSyncLayout = /*$framerSyncLayout*/ ctx[3];
				if (dirty & /*visualElement*/ 1) measure_changes.visualElement = /*visualElement*/ ctx[0];
				if (dirty & /*update*/ 2) measure_changes.update = /*update*/ ctx[1];
				measure.$set(measure_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(measure.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(measure.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(measure, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$B.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$B($$self, $$props, $$invalidate) {
		let update;
		let $syncLayout;
		let $framerSyncLayout;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('MeasureContextProvider', slots, []);
		let { visualElement, props, isCustom } = $$props;
		const syncLayout = getContext(SharedLayoutContext) || SharedLayoutContext(isCustom);
		validate_store(syncLayout, 'syncLayout');
		component_subscribe($$self, syncLayout, value => $$invalidate(2, $syncLayout = value));
		const framerSyncLayout = getContext(FramerTreeLayoutContext) || FramerTreeLayoutContext();
		validate_store(framerSyncLayout, 'framerSyncLayout');
		component_subscribe($$self, framerSyncLayout, value => $$invalidate(3, $framerSyncLayout = value));

		$$self.$$.on_mount.push(function () {
			if (visualElement === undefined && !('visualElement' in $$props || $$self.$$.bound[$$self.$$.props['visualElement']])) {
				console.warn("<MeasureContextProvider> was created without expected prop 'visualElement'");
			}

			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<MeasureContextProvider> was created without expected prop 'props'");
			}

			if (isCustom === undefined && !('isCustom' in $$props || $$self.$$.bound[$$self.$$.props['isCustom']])) {
				console.warn("<MeasureContextProvider> was created without expected prop 'isCustom'");
			}
		});

		const writable_props = ['visualElement', 'props', 'isCustom'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MeasureContextProvider> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('props' in $$props) $$invalidate(6, props = $$props.props);
			if ('isCustom' in $$props) $$invalidate(7, isCustom = $$props.isCustom);
		};

		$$self.$capture_state = () => ({
			getContext,
			SharedLayoutContext,
			FramerTreeLayoutContext,
			Measure: Measure$1,
			visualElement,
			props,
			isCustom,
			syncLayout,
			framerSyncLayout,
			update,
			$syncLayout,
			$framerSyncLayout
		});

		$$self.$inject_state = $$props => {
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('props' in $$props) $$invalidate(6, props = $$props.props);
			if ('isCustom' in $$props) $$invalidate(7, isCustom = $$props.isCustom);
			if ('update' in $$props) $$invalidate(1, update = $$props.update);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*props*/ 64) {
				$$invalidate(1, { update } = props, update);
			}
		};

		return [
			visualElement,
			update,
			$syncLayout,
			$framerSyncLayout,
			syncLayout,
			framerSyncLayout,
			props,
			isCustom
		];
	}

	class MeasureContextProvider extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$B, create_fragment$B, safe_not_equal, { visualElement: 0, props: 6, isCustom: 7 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "MeasureContextProvider",
				options,
				id: create_fragment$B.name
			});
		}

		get visualElement() {
			throw new Error("<MeasureContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualElement(value) {
			throw new Error("<MeasureContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get props() {
			throw new Error("<MeasureContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<MeasureContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isCustom() {
			throw new Error("<MeasureContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isCustom(value) {
			throw new Error("<MeasureContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var MeasureContextProvider$1 = MeasureContextProvider;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/


	var layoutAnimations = {
	    measureLayout: MeasureContextProvider$1,
	    layoutAnimation: AnimateLayoutContextProvider$1
	};

	/* node_modules/svelte-motion/src/motion/features/AnimationState.svelte generated by Svelte v4.2.10 */

	function create_fragment$A(ctx) {
		const block = {
			c: noop$3,
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: noop$3,
			p: noop$3,
			i: noop$3,
			o: noop$3,
			d: noop$3
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$A.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$A($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('AnimationState', slots, []);
		let { visualElement, props } = $$props;
		let { animate } = props;

		$$self.$$.on_mount.push(function () {
			if (visualElement === undefined && !('visualElement' in $$props || $$self.$$.bound[$$self.$$.props['visualElement']])) {
				console.warn("<AnimationState> was created without expected prop 'visualElement'");
			}

			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<AnimationState> was created without expected prop 'props'");
			}
		});

		const writable_props = ['visualElement', 'props'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AnimationState> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('props' in $$props) $$invalidate(1, props = $$props.props);
		};

		$$self.$capture_state = () => ({
			tick,
			createAnimationState,
			isAnimationControls,
			visualElement,
			props,
			animate
		});

		$$self.$inject_state = $$props => {
			if ('visualElement' in $$props) $$invalidate(0, visualElement = $$props.visualElement);
			if ('props' in $$props) $$invalidate(1, props = $$props.props);
			if ('animate' in $$props) $$invalidate(2, animate = $$props.animate);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*props*/ 2) {
				$$invalidate(2, { animate } = props, animate);
			}

			if ($$self.$$.dirty & /*visualElement*/ 1) {
				/**
	 * We dynamically generate the AnimationState manager as it contains a reference
	 * to the underlying animation library. We only want to load that if we load this,
	 * so people can optionally code split it out using the `m` component.
	 */
				{
					$$invalidate(0, visualElement.animationState = visualElement.animationState || createAnimationState(visualElement), visualElement);
				}
			}

			if ($$self.$$.dirty & /*animate, visualElement*/ 5) {
				/**
	 * Subscribe any provided AnimationControls to the component's VisualElement
	 */
				if (isAnimationControls(animate)) {
					tick().then(() => animate.subscribe(visualElement)); /*, [animate]*/
				}
			}
		};

		return [visualElement, props, animate];
	}

	class AnimationState extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$A, create_fragment$A, safe_not_equal, { visualElement: 0, props: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "AnimationState",
				options,
				id: create_fragment$A.name
			});
		}

		get visualElement() {
			throw new Error("<AnimationState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualElement(value) {
			throw new Error("<AnimationState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get props() {
			throw new Error("<AnimationState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<AnimationState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var AnimationState$1 = AnimationState;

	/* node_modules/svelte-motion/src/motion/features/Exit.svelte generated by Svelte v4.2.10 */

	function create_fragment$z(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[7].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[6],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$z.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$z($$self, $$props, $$invalidate) {
		let custom;
		let $presence;
		let $presenceContext;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Exit', slots, ['default']);
		let { props, visualElement, isCustom } = $$props;
		const presenceContext = getContext(PresenceContext) || PresenceContext(isCustom);
		validate_store(presenceContext, 'presenceContext');
		component_subscribe($$self, presenceContext, value => $$invalidate(9, $presenceContext = value));
		const presence = usePresence(isCustom);
		validate_store(presence, 'presence');
		component_subscribe($$self, presence, value => $$invalidate(5, $presence = value));

		const effect = pres => {
			const [isPresent, onExitComplete] = pres;

			const animation = visualElement.animationState?.setActive(AnimationType.Exit, !isPresent, {
				custom: $presenceContext?.custom ?? custom
			});

			!isPresent && animation?.then(onExitComplete);
			return "";
		};

		$$self.$$.on_mount.push(function () {
			if (props === undefined && !('props' in $$props || $$self.$$.bound[$$self.$$.props['props']])) {
				console.warn("<Exit> was created without expected prop 'props'");
			}

			if (visualElement === undefined && !('visualElement' in $$props || $$self.$$.bound[$$self.$$.props['visualElement']])) {
				console.warn("<Exit> was created without expected prop 'visualElement'");
			}

			if (isCustom === undefined && !('isCustom' in $$props || $$self.$$.bound[$$self.$$.props['isCustom']])) {
				console.warn("<Exit> was created without expected prop 'isCustom'");
			}
		});

		const writable_props = ['props', 'visualElement', 'isCustom'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Exit> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('props' in $$props) $$invalidate(2, props = $$props.props);
			if ('visualElement' in $$props) $$invalidate(3, visualElement = $$props.visualElement);
			if ('isCustom' in $$props) $$invalidate(4, isCustom = $$props.isCustom);
			if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			usePresence,
			getContext,
			PresenceContext,
			AnimationType,
			props,
			visualElement,
			isCustom,
			presenceContext,
			presence,
			effect,
			custom,
			$presence,
			$presenceContext
		});

		$$self.$inject_state = $$props => {
			if ('props' in $$props) $$invalidate(2, props = $$props.props);
			if ('visualElement' in $$props) $$invalidate(3, visualElement = $$props.visualElement);
			if ('isCustom' in $$props) $$invalidate(4, isCustom = $$props.isCustom);
			if ('custom' in $$props) custom = $$props.custom;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*props*/ 4) {
				({ custom } = props);
			}

			if ($$self.$$.dirty & /*$presence*/ 32) {
				effect($presence);
			}
		};

		return [
			presenceContext,
			presence,
			props,
			visualElement,
			isCustom,
			$presence,
			$$scope,
			slots
		];
	}

	class Exit extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$z, create_fragment$z, safe_not_equal, { props: 2, visualElement: 3, isCustom: 4 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Exit",
				options,
				id: create_fragment$z.name
			});
		}

		get props() {
			throw new Error("<Exit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set props(value) {
			throw new Error("<Exit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get visualElement() {
			throw new Error("<Exit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set visualElement(value) {
			throw new Error("<Exit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isCustom() {
			throw new Error("<Exit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isCustom(value) {
			throw new Error("<Exit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var Exit$1 = Exit;

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	/**
	 * @public
	 */
	const animations = {
	    animation: AnimationState$1,
	    exit:Exit$1
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	const featureBundle = {
	    ...animations,
	    ...gestureAnimations,
	    ...drag,
	    ...layoutAnimations,
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/
	//import { createMotionProxy } from './motion-proxy.js';



	/**
	 * HTML & SVG components, optimised for use with gestures and animation. These can be used as
	 * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.
	 *
	 * @public
	 */
	var motion = /*@__PURE__*/ //createMotionProxy(allMotionFeatures);
	    createMotionClass(featureBundle);

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/

	const useCombineMotionValues = (values, combineValues) => {

	  let subscriptions = [];
	  let vals = values;

	  
	  const unsubscribe = ()=>{
	    subscriptions.forEach((unsubscribe) => unsubscribe());
	  };
	  const subscribe = () => {
	    subscriptions = vals.map((val) => val.onChange(handler));
	    updateValue();
	  };
	  const value = motionValue(combineValues(), () => {
	    unsubscribe();
	    subscribe();
	    return unsubscribe;
	  });

	  let updateValue = () => {
	    value.set(combineValues());
	  };

	  const handler = () => {
	    sync.update(updateValue, false, true);
	  };

	  value.reset = (_values, _combineValues) => {
	    vals=_values;
	    //cleanup and reset
	    unsubscribe();
	    updateValue = () => {
	      value.set(_combineValues());
	    };
	    subscribe();
	  };

	  return value;
	};
	//export { default as UseCombineMotionValues } from "./UseCombineValues.svelte";

	/**
	 * Combine multiple motion values into a new one using a string template literal.
	 *
	 * ```jsx
	 * import {
	 *   motion,
	 *   useSpring,
	 *   useMotionValue,
	 *   useMotionTemplate
	 * } from "framer-motion"
	 *
	 * function Component() {
	 *   const shadowX = useSpring(0)
	 *   const shadowY = useMotionValue(0)
	 *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`
	 *
	 *   return <MotionDiv style={{ filter: shadow }} />
	 * }
	 * ```
	 *
	 * @public
	 */

	const useMotionTemplate = (fragments, ...values) => {
	    /**
	    * Create a function that will build a string from the latest motion values.
	    */
	    let numFragments = fragments.length;
	    const buildValue = () => {
	        let output = ``;

	        for (let i = 0; i < numFragments; i++) {
	            output += fragments[i];
	            const value = values[i];
	            if (value) output += values[i].get();
	        }

	        return output
	    };
	    const value = useCombineMotionValues(values, buildValue);
	    value.resetInner = value.reset;

	    value.reset = (f, ...vs) => {
	        numFragments = f.length;
	        value.resetInner(vs,buildValue);
	    };

	    return value;
	};

	/** 
	based on framer-motion@4.0.3,
	Copyright (c) 2018 Framer B.V.
	*/


	/**
	 * Creates `AnimationControls`, which can be used to manually start, stop
	 * and sequence animations on one or more components.
	 *
	 * The returned `AnimationControls` should be passed to the `animate` property
	 * of the components you want to animate.
	 *
	 * These components can then be animated with the `start` method.
	 *
	 * @library
	 *
	 * ```jsx
	 * import * as React from 'react'
	 * import { Frame, useAnimation } from 'framer'
	 *
	 * export function MyComponent(props) {
	 *    const controls = useAnimation()
	 *
	 *    controls.start({
	 *        x: 100,
	 *        transition: { duration: 0.5 },
	 *    })
	 *
	 *    return <Frame animate={controls} />
	 * }
	 * ```
	 *
	 * @motion
	 *
	 * ```jsx
	 * import * as React from 'react'
	 * import { motion, useAnimation } from 'framer-motion'
	 *
	 * export function MyComponent(props) {
	 *    const controls = useAnimation()
	 *
	 *    controls.start({
	 *        x: 100,
	 *        transition: { duration: 0.5 },
	 *    })
	 *
	 *    return <MotionDiv animate={controls} />
	 * }
	 * ```
	 *
	 * @returns Animation controller with `start` and `stop` methods
	 *
	 * @public
	 */
	const useAnimation = () =>{

	    const controls =  animationControls(()=>{

	        const cleanup = {};
	        tick().then(v => cleanup.clean = controls.mount());
	        return ()=>{
	            cleanup.clean?.();
	        }
	    });

	    return controls;
	};

	/* src/lib/components/toolbar/ToolbarAnimation.svelte generated by Svelte v4.2.10 */

	const file$p = "src/lib/components/toolbar/ToolbarAnimation.svelte";

	// (18:0) <Motion   animate={controls}   drag   dragConstraints={{ left: 0, right: 0, top: 0, bottom: 0 }}   style={{ x, y, rotate, filter: shadow }}   whileHover={{ scale: 1.05 }}   whileTap={{ scale: 1 }}   let:motion >
	function create_default_slot$d(ctx) {
		let div;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[5].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr_dev(div, "class", "relative bottom-3");
				add_location(div, file$p, 34, 2, 783);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = action_destroyer(/*motion*/ ctx[7].call(null, div));
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[6],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$d.name,
			type: "slot",
			source: "(18:0) <Motion   animate={controls}   drag   dragConstraints={{ left: 0, right: 0, top: 0, bottom: 0 }}   style={{ x, y, rotate, filter: shadow }}   whileHover={{ scale: 1.05 }}   whileTap={{ scale: 1 }}   let:motion >",
			ctx
		});

		return block;
	}

	function create_fragment$y(ctx) {
		let motion_1;
		let current;

		motion_1 = new motion({
				props: {
					animate: /*controls*/ ctx[4],
					drag: true,
					dragConstraints: { left: 0, right: 0, top: 0, bottom: 0 },
					style: {
						x: /*x*/ ctx[0],
						y: /*y*/ ctx[1],
						rotate: /*rotate*/ ctx[2],
						filter: /*shadow*/ ctx[3]
					},
					whileHover: { scale: 1.05 },
					whileTap: { scale: 1 },
					$$slots: {
						default: [
							create_default_slot$d,
							({ motion }) => ({ 7: motion }),
							({ motion }) => motion ? 128 : 0
						]
					},
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(motion_1.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(motion_1, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const motion_1_changes = {};

				if (dirty & /*$$scope*/ 64) {
					motion_1_changes.$$scope = { dirty, ctx };
				}

				motion_1.$set(motion_1_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(motion_1.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(motion_1.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(motion_1, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$y.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$y($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ToolbarAnimation', slots, ['default']);
		const x = motionValue(0);
		const y = motionValue(100);
		const rotate = motionValue(0);
		const shadow = useMotionTemplate`drop-shadow(${x}px ${y}px 20px rgba(0,0,0,0.05))`;
		const controls = useAnimation();

		onMount(() => {
			controls.start({
				x: 0,
				y: 0,
				rotate: 0,
				transition: { duration: 1, type: "spring" }, // Customize the duration, type of the animation, etc.
				
			});
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ToolbarAnimation> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			onMount,
			Motion: motion,
			useAnimation,
			useMotionTemplate,
			useMotionValue: motionValue,
			x,
			y,
			rotate,
			shadow,
			controls
		});

		return [x, y, rotate, shadow, controls, slots, $$scope];
	}

	class ToolbarAnimation extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$y, create_fragment$y, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ToolbarAnimation",
				options,
				id: create_fragment$y.name
			});
		}
	}

	class HoverRect {
	    constructor() {
	        this.element = document.createElement('div');
	        this.svgNamespace = 'http://www.w3.org/2000/svg';
	        this.svgElement = document.createElementNS(this.svgNamespace, 'svg');
	        this.rectElement = document.createElementNS(this.svgNamespace, 'rect');
	        this.rectElement.setAttribute('fill', 'none');
	        this.rectElement.setAttribute('stroke', '#FF0E48');
	        this.rectElement.setAttribute('stroke-width', '2');
	        this.svgElement.appendChild(this.rectElement);
	        this.element.style.position = 'absolute';
	        this.element.style.pointerEvents = 'none'; // Ensure it doesn't interfere with other interactions
	        this.element.style.zIndex = '999';
	        this.element.appendChild(this.svgElement);
	    }
	    render({ width, height, top, left }) {
	        this.svgElement.setAttribute('width', width);
	        this.svgElement.setAttribute('height', height);
	        this.svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
	        this.rectElement.setAttribute('width', width);
	        this.rectElement.setAttribute('height', height);
	        this.element.style.top = `${top + window.scrollY}px`;
	        this.element.style.left = `${left + window.scrollX}px`;
	    }
	}
	class ClickRect {
	    constructor() {
	        this.element = document.createElement('div');
	        this.svgNamespace = 'http://www.w3.org/2000/svg';
	        this.svgElement = document.createElementNS(this.svgNamespace, 'svg');
	        this.rectElement = document.createElementNS(this.svgNamespace, 'rect');
	        this.rectElement.setAttribute('fill', 'none');
	        this.rectElement.setAttribute('stroke', '#FF0E48');
	        this.rectElement.setAttribute('stroke-width', '4');
	        this.rectElement.setAttribute('stroke-linecap', 'round');
	        this.rectElement.setAttribute('stroke-linejoin', 'round');
	        this.svgElement.appendChild(this.rectElement);
	        this.element.style.position = 'absolute';
	        this.element.style.pointerEvents = 'none';
	        this.element.style.zIndex = '999';
	        this.element.appendChild(this.svgElement);
	    }
	    render({ width, height, top, left }) {
	        this.svgElement.setAttribute('width', width);
	        this.svgElement.setAttribute('height', height);
	        this.svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
	        this.rectElement.setAttribute('width', width);
	        this.rectElement.setAttribute('height', height);
	        this.element.style.top = `${top + window.scrollY}px`;
	        this.element.style.left = `${left + window.scrollX}px`;
	    }
	}
	class ParentRect {
	    constructor() {
	        this.element = document.createElement('div');
	        this.svgNamespace = 'http://www.w3.org/2000/svg';
	        this.svgElement = document.createElementNS(this.svgNamespace, 'svg');
	        this.rectElement = document.createElementNS(this.svgNamespace, 'rect');
	        this.rectElement.setAttribute('fill', 'none');
	        this.rectElement.setAttribute('stroke', '#FF0E48');
	        this.rectElement.setAttribute('stroke-width', '2');
	        this.rectElement.setAttribute('stroke-dasharray', '5');
	        this.svgElement.appendChild(this.rectElement);
	        this.element.style.position = 'absolute';
	        this.element.style.pointerEvents = 'none';
	        this.element.style.zIndex = '999';
	        this.element.appendChild(this.svgElement);
	    }
	    render({ width, height, top, left }) {
	        this.svgElement.setAttribute('width', width);
	        this.svgElement.setAttribute('height', height);
	        this.svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
	        this.rectElement.setAttribute('width', width);
	        this.rectElement.setAttribute('height', height);
	        this.element.style.top = `${top + window.scrollY}px`;
	        this.element.style.left = `${left + window.scrollX}px`;
	    }
	}
	let hoverRect = new HoverRect();
	let clickRect = new ClickRect();
	let parentRect = new ParentRect();
	document.body.appendChild(hoverRect.element);
	document.body.appendChild(clickRect.element);
	document.body.appendChild(parentRect.element);
	function updateHoverRect(element) {
	    if (hoverRect) {
	        const rect = element.getBoundingClientRect();
	        hoverRect.render(rect);
	    }
	}
	function updateClickRect(element) {
	    if (clickRect) {
	        const rect = element.getBoundingClientRect();
	        clickRect.render(rect);
	    }
	    if (parentRect) {
	        const rect = element.parentElement.getBoundingClientRect();
	        parentRect.render(rect);
	    }
	    removeHoverRect();
	}
	function removeHoverRect() {
	    if (hoverRect) {
	        hoverRect.render({ width: 0, height: 0, top: 0, left: 0 });
	    }
	}
	function removeClickedRect() {
	    if (clickRect) {
	        clickRect.render({ width: 0, height: 0, top: 0, left: 0 });
	    }
	    if (parentRect) {
	        parentRect.render({ width: 0, height: 0, top: 0, left: 0 });
	    }
	}

	class EditTool {
	    constructor(editorPanel) {
	        this.editorPanel = editorPanel;
	    }
	    onInit() { }
	    onDestroy() {
	        this.editorPanel.setVisible(false);
	        removeClickedRect();
	        removeHoverRect();
	        this.clickedElement = null;
	        this.hoveredElement = null;
	    }
	    onMouseOver(el) {
	        this.hoveredElement = el;
	        updateHoverRect(el);
	    }
	    onMouseOut(e) {
	        this.hoveredElement = null;
	        removeHoverRect();
	    }
	    onClick(el) {
	        this.clickedElement = el;
	        this.editorPanel.setVisible(true);
	        this.editorPanel.setElement(el);
	        removeClickedRect();
	        updateClickRect(el);
	        // const onlookId = getDataOnlookId(el);
	        // ResizeObserver to watch size changes
	        if (this.resizeObserver)
	            this.resizeObserver.disconnect();
	        this.resizeObserver = new ResizeObserver(entries => {
	            for (let entry of entries) {
	                updateClickRect(entry.target);
	            }
	        });
	        this.resizeObserver.observe(el);
	    }
	}

	const deepElementFromPoint = (x, y) => {
	    const el = document.elementFromPoint(x, y);
	    const crawlShadows = node => {
	        if (node === null || node === void 0 ? void 0 : node.shadowRoot) {
	            const potential = node.shadowRoot.elementFromPoint(x, y);
	            if (potential == node)
	                return node;
	            else if (potential.shadowRoot)
	                return crawlShadows(potential);
	            else
	                return potential;
	        }
	        else
	            return node;
	    };
	    const nested_shadow = crawlShadows(el);
	    return nested_shadow || el;
	};
	const isOffBounds = node => (node === null || node === void 0 ? void 0 : node.closest) && (node.closest('onlook-toolbar') || node.closest('#onlook-toolbar'));

	var ToolName;
	(function (ToolName) {
	    ToolName["EDIT"] = "edit";
	})(ToolName || (ToolName = {}));
	class Editor {
	    constructor(toolName, editorPanel) {
	        this.eventsMap = {
	            'mouseover': (e) => this.handleMouseOver(e),
	            'mouseout': (e) => this.handleMouseOut(e),
	            'click': (e) => this.handleClick(e),
	            'resize': (e) => this.handleResize(e)
	        };
	        this.selectTool = (toolName) => {
	            if (this.selectedTool)
	                this.selectedTool.onDestroy();
	            if (!toolName) {
	                this.selectedTool = undefined;
	                return;
	            }
	            this.selectedTool = this.toolMap[toolName];
	            this.selectedTool.onInit();
	        };
	        this.handleMouseOver = (e) => {
	            if (!this.selectedTool)
	                return;
	            // Select and filter for non-onlook
	            const target = deepElementFromPoint(e.clientX, e.clientY);
	            if (isOffBounds(target))
	                return;
	            this.selectedTool.onMouseOver(target);
	            this.hoveredElement = target;
	        };
	        this.handleMouseOut = (e) => {
	            if (!this.selectedTool)
	                return;
	            const target = deepElementFromPoint(e.clientX, e.clientY);
	            if (isOffBounds(target))
	                return;
	            this.selectedTool.onMouseOut(target);
	            this.hoveredElement = null;
	        };
	        this.handleClick = (e) => {
	            if (!this.selectedTool)
	                return;
	            // Select and filter for non-onlook
	            const target = deepElementFromPoint(e.clientX, e.clientY);
	            if (isOffBounds(target))
	                return;
	            e.preventDefault();
	            e.stopPropagation();
	            this.selectedTool.onClick(target);
	            this.clickedElement = target;
	        };
	        this.handleResize = (e) => {
	            if (!this.selectedTool)
	                return;
	            if (this.clickedElement) {
	                this.selectedTool.onClick(this.clickedElement);
	            }
	            if (this.hoveredElement) {
	                this.selectedTool.onMouseOver(this.hoveredElement);
	            }
	        };
	        this.setListeners = () => {
	            Object.keys(this.eventsMap).forEach(event => {
	                window.addEventListener(event, this.eventsMap[event], true);
	            });
	        };
	        this.removeListeners = () => {
	            Object.keys(this.eventsMap).forEach(event => {
	                window.removeEventListener(event, this.eventsMap[event], true);
	            });
	        };
	        this.editorPanel = editorPanel;
	        this.toolMap = {
	            [ToolName.EDIT]: new EditTool(editorPanel),
	        };
	        // Set up tools
	        this.setListeners();
	        this.selectTool(toolName);
	    }
	}

	var t={dragStart:!0},e=(t,e,n)=>Math.min(Math.max(t,e),n),n$2=t=>"string"==typeof t,r=([t,e],n,r)=>{const o=(t,e)=>0===e?0:Math.ceil(t/e)*e;return [o(n,t),o(r,e)]};var o=(t,e)=>t.some((t=>e.some((e=>t.contains(e)))));function i$1(t,e){if(void 0===t)return;if(s(t))return t.getBoundingClientRect();if("object"==typeof t){const{top:e=0,left:n=0,right:r=0,bottom:o=0}=t;return {top:e,right:window.innerWidth-r,bottom:window.innerHeight-o,left:n}}if("parent"===t)return e.parentNode.getBoundingClientRect();const n=document.querySelector(t);if(null===n)throw new Error("The selector provided for bound doesn't exists in the document.");return n.getBoundingClientRect()}var a$2=(t,e,n)=>t.style.setProperty(e,n),s=t=>t instanceof HTMLElement,d$1=(d,l={})=>{let c,u,{bounds:f,axis:g="both",gpuAcceleration:h=!0,legacyTranslate:p=!0,transform:m,applyUserSelectHack:y=!0,disabled:b=!1,ignoreMultitouch:w=!1,recomputeBounds:v=t,grid:x,position:E,cancel:S,handle:A,defaultClass:C="neodrag",defaultClassDragging:N="neodrag-dragging",defaultClassDragged:D="neodrag-dragged",defaultPosition:M={x:0,y:0},onDragStart:B,onDrag:$,onDragEnd:R}=l,H=!1,L=0,P=0,T=0,X=0,Y=0,q=0,{x:k,y:U}=E?{x:E?.x??0,y:E?.y??0}:M;Q(k,U);let W,j,z,F,G,I="",J=!!E;v={...t,...v};const K=document.body.style,O=d.classList;function Q(t=L,e=P){if(!m){if(p){let n=`${+t}px, ${+e}px`;return a$2(d,"transform",h?`translate3d(${n}, 0)`:`translate(${n})`)}return a$2(d,"translate",`${+t}px ${+e}px ${h?"1px":""}`)}const r=m({offsetX:t,offsetY:e,rootNode:d});n$2(r)&&a$2(d,"transform",r);}const V=(t,e)=>{const n={offsetX:L,offsetY:P,rootNode:d,currentNode:G};d.dispatchEvent(new CustomEvent(t,{detail:n})),e?.(n);};const Z=addEventListener;Z("pointerdown",tt,!1),Z("pointerup",et,!1),Z("pointermove",nt,!1),a$2(d,"touch-action","none");const _=()=>{let t=d.offsetWidth/j.width;return isNaN(t)&&(t=1),t};function tt(t){if(b)return;if(2===t.button)return;if(w&&!t.isPrimary)return;if(v.dragStart&&(W=i$1(f,d)),n$2(A)&&n$2(S)&&A===S)throw new Error("`handle` selector can't be same as `cancel` selector");if(O.add(C),z=function(t,e){if(!t)return [e];if(s(t))return [t];if(Array.isArray(t))return t;const n=e.querySelectorAll(t);if(null===n)throw new Error("Selector passed for `handle` option should be child of the element on which the action is applied");return Array.from(n.values())}(A,d),F=function(t,e){if(!t)return [];if(s(t))return [t];if(Array.isArray(t))return t;const n=e.querySelectorAll(t);if(null===n)throw new Error("Selector passed for `cancel` option should be child of the element on which the action is applied");return Array.from(n.values())}(S,d),c=/(both|x)/.test(g),u=/(both|y)/.test(g),o(F,z))throw new Error("Element being dragged can't be a child of the element on which `cancel` is applied");const e=t.composedPath()[0];if(!z.some((t=>t.contains(e)||t.shadowRoot?.contains(e)))||o(F,[e]))return;G=1===z.length?d:z.find((t=>t.contains(e))),H=!0,j=d.getBoundingClientRect(),y&&(I=K.userSelect,K.userSelect="none"),V("neodrag:start",B);const{clientX:r,clientY:a}=t,l=_();c&&(T=r-k/l),u&&(X=a-U/l),W&&(Y=r-j.left,q=a-j.top);}function et(){H&&(v.dragEnd&&(W=i$1(f,d)),O.remove(N),O.add(D),y&&(K.userSelect=I),V("neodrag:end",R),c&&(T=L),u&&(X=P),H=!1);}function nt(t){if(!H)return;v.drag&&(W=i$1(f,d)),O.add(N),t.preventDefault(),j=d.getBoundingClientRect();let n=t.clientX,o=t.clientY;const a=_();if(W){const t={left:W.left+Y,top:W.top+q,right:W.right+Y-j.width,bottom:W.bottom+q-j.height};n=e(n,t.left,t.right),o=e(o,t.top,t.bottom);}if(Array.isArray(x)){let[t,e]=x;if(isNaN(+t)||t<0)throw new Error("1st argument of `grid` must be a valid positive number");if(isNaN(+e)||e<0)throw new Error("2nd argument of `grid` must be a valid positive number");let i=n-T,s=o-X;[i,s]=r([t/a,e/a],i,s),n=T+i,o=X+s;}c&&(L=Math.round((n-T)*a)),u&&(P=Math.round((o-X)*a)),k=L,U=P,V("neodrag",$),Q();}return {destroy:()=>{const t=removeEventListener;t("pointerdown",tt,!1),t("pointerup",et,!1),t("pointermove",nt,!1);},update:e=>{g=e.axis||"both",b=e.disabled??!1,w=e.ignoreMultitouch??!1,A=e.handle,f=e.bounds,v=e.recomputeBounds??t,S=e.cancel,y=e.applyUserSelectHack??!0,x=e.grid,h=e.gpuAcceleration??!0,p=e.legacyTranslate??!0,m=e.transform;const n=O.contains(D);O.remove(C,D),C=e.defaultClass??"neodrag",N=e.defaultClassDragging??"neodrag-dragging",D=e.defaultClassDragged??"neodrag-dragged",O.add(C),n&&O.add(D),J&&(k=L=e.position?.x??L,U=P=e.position?.y??P,Q());}}};

	function arraysAreEqual(arr1, arr2) {
	    if (arr1.length !== arr2.length) {
	        return false;
	    }
	    return arr1.every((value, index) => value === arr2[index]);
	}

	/**
	 * Returns the array element after to the given index.
	 * @param array the array.
	 * @param currentIndex the index of the current element.
	 * @param loop loop to the beginning of the array if the next index is out of bounds?
	 */
	function next(array, index, loop = true) {
	    if (index === array.length - 1) {
	        return loop ? array[0] : array[index];
	    }
	    return array[index + 1];
	}
	/**
	 * Returns the array element prior to the given index.
	 * @param array the array.
	 * @param currentIndex the index of the current element.
	 * @param loop loop to the end of the array if the previous index is out of bounds?
	 */
	function prev(array, currentIndex, loop = true) {
	    if (currentIndex <= 0) {
	        return loop ? array[array.length - 1] : array[0];
	    }
	    return array[currentIndex - 1];
	}
	/**
	 * Returns the last element in an array.
	 * @param array the array.
	 */
	function last$1(array) {
	    return array[array.length - 1];
	}

	/**
	 * A utility function that converts a style object to a string.
	 *
	 * @param style - The style object to convert
	 * @returns The style object as a string
	 */
	function styleToString(style) {
	    return Object.keys(style).reduce((str, key) => {
	        if (style[key] === undefined)
	            return str;
	        return str + `${key}:${style[key]};`;
	    }, '');
	}

	function disabledAttr(disabled) {
	    return disabled ? true : undefined;
	}
	({
	    type: 'hidden',
	    'aria-hidden': true,
	    hidden: true,
	    tabIndex: -1,
	    style: styleToString({
	        position: 'absolute',
	        opacity: 0,
	        'pointer-events': 'none',
	        margin: 0,
	        transform: 'translateX(-100%)',
	    }),
	});

	function lightable(value) {
	    function subscribe(run) {
	        run(value);
	        return () => {
	            // don't need to unsub from anything
	        };
	    }
	    return { subscribe };
	}

	function getElementByMeltId(id) {
	    if (!isBrowser)
	        return null;
	    const el = document.querySelector(`[data-melt-id="${id}"]`);
	    return isHTMLElement(el) ? el : null;
	}
	const hiddenAction = (obj) => {
	    return new Proxy(obj, {
	        get(target, prop, receiver) {
	            return Reflect.get(target, prop, receiver);
	        },
	        ownKeys(target) {
	            return Reflect.ownKeys(target).filter((key) => key !== 'action');
	        },
	    });
	};
	const isFunctionWithParams = (fn) => {
	    return typeof fn === 'function';
	};
	function builder(name, args) {
	    const { stores, action, returned } = args ?? {};
	    const derivedStore = (() => {
	        if (stores && returned) {
	            // If stores are provided, create a derived store from them
	            return derived(stores, (values) => {
	                const result = returned(values);
	                if (isFunctionWithParams(result)) {
	                    const fn = (...args) => {
	                        return hiddenAction({
	                            ...result(...args),
	                            [`data-melt-${name}`]: '',
	                            action: action ?? noop$1,
	                        });
	                    };
	                    fn.action = action ?? noop$1;
	                    return fn;
	                }
	                return hiddenAction({
	                    ...result,
	                    [`data-melt-${name}`]: '',
	                    action: action ?? noop$1,
	                });
	            });
	        }
	        else {
	            // If stores are not provided, return a lightable store, for consistency
	            const returnedFn = returned;
	            const result = returnedFn?.();
	            if (isFunctionWithParams(result)) {
	                const resultFn = (...args) => {
	                    return hiddenAction({
	                        ...result(...args),
	                        [`data-melt-${name}`]: '',
	                        action: action ?? noop$1,
	                    });
	                };
	                resultFn.action = action ?? noop$1;
	                return lightable(resultFn);
	            }
	            return lightable(hiddenAction({
	                ...result,
	                [`data-melt-${name}`]: '',
	                action: action ?? noop$1,
	            }));
	        }
	    })();
	    const actionFn = (action ??
	        (() => {
	            /** noop */
	        }));
	    actionFn.subscribe = derivedStore.subscribe;
	    return actionFn;
	}
	function createElHelpers(prefix) {
	    const name = (part) => (part ? `${prefix}-${part}` : prefix);
	    const attribute = (part) => `data-melt-${prefix}${part ? `-${part}` : ''}`;
	    const selector = (part) => `[data-melt-${prefix}${part ? `-${part}` : ''}]`;
	    const getEl = (part) => document.querySelector(selector(part));
	    return {
	        name,
	        attribute,
	        selector,
	        getEl,
	    };
	}

	const isBrowser = typeof document !== 'undefined';
	function isHTMLElement(element) {
	    return element instanceof HTMLElement;
	}

	/**
	 * Executes an array of callback functions with the same arguments.
	 * @template T The types of the arguments that the callback functions take.
	 * @param n array of callback functions to execute.
	 * @returns A new function that executes all of the original callback functions with the same arguments.
	 */
	function executeCallbacks(...callbacks) {
	    return (...args) => {
	        for (const callback of callbacks) {
	            if (typeof callback === 'function') {
	                callback(...args);
	            }
	        }
	    };
	}
	/**
	 * A no operation function (does nothing)
	 */
	function noop$1() {
	    //
	}

	/**
	 * Adds an event listener to the specified target element(s) for the given event(s), and returns a function to remove it.
	 * @param target The target element(s) to add the event listener to.
	 * @param event The event(s) to listen for.
	 * @param handler The function to be called when the event is triggered.
	 * @param options An optional object that specifies characteristics about the event listener.
	 * @returns A function that removes the event listener from the target element(s).
	 */
	function addEventListener$1(target, event, handler, options) {
	    const events = Array.isArray(event) ? event : [event];
	    // Add the event listener to each specified event for the target element(s).
	    events.forEach((_event) => target.addEventListener(_event, handler, options));
	    // Return a function that removes the event listener from the target element(s).
	    return () => {
	        events.forEach((_event) => target.removeEventListener(_event, handler, options));
	    };
	}
	function addMeltEventListener(target, event, handler, options) {
	    const events = Array.isArray(event) ? event : [event];
	    if (typeof handler === 'function') {
	        const handlerWithMelt = withMelt((_event) => handler(_event));
	        // Add the event listener to each specified event for the target element(s).
	        events.forEach((_event) => target.addEventListener(_event, handlerWithMelt, options));
	        // Return a function that removes the event listener from the target element(s).
	        return () => {
	            events.forEach((_event) => target.removeEventListener(_event, handlerWithMelt, options));
	        };
	    }
	    return () => noop$1();
	}
	function dispatchMeltEvent(originalEvent) {
	    const node = originalEvent.currentTarget;
	    if (!isHTMLElement(node))
	        return null;
	    const customMeltEvent = new CustomEvent(`m-${originalEvent.type}`, {
	        detail: {
	            originalEvent,
	        },
	        cancelable: true,
	    });
	    node.dispatchEvent(customMeltEvent);
	    return customMeltEvent;
	}
	function withMelt(handler) {
	    return (event) => {
	        const customEvent = dispatchMeltEvent(event);
	        if (customEvent?.defaultPrevented)
	            return;
	        return handler(event);
	    };
	}

	/**
	 * Detects the text direction in the element.
	 * @returns {TextDirection} The text direction ('ltr' for left-to-right or 'rtl' for right-to-left).
	 */
	function getElemDirection(elem) {
	    const style = window.getComputedStyle(elem);
	    const direction = style.getPropertyValue('direction');
	    return direction;
	}

	function omit(obj, ...keys) {
	    const result = {};
	    for (const key of Object.keys(obj)) {
	        if (!keys.includes(key)) {
	            result[key] = obj[key];
	        }
	    }
	    return result;
	}

	/**
	 * Transforms an existing store into a store with a `get` method.
	 * Uses subscriptions to keep the value up to date, so make sure to call `destroy` when you're done with it.
	 * @date 20/01/2024 - 16:38:39
	 *
	 * @export
	 * @template {Readable<unknown>} T
	 * @param {T} store
	 * @returns {WithGet<T>}
	 */
	function withGet(store) {
	    return {
	        ...store,
	        get: () => get_store_value(store),
	    };
	}
	withGet.writable = function (initial) {
	    const internal = writable(initial);
	    let value = initial;
	    return {
	        subscribe: internal.subscribe,
	        set(newValue) {
	            internal.set(newValue);
	            value = newValue;
	        },
	        update(updater) {
	            const newValue = updater(value);
	            internal.set(newValue);
	            value = newValue;
	        },
	        get() {
	            return value;
	        },
	    };
	};
	withGet.derived = function (stores, fn) {
	    const subscribers = new Map();
	    const get = () => {
	        const values = Array.isArray(stores) ? stores.map((store) => store.get()) : stores.get();
	        return fn(values);
	    };
	    const subscribe = (subscriber) => {
	        const unsubscribers = [];
	        const storesArr = Array.isArray(stores) ? stores : [stores];
	        storesArr.forEach((store) => {
	            unsubscribers.push(store.subscribe(() => {
	                subscriber(get());
	            }));
	        });
	        subscriber(get());
	        subscribers.set(subscriber, unsubscribers);
	        return () => {
	            const unsubscribers = subscribers.get(subscriber);
	            if (unsubscribers) {
	                for (const unsubscribe of unsubscribers) {
	                    unsubscribe();
	                }
	            }
	            subscribers.delete(subscriber);
	        };
	    };
	    return {
	        get,
	        subscribe,
	    };
	};

	const overridable = (_store, onChange) => {
	    const store = withGet(_store);
	    const update = (updater, sideEffect) => {
	        store.update((curr) => {
	            const next = updater(curr);
	            let res = next;
	            if (onChange) {
	                res = onChange({ curr, next });
	            }
	            sideEffect?.(res);
	            return res;
	        });
	    };
	    const set = (curr) => {
	        update(() => curr);
	    };
	    return {
	        ...store,
	        update,
	        set,
	    };
	};

	function sleep(ms) {
	    return new Promise((resolve) => setTimeout(resolve, ms));
	}

	let urlAlphabet =
	  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
	let nanoid = (size = 21) => {
	  let id = '';
	  let i = size;
	  while (i--) {
	    id += urlAlphabet[(Math.random() * 64) | 0];
	  }
	  return id
	};

	/**
	 * A function that generates a random id
	 * @returns An id
	 */
	function generateId() {
	    return nanoid(10);
	}
	function generateIds(args) {
	    return args.reduce((acc, curr) => {
	        acc[curr] = generateId();
	        return acc;
	    }, {});
	}

	/**
	 * A constant object that maps commonly used keyboard keys to their corresponding string values.
	 * This object can be used in other parts of the application to handle keyboard input and prevent
	 * hard-coded strings throughout.
	 */
	const kbd = {
	    ALT: 'Alt',
	    ARROW_DOWN: 'ArrowDown',
	    ARROW_LEFT: 'ArrowLeft',
	    ARROW_RIGHT: 'ArrowRight',
	    ARROW_UP: 'ArrowUp',
	    BACKSPACE: 'Backspace',
	    CAPS_LOCK: 'CapsLock',
	    CONTROL: 'Control',
	    DELETE: 'Delete',
	    END: 'End',
	    ENTER: 'Enter',
	    ESCAPE: 'Escape',
	    F1: 'F1',
	    F10: 'F10',
	    F11: 'F11',
	    F12: 'F12',
	    F2: 'F2',
	    F3: 'F3',
	    F4: 'F4',
	    F5: 'F5',
	    F6: 'F6',
	    F7: 'F7',
	    F8: 'F8',
	    F9: 'F9',
	    HOME: 'Home',
	    META: 'Meta',
	    PAGE_DOWN: 'PageDown',
	    PAGE_UP: 'PageUp',
	    SHIFT: 'Shift',
	    SPACE: ' ',
	    TAB: 'Tab',
	    CTRL: 'Control',
	    ASTERISK: '*',
	    A: 'a',
	    P: 'p',
	};
	const getNextKey = (dir = 'ltr', orientation = 'horizontal') => {
	    return {
	        horizontal: dir === 'rtl' ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,
	        vertical: kbd.ARROW_DOWN,
	    }[orientation];
	};
	const getPrevKey = (dir = 'ltr', orientation = 'horizontal') => {
	    return {
	        horizontal: dir === 'rtl' ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,
	        vertical: kbd.ARROW_UP,
	    }[orientation];
	};
	const getDirectionalKeys = (dir = 'ltr', orientation = 'horizontal') => {
	    return {
	        nextKey: getNextKey(dir, orientation),
	        prevKey: getPrevKey(dir, orientation),
	    };
	};

	/**
	 * Given an object of properties, returns an object of writable stores
	 * with the same properties and values.
	 */
	function toWritableStores(properties) {
	    const result = {};
	    Object.keys(properties).forEach((key) => {
	        const propertyKey = key;
	        const value = properties[propertyKey];
	        result[propertyKey] = withGet(writable(value));
	    });
	    return result;
	}

	/**
	 * Manage roving focus between elements. Sets the current active element to
	 * tabindex -1 and the next element to tabindex 0.
	 *
	 * @param nextElement The element to focus on
	 */
	function handleRovingFocus(nextElement) {
	    if (!isBrowser)
	        return;
	    sleep(1).then(() => {
	        const currentFocusedElement = document.activeElement;
	        if (!isHTMLElement(currentFocusedElement) || currentFocusedElement === nextElement)
	            return;
	        currentFocusedElement.tabIndex = -1;
	        if (nextElement) {
	            nextElement.tabIndex = 0;
	            nextElement.focus();
	        }
	    });
	}

	const { name: name$2, selector: selector$3 } = createElHelpers('accordion');
	const defaults$4 = {
	    multiple: false,
	    disabled: false,
	    forceVisible: false,
	};
	const createAccordion = (props) => {
	    const withDefaults = { ...defaults$4, ...props };
	    const options = toWritableStores(omit(withDefaults, 'value', 'onValueChange', 'defaultValue'));
	    const meltIds = generateIds(['root']);
	    const { disabled, forceVisible } = options;
	    const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
	    const value = overridable(valueWritable, withDefaults?.onValueChange);
	    const isSelected = (key, v) => {
	        if (v === undefined)
	            return false;
	        if (typeof v === 'string')
	            return v === key;
	        return v.includes(key);
	    };
	    const isSelectedStore = derived(value, ($value) => {
	        return (key) => isSelected(key, $value);
	    });
	    const root = builder(name$2(), {
	        returned: () => ({
	            'data-melt-id': meltIds.root,
	        }),
	    });
	    const parseItemProps = (props) => {
	        if (typeof props === 'string') {
	            return { value: props };
	        }
	        else {
	            return props;
	        }
	    };
	    const parseHeadingProps = (props) => {
	        if (typeof props === 'number') {
	            return { level: props };
	        }
	        else {
	            return props;
	        }
	    };
	    const item = builder(name$2('item'), {
	        stores: value,
	        returned: ($value) => {
	            return (props) => {
	                const { value: itemValue, disabled } = parseItemProps(props);
	                return {
	                    'data-state': isSelected(itemValue, $value) ? 'open' : 'closed',
	                    'data-disabled': disabledAttr(disabled),
	                };
	            };
	        },
	    });
	    const trigger = builder(name$2('trigger'), {
	        stores: [value, disabled],
	        returned: ([$value, $disabled]) => {
	            return (props) => {
	                const { value: itemValue, disabled } = parseItemProps(props);
	                // generate the content ID here so that we can grab it in the content
	                // builder action to ensure the values match.
	                return {
	                    disabled: disabledAttr($disabled || disabled),
	                    'aria-expanded': isSelected(itemValue, $value) ? true : false,
	                    'aria-disabled': disabled ? true : false,
	                    'data-disabled': disabledAttr(disabled),
	                    'data-value': itemValue,
	                    'data-state': isSelected(itemValue, $value) ? 'open' : 'closed',
	                };
	            };
	        },
	        action: (node) => {
	            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {
	                const disabled = node.dataset.disabled === 'true';
	                const itemValue = node.dataset.value;
	                if (disabled || !itemValue)
	                    return;
	                handleValueUpdate(itemValue);
	            }), addMeltEventListener(node, 'keydown', (e) => {
	                if (![kbd.ARROW_DOWN, kbd.ARROW_UP, kbd.HOME, kbd.END].includes(e.key)) {
	                    return;
	                }
	                e.preventDefault();
	                if (e.key === kbd.SPACE || e.key === kbd.ENTER) {
	                    const disabled = node.dataset.disabled === 'true';
	                    const itemValue = node.dataset.value;
	                    if (disabled || !itemValue)
	                        return;
	                    handleValueUpdate(itemValue);
	                    return;
	                }
	                const el = e.target;
	                const rootEl = getElementByMeltId(meltIds.root);
	                if (!rootEl || !isHTMLElement(el))
	                    return;
	                const items = Array.from(rootEl.querySelectorAll(selector$3('trigger')));
	                const candidateItems = items.filter((item) => {
	                    if (!isHTMLElement(item))
	                        return false;
	                    return item.dataset.disabled !== 'true';
	                });
	                if (!candidateItems.length)
	                    return;
	                const elIdx = candidateItems.indexOf(el);
	                if (e.key === kbd.ARROW_DOWN) {
	                    candidateItems[(elIdx + 1) % candidateItems.length].focus();
	                }
	                if (e.key === kbd.ARROW_UP) {
	                    candidateItems[(elIdx - 1 + candidateItems.length) % candidateItems.length].focus();
	                }
	                if (e.key === kbd.HOME) {
	                    candidateItems[0].focus();
	                }
	                if (e.key === kbd.END) {
	                    candidateItems[candidateItems.length - 1].focus();
	                }
	            }));
	            return {
	                destroy: unsub,
	            };
	        },
	    });
	    const content = builder(name$2('content'), {
	        stores: [value, disabled, forceVisible],
	        returned: ([$value, $disabled, $forceVisible]) => {
	            return (props) => {
	                const { value: itemValue } = parseItemProps(props);
	                const isVisible = isSelected(itemValue, $value) || $forceVisible;
	                return {
	                    'data-state': isVisible ? 'open' : 'closed',
	                    'data-disabled': disabledAttr($disabled),
	                    'data-value': itemValue,
	                    hidden: isVisible ? undefined : true,
	                    style: styleToString({
	                        display: isVisible ? undefined : 'none',
	                    }),
	                };
	            };
	        },
	        action: (node) => {
	            tick().then(() => {
	                const contentId = generateId();
	                const triggerId = generateId();
	                const parentTrigger = document.querySelector(`${selector$3('trigger')}, [data-value="${node.dataset.value}"]`);
	                if (!isHTMLElement(parentTrigger))
	                    return;
	                node.id = contentId;
	                parentTrigger.setAttribute('aria-controls', contentId);
	                parentTrigger.id = triggerId;
	            });
	        },
	    });
	    const heading = builder(name$2('heading'), {
	        returned: () => {
	            return (props) => {
	                const { level } = parseHeadingProps(props);
	                return {
	                    role: 'heading',
	                    'aria-level': level,
	                    'data-heading-level': level,
	                };
	            };
	        },
	    });
	    function handleValueUpdate(itemValue) {
	        value.update(($value) => {
	            if ($value === undefined) {
	                return withDefaults.multiple ? [itemValue] : itemValue;
	            }
	            if (Array.isArray($value)) {
	                if ($value.includes(itemValue)) {
	                    return $value.filter((v) => v !== itemValue);
	                }
	                $value.push(itemValue);
	                return $value;
	            }
	            return $value === itemValue ? undefined : itemValue;
	        });
	    }
	    return {
	        ids: meltIds,
	        elements: {
	            root,
	            item,
	            trigger,
	            content,
	            heading,
	        },
	        states: {
	            value: value,
	        },
	        helpers: {
	            isSelected: isSelectedStore,
	        },
	        options,
	    };
	};

	// Modified from Grail UI v0.9.6 (2023-06-10)
	// Source: https://github.com/grail-ui/grail-ui
	// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/clickOutside/clickOutside.ts
	/**
	 * Creates a readable store that tracks the latest PointerEvent that occurred on the document.
	 *
	 * @returns A function to unsubscribe from the event listener and stop tracking pointer events.
	 */
	readable(undefined, (set) => {
	    /**
	     * Event handler for pointerdown events on the document.
	     * Updates the store's value with the latest PointerEvent and then resets it to undefined.
	     */
	    function clicked(event) {
	        set(event);
	        // New subscriptions will not trigger immediately
	        set(undefined);
	    }
	    // Adds a pointerdown event listener to the document, calling the clicked function when triggered.
	    const unsubscribe = addEventListener$1(document, 'pointerup', clicked, {
	        passive: false,
	        capture: true,
	    });
	    // Returns a function to unsubscribe from the event listener and stop tracking pointer events.
	    return unsubscribe;
	});

	/**
	 * Creates a readable store that tracks the latest Escape Keydown that occurred on the document.
	 *
	 * @returns A function to unsubscribe from the event listener and stop tracking keydown events.
	 */
	readable(undefined, (set) => {
	    /**
	     * Event handler for keydown events on the document.
	     * Updates the store's value with the latest Escape Keydown event and then resets it to undefined.
	     */
	    function keydown(event) {
	        if (event && event.key === kbd.ESCAPE) {
	            set(event);
	        }
	        // New subscriptions will not trigger immediately
	        set(undefined);
	    }
	    // Adds a keydown event listener to the document, calling the keydown function when triggered.
	    const unsubscribe = addEventListener$1(document, 'keydown', keydown, {
	        passive: false,
	    });
	    // Returns a function to unsubscribe from the event listener and stop tracking keydown events.
	    return unsubscribe;
	});

	/**
	 * A special action for Melt UI's preprocessor `@melt-ui/pp`.
	 *
	 * @see https://www.melt-ui.com/docs/preprocessor
	 *
	 * @example
	 * ```svelte
	 * <script>
	 * 	import { createLabel, melt } from '@melt-ui/svelte';
	 * 	const { elements: { root } } = createLabel();
	 * </script>
	 *
	 * <label use:melt={$root} />
	 * ```
	 */
	function melt(node, params) {
	    throw new Error("[MELTUI ERROR]: The `use:melt` action cannot be used without MeltUI's Preprocessor. See: https://www.melt-ui.com/docs/preprocessor");
	}

	const defaults$3 = {
	    orientation: 'horizontal',
	    decorative: false,
	};
	const createSeparator = (props) => {
	    const withDefaults = { ...defaults$3, ...props };
	    const options = toWritableStores(withDefaults);
	    const { orientation, decorative } = options;
	    const root = builder('separator', {
	        stores: [orientation, decorative],
	        returned: ([$orientation, $decorative]) => {
	            const ariaOrientation = $orientation === 'vertical' ? $orientation : undefined;
	            return {
	                role: $decorative ? 'none' : 'separator',
	                'aria-orientation': ariaOrientation,
	                'aria-hidden': $decorative,
	                'data-orientation': $orientation,
	            };
	        },
	    });
	    return {
	        elements: {
	            root,
	        },
	        options,
	    };
	};

	const defaults$2 = {
	    orientation: 'horizontal',
	    activateOnFocus: true,
	    loop: true,
	    autoSet: true,
	};
	const { name: name$1, selector: selector$2 } = createElHelpers('tabs');
	function createTabs(props) {
	    const withDefaults = { ...defaults$2, ...props };
	    const options = toWritableStores(omit(withDefaults, 'defaultValue', 'value', 'onValueChange', 'autoSet'));
	    const { orientation, activateOnFocus, loop } = options;
	    const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
	    const value = overridable(valueWritable, withDefaults?.onValueChange);
	    let ssrValue = withDefaults.defaultValue ?? value.get();
	    // Root
	    const root = builder(name$1(), {
	        stores: orientation,
	        returned: ($orientation) => {
	            return {
	                'data-orientation': $orientation,
	            };
	        },
	    });
	    // List
	    const list = builder(name$1('list'), {
	        stores: orientation,
	        returned: ($orientation) => {
	            return {
	                role: 'tablist',
	                'aria-orientation': $orientation,
	                'data-orientation': $orientation,
	            };
	        },
	    });
	    const parseTriggerProps = (props) => {
	        if (typeof props === 'string') {
	            return { value: props };
	        }
	        else {
	            return props;
	        }
	    };
	    const trigger = builder(name$1('trigger'), {
	        stores: [value, orientation],
	        returned: ([$value, $orientation]) => {
	            return (props) => {
	                const { value: tabValue, disabled } = parseTriggerProps(props);
	                if (!$value && !ssrValue && withDefaults.autoSet) {
	                    ssrValue = tabValue;
	                    $value = tabValue;
	                    value.set(tabValue);
	                }
	                const sourceOfTruth = isBrowser ? $value : ssrValue;
	                const isActive = sourceOfTruth === tabValue;
	                return {
	                    type: 'button',
	                    role: 'tab',
	                    'data-state': isActive ? 'active' : 'inactive',
	                    tabindex: isActive ? 0 : -1,
	                    'data-value': tabValue,
	                    'data-orientation': $orientation,
	                    'data-disabled': disabledAttr(disabled),
	                    disabled: disabledAttr(disabled),
	                };
	            };
	        },
	        action: (node) => {
	            const unsub = executeCallbacks(addMeltEventListener(node, 'focus', () => {
	                const disabled = node.dataset.disabled === 'true';
	                const tabValue = node.dataset.value;
	                if (activateOnFocus.get() && !disabled && tabValue !== undefined) {
	                    value.set(tabValue);
	                }
	            }), addMeltEventListener(node, 'click', (e) => {
	                node.focus();
	                e.preventDefault();
	                const disabled = node.dataset.disabled === 'true';
	                if (disabled)
	                    return;
	                const tabValue = node.dataset.value;
	                node.focus();
	                if (tabValue !== undefined) {
	                    value.set(tabValue);
	                }
	            }), addMeltEventListener(node, 'keydown', (e) => {
	                const tabValue = node.dataset.value;
	                if (!tabValue)
	                    return;
	                const el = e.currentTarget;
	                if (!isHTMLElement(el))
	                    return;
	                const rootEl = el.closest(selector$2());
	                if (!isHTMLElement(rootEl))
	                    return;
	                const $loop = loop.get();
	                const triggers = Array.from(rootEl.querySelectorAll('[role="tab"]')).filter((trigger) => isHTMLElement(trigger));
	                const enabledTriggers = triggers.filter((el) => !el.hasAttribute('data-disabled'));
	                const triggerIdx = enabledTriggers.findIndex((el) => el === e.target);
	                const dir = getElemDirection(rootEl);
	                const { nextKey, prevKey } = getDirectionalKeys(dir, orientation.get());
	                if (e.key === nextKey) {
	                    e.preventDefault();
	                    const nextEl = next(enabledTriggers, triggerIdx, $loop);
	                    nextEl.focus();
	                }
	                else if (e.key === prevKey) {
	                    e.preventDefault();
	                    const prevEl = prev(enabledTriggers, triggerIdx, $loop);
	                    prevEl.focus();
	                }
	                else if (e.key === kbd.ENTER || e.key === kbd.SPACE) {
	                    e.preventDefault();
	                    value.set(tabValue);
	                }
	                else if (e.key === kbd.HOME) {
	                    e.preventDefault();
	                    const firstTrigger = enabledTriggers[0];
	                    firstTrigger.focus();
	                }
	                else if (e.key === kbd.END) {
	                    e.preventDefault();
	                    const lastTrigger = last$1(enabledTriggers);
	                    lastTrigger.focus();
	                }
	            }));
	            return {
	                destroy: unsub,
	            };
	        },
	    });
	    // Content
	    const content = builder(name$1('content'), {
	        stores: value,
	        returned: ($value) => {
	            return (tabValue) => {
	                return {
	                    role: 'tabpanel',
	                    // TODO: improve
	                    'aria-labelledby': tabValue,
	                    hidden: isBrowser
	                        ? $value === tabValue
	                            ? undefined
	                            : true
	                        : ssrValue === tabValue
	                            ? undefined
	                            : true,
	                    tabindex: 0,
	                };
	            };
	        },
	    });
	    return {
	        elements: {
	            root,
	            list,
	            trigger,
	            content,
	        },
	        states: {
	            value,
	        },
	        options,
	    };
	}

	const defaults$1 = {
	    type: 'single',
	    orientation: 'horizontal',
	    loop: true,
	    rovingFocus: true,
	    disabled: false,
	    defaultValue: '',
	};
	const { name, selector: selector$1 } = createElHelpers('toggle-group');
	const createToggleGroup = (props) => {
	    const withDefaults = { ...defaults$1, ...props };
	    const options = toWritableStores(omit(withDefaults, 'value'));
	    const { type, orientation, loop, rovingFocus, disabled } = options;
	    const defaultValue = withDefaults.defaultValue
	        ? withDefaults.defaultValue
	        : withDefaults.type === 'single'
	            ? 'undefined'
	            : [];
	    const valueWritable = withDefaults.value ?? writable(defaultValue);
	    const value = overridable(valueWritable, withDefaults?.onValueChange);
	    const root = builder(name(), {
	        stores: orientation,
	        returned: ($orientation) => {
	            return {
	                role: 'group',
	                'data-orientation': $orientation,
	            };
	        },
	    });
	    const item = builder(name('item'), {
	        stores: [value, disabled, orientation, type],
	        returned: ([$value, $disabled, $orientation, $type]) => {
	            return (props) => {
	                const itemValue = typeof props === 'string' ? props : props.value;
	                const argDisabled = typeof props === 'string' ? false : !!props.disabled;
	                const disabled = $disabled || argDisabled;
	                const pressed = Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;
	                const isSingle = $type === 'single';
	                const isMultiple = $type === 'multiple' || $type === undefined;
	                return {
	                    disabled: disabledAttr(disabled),
	                    pressed,
	                    'data-orientation': $orientation,
	                    'data-disabled': disabledAttr(disabled),
	                    'data-state': pressed ? 'on' : 'off',
	                    'data-value': itemValue,
	                    'aria-pressed': isMultiple ? pressed : undefined,
	                    'aria-checked': isSingle ? pressed : undefined,
	                    type: 'button',
	                    role: isSingle ? 'radio' : undefined,
	                    tabindex: pressed ? 0 : -1,
	                };
	            };
	        },
	        action: (node) => {
	            let unsub = noop$1;
	            const parentGroup = node.closest(selector$1());
	            if (!isHTMLElement(parentGroup))
	                return {};
	            const items = Array.from(parentGroup.querySelectorAll(selector$1('item')));
	            const $value = value.get();
	            const anyPressed = Array.isArray($value) ? $value.length > 0 : $value !== null;
	            if (!anyPressed && items[0] === node) {
	                node.tabIndex = 0;
	            }
	            function getNodeProps() {
	                const itemValue = node.dataset.value;
	                const disabled = node.dataset.disabled === 'true';
	                return { value: itemValue, disabled };
	            }
	            function handleValueUpdate() {
	                const { value: itemValue, disabled } = getNodeProps();
	                if (itemValue === undefined || disabled)
	                    return;
	                value.update(($value) => {
	                    if (Array.isArray($value)) {
	                        if ($value.includes(itemValue)) {
	                            return $value.filter((i) => i !== itemValue);
	                        }
	                        $value.push(itemValue);
	                        return $value;
	                    }
	                    return $value === itemValue ? undefined : itemValue;
	                });
	            }
	            unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {
	                handleValueUpdate();
	            }), addMeltEventListener(node, 'keydown', (e) => {
	                if (e.key === kbd.SPACE || e.key === kbd.ENTER) {
	                    e.preventDefault();
	                    handleValueUpdate();
	                    return;
	                }
	                if (!rovingFocus.get())
	                    return;
	                const el = e.currentTarget;
	                if (!isHTMLElement(el))
	                    return;
	                const root = el.closest(selector$1());
	                if (!isHTMLElement(root))
	                    return;
	                const items = Array.from(root.querySelectorAll(selector$1('item') + ':not([data-disabled])')).filter((item) => isHTMLElement(item));
	                const currentIndex = items.indexOf(el);
	                const dir = getElemDirection(el);
	                const $orientation = orientation.get();
	                const nextKey = {
	                    horizontal: dir === 'rtl' ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,
	                    vertical: kbd.ARROW_DOWN,
	                }[$orientation ?? 'horizontal'];
	                const prevKey = {
	                    horizontal: dir === 'rtl' ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,
	                    vertical: kbd.ARROW_UP,
	                }[$orientation ?? 'horizontal'];
	                const $loop = loop.get();
	                if (e.key === nextKey) {
	                    e.preventDefault();
	                    const nextIndex = currentIndex + 1;
	                    if (nextIndex >= items.length && $loop) {
	                        handleRovingFocus(items[0]);
	                    }
	                    else {
	                        handleRovingFocus(items[nextIndex]);
	                    }
	                }
	                else if (e.key === prevKey) {
	                    e.preventDefault();
	                    const prevIndex = currentIndex - 1;
	                    if (prevIndex < 0 && $loop) {
	                        handleRovingFocus(items[items.length - 1]);
	                    }
	                    else {
	                        handleRovingFocus(items[prevIndex]);
	                    }
	                }
	                else if (e.key === kbd.HOME) {
	                    e.preventDefault();
	                    handleRovingFocus(items[0]);
	                }
	                else if (e.key === kbd.END) {
	                    e.preventDefault();
	                    handleRovingFocus(items[items.length - 1]);
	                }
	            }));
	            return {
	                destroy: unsub,
	            };
	        },
	    });
	    const isPressed = derived(value, ($value) => {
	        return (itemValue) => {
	            return Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;
	        };
	    });
	    return {
	        elements: {
	            root,
	            item,
	        },
	        states: {
	            value,
	        },
	        helpers: {
	            isPressed,
	        },
	        options,
	    };
	};

	function createBitAttrs(bit, parts) {
	    const attrs = {};
	    parts.forEach((part) => {
	        attrs[part] = {
	            [`data-${bit}-${part}`]: "",
	        };
	    });
	    return (part) => attrs[part];
	}

	function createDispatcher() {
	    const dispatch = createEventDispatcher();
	    return (e) => {
	        const { originalEvent } = e.detail;
	        const { cancelable } = e;
	        const type = originalEvent.type;
	        const shouldContinue = dispatch(type, { originalEvent, currentTarget: originalEvent.currentTarget }, { cancelable });
	        if (!shouldContinue) {
	            e.preventDefault();
	        }
	    };
	}

	function removeUndefined(obj) {
	    const result = {};
	    for (const key in obj) {
	        const value = obj[key];
	        if (value !== undefined) {
	            result[key] = value;
	        }
	    }
	    return result;
	}

	function getOptionUpdater(options) {
	    return function (key, value) {
	        if (value === undefined)
	            return;
	        const store = options[key];
	        if (store) {
	            store.set(value);
	        }
	    };
	}

	function getAccordionData() {
	    const NAME = "accordion";
	    const ITEM_NAME = "accordion-item";
	    const PARTS = ["root", "content", "header", "item", "trigger"];
	    return { NAME, ITEM_NAME, PARTS };
	}
	function setCtx$3(props) {
	    const initAccordion = createAccordion(removeUndefined(props));
	    const { NAME, PARTS } = getAccordionData();
	    const getAttrs = createBitAttrs(NAME, PARTS);
	    const accordion = {
	        ...initAccordion,
	        getAttrs,
	        updateOption: getOptionUpdater(initAccordion.options),
	    };
	    setContext(NAME, accordion);
	    return accordion;
	}
	function getCtx$2() {
	    const { NAME } = getAccordionData();
	    return getContext(NAME);
	}
	function setItem(props) {
	    const { ITEM_NAME } = getAccordionData();
	    setContext(ITEM_NAME, { ...props });
	    const ctx = getCtx$2();
	    return { ...ctx, props };
	}
	function getItemProps() {
	    const { ITEM_NAME } = getAccordionData();
	    return getContext(ITEM_NAME);
	}
	function getContent() {
	    const ctx = getCtx$2();
	    const { value: props } = getItemProps();
	    return {
	        ...ctx,
	        props,
	    };
	}
	function getTrigger() {
	    const ctx = getCtx$2();
	    const { value, disabled } = getItemProps();
	    return {
	        ...ctx,
	        props: { value, disabled },
	    };
	}

	/* node_modules/bits-ui/dist/bits/accordion/components/accordion.svelte generated by Svelte v4.2.10 */
	const file$o = "node_modules/bits-ui/dist/bits/accordion/components/accordion.svelte";
	const get_default_slot_changes_1$a = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context_1$a = ctx => ({ builder: /*builder*/ ctx[2] });
	const get_default_slot_changes$c = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context$c = ctx => ({ builder: /*builder*/ ctx[2] });

	// (51:0) {:else}
	function create_else_block$f(ctx) {
		let div;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[11].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], get_default_slot_context_1$a);
		let div_levels = [/*builder*/ ctx[2], /*$$restProps*/ ctx[4]];
		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$o, 51, 1, 1187);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				/*div_binding*/ ctx[12](div);
				current = true;

				if (!mounted) {
					dispose = action_destroyer(/*builder*/ ctx[2].action(div));
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 1028)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[10],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, get_default_slot_changes_1$a),
							get_default_slot_context_1$a
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					dirty & /*builder*/ 4 && /*builder*/ ctx[2],
					dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
				/*div_binding*/ ctx[12](null);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$f.name,
			type: "else",
			source: "(51:0) {:else}",
			ctx
		});

		return block;
	}

	// (49:0) {#if asChild}
	function create_if_block$i(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[11].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], get_default_slot_context$c);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 1028)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[10],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, get_default_slot_changes$c),
							get_default_slot_context$c
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$i.name,
			type: "if",
			source: "(49:0) {#if asChild}",
			ctx
		});

		return block;
	}

	function create_fragment$x(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$i, create_else_block$f];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*asChild*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$x.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$x($$self, $$props, $$invalidate) {
		let builder;
		const omit_props_names = ["multiple","value","onValueChange","disabled","asChild","el"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let $root;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Accordion', slots, ['default']);
		let { multiple = false } = $$props;
		let { value = void 0 } = $$props;
		let { onValueChange = void 0 } = $$props;
		let { disabled = false } = $$props;
		let { asChild = false } = $$props;
		let { el = void 0 } = $$props;

		const { elements: { root }, states: { value: localValue }, updateOption, getAttrs } = setCtx$3({
			multiple,
			disabled,
			defaultValue: value,
			onValueChange: ({ next }) => {
				if (Array.isArray(next)) {
					if (!Array.isArray(value) || !arraysAreEqual(value, next)) {
						onValueChange?.(next);
						$$invalidate(5, value = next);
						return next;
					}

					return next;
				}

				if (value !== next) {
					onValueChange?.(next);
					$$invalidate(5, value = next);
				}

				return next;
			}
		});

		validate_store(root, 'root');
		component_subscribe($$self, root, value => $$invalidate(9, $root = value));
		const attrs = getAttrs("root");

		function div_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('multiple' in $$new_props) $$invalidate(6, multiple = $$new_props.multiple);
			if ('value' in $$new_props) $$invalidate(5, value = $$new_props.value);
			if ('onValueChange' in $$new_props) $$invalidate(7, onValueChange = $$new_props.onValueChange);
			if ('disabled' in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
			if ('asChild' in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$new_props) $$invalidate(0, el = $$new_props.el);
			if ('$$scope' in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			arraysAreEqual,
			melt,
			setCtx: setCtx$3,
			multiple,
			value,
			onValueChange,
			disabled,
			asChild,
			el,
			root,
			localValue,
			updateOption,
			getAttrs,
			attrs,
			builder,
			$root
		});

		$$self.$inject_state = $$new_props => {
			if ('multiple' in $$props) $$invalidate(6, multiple = $$new_props.multiple);
			if ('value' in $$props) $$invalidate(5, value = $$new_props.value);
			if ('onValueChange' in $$props) $$invalidate(7, onValueChange = $$new_props.onValueChange);
			if ('disabled' in $$props) $$invalidate(8, disabled = $$new_props.disabled);
			if ('asChild' in $$props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
			if ('builder' in $$props) $$invalidate(2, builder = $$new_props.builder);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*value*/ 32) {
				value !== void 0 && // eslint-disable-next-line @typescript-eslint/no-explicit-any
				localValue.set(Array.isArray(value) ? [...value] : value);
			}

			if ($$self.$$.dirty & /*multiple*/ 64) {
				updateOption("multiple", multiple);
			}

			if ($$self.$$.dirty & /*disabled*/ 256) {
				updateOption("disabled", disabled);
			}

			if ($$self.$$.dirty & /*$root*/ 512) {
				$$invalidate(2, builder = $root);
			}

			if ($$self.$$.dirty & /*builder*/ 4) {
				Object.assign(builder, attrs);
			}
		};

		return [
			el,
			asChild,
			builder,
			root,
			$$restProps,
			value,
			multiple,
			onValueChange,
			disabled,
			$root,
			$$scope,
			slots,
			div_binding
		];
	}

	let Accordion$1 = class Accordion extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$x, create_fragment$x, safe_not_equal, {
				multiple: 6,
				value: 5,
				onValueChange: 7,
				disabled: 8,
				asChild: 1,
				el: 0
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Accordion",
				options,
				id: create_fragment$x.name
			});
		}

		get multiple() {
			throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set multiple(value) {
			throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get value() {
			throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set value(value) {
			throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get onValueChange() {
			throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set onValueChange(value) {
			throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get disabled() {
			throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set disabled(value) {
			throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get asChild() {
			throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set asChild(value) {
			throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get el() {
			throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set el(value) {
			throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	};

	/* node_modules/bits-ui/dist/bits/accordion/components/accordion-item.svelte generated by Svelte v4.2.10 */
	const file$n = "node_modules/bits-ui/dist/bits/accordion/components/accordion-item.svelte";
	const get_default_slot_changes_1$9 = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context_1$9 = ctx => ({ builder: /*builder*/ ctx[2] });
	const get_default_slot_changes$b = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context$b = ctx => ({ builder: /*builder*/ ctx[2] });

	// (21:0) {:else}
	function create_else_block$e(ctx) {
		let div;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[9].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context_1$9);
		let div_levels = [/*builder*/ ctx[2], /*$$restProps*/ ctx[4]];
		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$n, 21, 1, 420);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				/*div_binding*/ ctx[10](div);
				current = true;

				if (!mounted) {
					dispose = action_destroyer(/*builder*/ ctx[2].action(div));
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 260)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[8],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, get_default_slot_changes_1$9),
							get_default_slot_context_1$9
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					dirty & /*builder*/ 4 && /*builder*/ ctx[2],
					dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
				/*div_binding*/ ctx[10](null);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$e.name,
			type: "else",
			source: "(21:0) {:else}",
			ctx
		});

		return block;
	}

	// (19:0) {#if asChild}
	function create_if_block$h(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[9].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context$b);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 260)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[8],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, get_default_slot_changes$b),
							get_default_slot_context$b
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$h.name,
			type: "if",
			source: "(19:0) {#if asChild}",
			ctx
		});

		return block;
	}

	function create_fragment$w(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$h, create_else_block$e];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*asChild*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$w.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$w($$self, $$props, $$invalidate) {
		let builder;
		const omit_props_names = ["value","disabled","asChild","el"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let $item;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Accordion_item', slots, ['default']);
		let { value } = $$props;
		let { disabled = void 0 } = $$props;
		let { asChild = false } = $$props;
		let { el = void 0 } = $$props;
		const { elements: { item }, props, getAttrs } = setItem({ value, disabled });
		validate_store(item, 'item');
		component_subscribe($$self, item, value => $$invalidate(7, $item = value));
		const attrs = getAttrs("item");

		$$self.$$.on_mount.push(function () {
			if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
				console.warn("<Accordion_item> was created without expected prop 'value'");
			}
		});

		function div_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('value' in $$new_props) $$invalidate(5, value = $$new_props.value);
			if ('disabled' in $$new_props) $$invalidate(6, disabled = $$new_props.disabled);
			if ('asChild' in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$new_props) $$invalidate(0, el = $$new_props.el);
			if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			melt,
			setItem,
			value,
			disabled,
			asChild,
			el,
			item,
			props,
			getAttrs,
			attrs,
			builder,
			$item
		});

		$$self.$inject_state = $$new_props => {
			if ('value' in $$props) $$invalidate(5, value = $$new_props.value);
			if ('disabled' in $$props) $$invalidate(6, disabled = $$new_props.disabled);
			if ('asChild' in $$props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
			if ('builder' in $$props) $$invalidate(2, builder = $$new_props.builder);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*$item*/ 128) {
				$$invalidate(2, builder = $item(props));
			}

			if ($$self.$$.dirty & /*builder*/ 4) {
				Object.assign(builder, attrs);
			}
		};

		return [
			el,
			asChild,
			builder,
			item,
			$$restProps,
			value,
			disabled,
			$item,
			$$scope,
			slots,
			div_binding
		];
	}

	let Accordion_item$1 = class Accordion_item extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$w, create_fragment$w, safe_not_equal, { value: 5, disabled: 6, asChild: 1, el: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Accordion_item",
				options,
				id: create_fragment$w.name
			});
		}

		get value() {
			throw new Error("<Accordion_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set value(value) {
			throw new Error("<Accordion_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get disabled() {
			throw new Error("<Accordion_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set disabled(value) {
			throw new Error("<Accordion_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get asChild() {
			throw new Error("<Accordion_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set asChild(value) {
			throw new Error("<Accordion_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get el() {
			throw new Error("<Accordion_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set el(value) {
			throw new Error("<Accordion_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	};

	/* node_modules/bits-ui/dist/bits/accordion/components/accordion-header.svelte generated by Svelte v4.2.10 */
	const file$m = "node_modules/bits-ui/dist/bits/accordion/components/accordion-header.svelte";
	const get_default_slot_changes_1$8 = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context_1$8 = ctx => ({ builder: /*builder*/ ctx[2] });
	const get_default_slot_changes$a = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context$a = ctx => ({ builder: /*builder*/ ctx[2] });

	// (19:0) {:else}
	function create_else_block$d(ctx) {
		let div;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[8].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context_1$8);
		let div_levels = [/*builder*/ ctx[2], /*$$restProps*/ ctx[4]];
		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$m, 19, 1, 379);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				/*div_binding*/ ctx[9](div);
				current = true;

				if (!mounted) {
					dispose = action_destroyer(/*builder*/ ctx[2].action(div));
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 132)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[7],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, get_default_slot_changes_1$8),
							get_default_slot_context_1$8
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					dirty & /*builder*/ 4 && /*builder*/ ctx[2],
					dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
				/*div_binding*/ ctx[9](null);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$d.name,
			type: "else",
			source: "(19:0) {:else}",
			ctx
		});

		return block;
	}

	// (17:0) {#if asChild}
	function create_if_block$g(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[8].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context$a);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 132)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[7],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, get_default_slot_changes$a),
							get_default_slot_context$a
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$g.name,
			type: "if",
			source: "(17:0) {#if asChild}",
			ctx
		});

		return block;
	}

	function create_fragment$v(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$g, create_else_block$d];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*asChild*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$v.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$v($$self, $$props, $$invalidate) {
		let builder;
		const omit_props_names = ["level","asChild","el"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let $header;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Accordion_header', slots, ['default']);
		let { level = 3 } = $$props;
		let { asChild = false } = $$props;
		let { el = void 0 } = $$props;
		const { elements: { heading: header }, getAttrs } = getCtx$2();
		validate_store(header, 'header');
		component_subscribe($$self, header, value => $$invalidate(6, $header = value));
		const attrs = getAttrs("header");

		function div_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('level' in $$new_props) $$invalidate(5, level = $$new_props.level);
			if ('asChild' in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$new_props) $$invalidate(0, el = $$new_props.el);
			if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			melt,
			getCtx: getCtx$2,
			level,
			asChild,
			el,
			header,
			getAttrs,
			attrs,
			builder,
			$header
		});

		$$self.$inject_state = $$new_props => {
			if ('level' in $$props) $$invalidate(5, level = $$new_props.level);
			if ('asChild' in $$props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
			if ('builder' in $$props) $$invalidate(2, builder = $$new_props.builder);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*$header, level*/ 96) {
				$$invalidate(2, builder = $header(level));
			}

			if ($$self.$$.dirty & /*builder*/ 4) {
				Object.assign(builder, attrs);
			}
		};

		return [
			el,
			asChild,
			builder,
			header,
			$$restProps,
			level,
			$header,
			$$scope,
			slots,
			div_binding
		];
	}

	class Accordion_header extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$v, create_fragment$v, safe_not_equal, { level: 5, asChild: 1, el: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Accordion_header",
				options,
				id: create_fragment$v.name
			});
		}

		get level() {
			throw new Error("<Accordion_header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set level(value) {
			throw new Error("<Accordion_header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get asChild() {
			throw new Error("<Accordion_header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set asChild(value) {
			throw new Error("<Accordion_header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get el() {
			throw new Error("<Accordion_header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set el(value) {
			throw new Error("<Accordion_header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* node_modules/bits-ui/dist/bits/accordion/components/accordion-trigger.svelte generated by Svelte v4.2.10 */
	const file$l = "node_modules/bits-ui/dist/bits/accordion/components/accordion-trigger.svelte";
	const get_default_slot_changes_1$7 = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context_1$7 = ctx => ({ builder: /*builder*/ ctx[2] });
	const get_default_slot_changes$9 = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context$9 = ctx => ({ builder: /*builder*/ ctx[2] });

	// (21:0) {:else}
	function create_else_block$c(ctx) {
		let button;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[8].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context_1$7);
		let button_levels = [/*builder*/ ctx[2], { type: "button" }, /*$$restProps*/ ctx[5]];
		let button_data = {};

		for (let i = 0; i < button_levels.length; i += 1) {
			button_data = assign(button_data, button_levels[i]);
		}

		const block = {
			c: function create() {
				button = element("button");
				if (default_slot) default_slot.c();
				set_attributes(button, button_data);
				add_location(button, file$l, 21, 1, 469);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);

				if (default_slot) {
					default_slot.m(button, null);
				}

				if (button.autofocus) button.focus();
				/*button_binding*/ ctx[9](button);
				current = true;

				if (!mounted) {
					dispose = [
						action_destroyer(/*builder*/ ctx[2].action(button)),
						listen_dev(button, "m-keydown", /*dispatch*/ ctx[4], false, false, false, false),
						listen_dev(button, "m-click", /*dispatch*/ ctx[4], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 132)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[7],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, get_default_slot_changes_1$7),
							get_default_slot_context_1$7
						);
					}
				}

				set_attributes(button, button_data = get_spread_update(button_levels, [
					dirty & /*builder*/ 4 && /*builder*/ ctx[2],
					{ type: "button" },
					dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				if (default_slot) default_slot.d(detaching);
				/*button_binding*/ ctx[9](null);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$c.name,
			type: "else",
			source: "(21:0) {:else}",
			ctx
		});

		return block;
	}

	// (19:0) {#if asChild}
	function create_if_block$f(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[8].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context$9);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 132)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[7],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, get_default_slot_changes$9),
							get_default_slot_context$9
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$f.name,
			type: "if",
			source: "(19:0) {#if asChild}",
			ctx
		});

		return block;
	}

	function create_fragment$u(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$f, create_else_block$c];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*asChild*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$u.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$u($$self, $$props, $$invalidate) {
		let builder;
		const omit_props_names = ["asChild","el"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let $trigger;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Accordion_trigger', slots, ['default']);
		let { asChild = false } = $$props;
		let { el = void 0 } = $$props;
		const { elements: { trigger }, props, getAttrs } = getTrigger();
		validate_store(trigger, 'trigger');
		component_subscribe($$self, trigger, value => $$invalidate(6, $trigger = value));
		const dispatch = createDispatcher();
		const attrs = getAttrs("trigger");

		function button_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('asChild' in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$new_props) $$invalidate(0, el = $$new_props.el);
			if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			melt,
			getTrigger,
			createDispatcher,
			asChild,
			el,
			trigger,
			props,
			getAttrs,
			dispatch,
			attrs,
			builder,
			$trigger
		});

		$$self.$inject_state = $$new_props => {
			if ('asChild' in $$props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
			if ('builder' in $$props) $$invalidate(2, builder = $$new_props.builder);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*$trigger*/ 64) {
				$$invalidate(2, builder = $trigger(props));
			}

			if ($$self.$$.dirty & /*builder*/ 4) {
				Object.assign(builder, attrs);
			}
		};

		return [
			el,
			asChild,
			builder,
			trigger,
			dispatch,
			$$restProps,
			$trigger,
			$$scope,
			slots,
			button_binding
		];
	}

	let Accordion_trigger$1 = class Accordion_trigger extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$u, create_fragment$u, safe_not_equal, { asChild: 1, el: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Accordion_trigger",
				options,
				id: create_fragment$u.name
			});
		}

		get asChild() {
			throw new Error("<Accordion_trigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set asChild(value) {
			throw new Error("<Accordion_trigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get el() {
			throw new Error("<Accordion_trigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set el(value) {
			throw new Error("<Accordion_trigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	};

	/* node_modules/bits-ui/dist/bits/accordion/components/accordion-content.svelte generated by Svelte v4.2.10 */
	const file$k = "node_modules/bits-ui/dist/bits/accordion/components/accordion-content.svelte";
	const get_default_slot_changes_5 = dirty => ({ builder: dirty & /*builder*/ 256 });
	const get_default_slot_context_5 = ctx => ({ builder: /*builder*/ ctx[8] });
	const get_default_slot_changes_4 = dirty => ({ builder: dirty & /*builder*/ 256 });
	const get_default_slot_context_4 = ctx => ({ builder: /*builder*/ ctx[8] });
	const get_default_slot_changes_3 = dirty => ({ builder: dirty & /*builder*/ 256 });
	const get_default_slot_context_3 = ctx => ({ builder: /*builder*/ ctx[8] });
	const get_default_slot_changes_2 = dirty => ({ builder: dirty & /*builder*/ 256 });
	const get_default_slot_context_2 = ctx => ({ builder: /*builder*/ ctx[8] });
	const get_default_slot_changes_1$6 = dirty => ({ builder: dirty & /*builder*/ 256 });
	const get_default_slot_context_1$6 = ctx => ({ builder: /*builder*/ ctx[8] });
	const get_default_slot_changes$8 = dirty => ({ builder: dirty & /*builder*/ 256 });
	const get_default_slot_context$8 = ctx => ({ builder: /*builder*/ ctx[8] });

	// (48:29) 
	function create_if_block_5$1(ctx) {
		let div;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[16].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], get_default_slot_context_5);
		let div_levels = [/*builder*/ ctx[8], /*$$restProps*/ ctx[13]];
		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$k, 48, 1, 1466);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				/*div_binding_4*/ ctx[21](div);
				current = true;

				if (!mounted) {
					dispose = action_destroyer(/*builder*/ ctx[8].action(div));
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 33024)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[15],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, get_default_slot_changes_5),
							get_default_slot_context_5
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					dirty & /*builder*/ 256 && /*builder*/ ctx[8],
					dirty & /*$$restProps*/ 8192 && /*$$restProps*/ ctx[13]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
				/*div_binding_4*/ ctx[21](null);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_5$1.name,
			type: "if",
			source: "(48:29) ",
			ctx
		});

		return block;
	}

	// (44:46) 
	function create_if_block_4$1(ctx) {
		let div;
		let div_outro;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[16].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], get_default_slot_context_4);
		let div_levels = [/*builder*/ ctx[8], /*$$restProps*/ ctx[13]];
		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$k, 44, 1, 1296);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				/*div_binding_3*/ ctx[20](div);
				current = true;

				if (!mounted) {
					dispose = action_destroyer(/*builder*/ ctx[8].action(div));
					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 33024)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[15],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, get_default_slot_changes_4),
							get_default_slot_context_4
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					dirty & /*builder*/ 256 && /*builder*/ ctx[8],
					dirty & /*$$restProps*/ 8192 && /*$$restProps*/ ctx[13]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				if (div_outro) div_outro.end(1);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);

				if (local) {
					div_outro = create_out_transition(div, /*outTransition*/ ctx[5], /*outTransitionConfig*/ ctx[6]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
				/*div_binding_3*/ ctx[20](null);
				if (detaching && div_outro) div_outro.end();
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_4$1.name,
			type: "if",
			source: "(44:46) ",
			ctx
		});

		return block;
	}

	// (40:45) 
	function create_if_block_3$1(ctx) {
		let div;
		let div_intro;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[16].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], get_default_slot_context_3);
		let div_levels = [/*builder*/ ctx[8], /*$$restProps*/ ctx[13]];
		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$k, 40, 1, 1112);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				/*div_binding_2*/ ctx[19](div);
				current = true;

				if (!mounted) {
					dispose = action_destroyer(/*builder*/ ctx[8].action(div));
					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 33024)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[15],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, get_default_slot_changes_3),
							get_default_slot_context_3
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					dirty & /*builder*/ 256 && /*builder*/ ctx[8],
					dirty & /*$$restProps*/ 8192 && /*$$restProps*/ ctx[13]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);

				if (local) {
					if (!div_intro) {
						add_render_callback(() => {
							div_intro = create_in_transition(div, /*inTransition*/ ctx[3], /*inTransitionConfig*/ ctx[4]);
							div_intro.start();
						});
					}
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
				/*div_binding_2*/ ctx[19](null);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$1.name,
			type: "if",
			source: "(40:45) ",
			ctx
		});

		return block;
	}

	// (30:62) 
	function create_if_block_2$2(ctx) {
		let div;
		let div_intro;
		let div_outro;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[16].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], get_default_slot_context_2);
		let div_levels = [/*builder*/ ctx[8], /*$$restProps*/ ctx[13]];
		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$k, 30, 1, 877);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				/*div_binding_1*/ ctx[18](div);
				current = true;

				if (!mounted) {
					dispose = action_destroyer(/*builder*/ ctx[8].action(div));
					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 33024)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[15],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, get_default_slot_changes_2),
							get_default_slot_context_2
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					dirty & /*builder*/ 256 && /*builder*/ ctx[8],
					dirty & /*$$restProps*/ 8192 && /*$$restProps*/ ctx[13]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (div_outro) div_outro.end(1);
						div_intro = create_in_transition(div, /*inTransition*/ ctx[3], /*inTransitionConfig*/ ctx[4]);
						div_intro.start();
					});
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				if (div_intro) div_intro.invalidate();

				if (local) {
					div_outro = create_out_transition(div, /*outTransition*/ ctx[5], /*outTransitionConfig*/ ctx[6]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
				/*div_binding_1*/ ctx[18](null);
				if (detaching && div_outro) div_outro.end();
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$2.name,
			type: "if",
			source: "(30:62) ",
			ctx
		});

		return block;
	}

	// (26:43) 
	function create_if_block_1$5(ctx) {
		let div;
		let div_transition;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[16].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], get_default_slot_context_1$6);
		let div_levels = [/*builder*/ ctx[8], /*$$restProps*/ ctx[13]];
		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$k, 26, 1, 673);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				/*div_binding*/ ctx[17](div);
				current = true;

				if (!mounted) {
					dispose = action_destroyer(/*builder*/ ctx[8].action(div));
					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 33024)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[15],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, get_default_slot_changes_1$6),
							get_default_slot_context_1$6
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					dirty & /*builder*/ 256 && /*builder*/ ctx[8],
					dirty & /*$$restProps*/ 8192 && /*$$restProps*/ ctx[13]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (!div_transition) div_transition = create_bidirectional_transition(div, /*transition*/ ctx[1], /*transitionConfig*/ ctx[2], true);
						div_transition.run(1);
					});
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);

				if (local) {
					if (!div_transition) div_transition = create_bidirectional_transition(div, /*transition*/ ctx[1], /*transitionConfig*/ ctx[2], false);
					div_transition.run(0);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
				/*div_binding*/ ctx[17](null);
				if (detaching && div_transition) div_transition.end();
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$5.name,
			type: "if",
			source: "(26:43) ",
			ctx
		});

		return block;
	}

	// (24:0) {#if asChild && $isSelected(props)}
	function create_if_block$e(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[16].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], get_default_slot_context$8);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 33024)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[15],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, get_default_slot_changes$8),
							get_default_slot_context$8
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$e.name,
			type: "if",
			source: "(24:0) {#if asChild && $isSelected(props)}",
			ctx
		});

		return block;
	}

	function create_fragment$t(ctx) {
		let show_if;
		let show_if_1;
		let show_if_2;
		let show_if_3;
		let show_if_4;
		let show_if_5;
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;

		const if_block_creators = [
			create_if_block$e,
			create_if_block_1$5,
			create_if_block_2$2,
			create_if_block_3$1,
			create_if_block_4$1,
			create_if_block_5$1
		];

		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (dirty & /*asChild, $isSelected*/ 640) show_if = null;
			if (dirty & /*transition, $isSelected*/ 514) show_if_1 = null;
			if (dirty & /*inTransition, outTransition, $isSelected*/ 552) show_if_2 = null;
			if (dirty & /*inTransition, $isSelected*/ 520) show_if_3 = null;
			if (dirty & /*outTransition, $isSelected*/ 544) show_if_4 = null;
			if (dirty & /*$isSelected*/ 512) show_if_5 = null;
			if (show_if == null) show_if = !!(/*asChild*/ ctx[7] && /*$isSelected*/ ctx[9](/*props*/ ctx[12]));
			if (show_if) return 0;
			if (show_if_1 == null) show_if_1 = !!(/*transition*/ ctx[1] && /*$isSelected*/ ctx[9](/*props*/ ctx[12]));
			if (show_if_1) return 1;
			if (show_if_2 == null) show_if_2 = !!(/*inTransition*/ ctx[3] && /*outTransition*/ ctx[5] && /*$isSelected*/ ctx[9](/*props*/ ctx[12]));
			if (show_if_2) return 2;
			if (show_if_3 == null) show_if_3 = !!(/*inTransition*/ ctx[3] && /*$isSelected*/ ctx[9](/*props*/ ctx[12]));
			if (show_if_3) return 3;
			if (show_if_4 == null) show_if_4 = !!(/*outTransition*/ ctx[5] && /*$isSelected*/ ctx[9](/*props*/ ctx[12]));
			if (show_if_4) return 4;
			if (show_if_5 == null) show_if_5 = !!/*$isSelected*/ ctx[9](/*props*/ ctx[12]);
			if (show_if_5) return 5;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx, -1))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(target, anchor);
				}

				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx, dirty);

				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) {
						if_blocks[current_block_type_index].p(ctx, dirty);
					}
				} else {
					if (if_block) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];

						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block.c();
						} else {
							if_block.p(ctx, dirty);
						}

						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					} else {
						if_block = null;
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d(detaching);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$t.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$t($$self, $$props, $$invalidate) {
		let builder;

		const omit_props_names = [
			"transition","transitionConfig","inTransition","inTransitionConfig","outTransition","outTransitionConfig","asChild","el"
		];

		let $$restProps = compute_rest_props($$props, omit_props_names);
		let $content;
		let $isSelected;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Accordion_content', slots, ['default']);
		let { transition = void 0 } = $$props;
		let { transitionConfig = void 0 } = $$props;
		let { inTransition = void 0 } = $$props;
		let { inTransitionConfig = void 0 } = $$props;
		let { outTransition = void 0 } = $$props;
		let { outTransitionConfig = void 0 } = $$props;
		let { asChild = false } = $$props;
		let { el = void 0 } = $$props;
		const { elements: { content }, helpers: { isSelected }, props, getAttrs } = getContent();
		validate_store(content, 'content');
		component_subscribe($$self, content, value => $$invalidate(14, $content = value));
		validate_store(isSelected, 'isSelected');
		component_subscribe($$self, isSelected, value => $$invalidate(9, $isSelected = value));
		const attrs = getAttrs("content");

		function div_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		function div_binding_1($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		function div_binding_2($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		function div_binding_3($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		function div_binding_4($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('transition' in $$new_props) $$invalidate(1, transition = $$new_props.transition);
			if ('transitionConfig' in $$new_props) $$invalidate(2, transitionConfig = $$new_props.transitionConfig);
			if ('inTransition' in $$new_props) $$invalidate(3, inTransition = $$new_props.inTransition);
			if ('inTransitionConfig' in $$new_props) $$invalidate(4, inTransitionConfig = $$new_props.inTransitionConfig);
			if ('outTransition' in $$new_props) $$invalidate(5, outTransition = $$new_props.outTransition);
			if ('outTransitionConfig' in $$new_props) $$invalidate(6, outTransitionConfig = $$new_props.outTransitionConfig);
			if ('asChild' in $$new_props) $$invalidate(7, asChild = $$new_props.asChild);
			if ('el' in $$new_props) $$invalidate(0, el = $$new_props.el);
			if ('$$scope' in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			melt,
			getContent,
			transition,
			transitionConfig,
			inTransition,
			inTransitionConfig,
			outTransition,
			outTransitionConfig,
			asChild,
			el,
			content,
			isSelected,
			props,
			getAttrs,
			attrs,
			builder,
			$content,
			$isSelected
		});

		$$self.$inject_state = $$new_props => {
			if ('transition' in $$props) $$invalidate(1, transition = $$new_props.transition);
			if ('transitionConfig' in $$props) $$invalidate(2, transitionConfig = $$new_props.transitionConfig);
			if ('inTransition' in $$props) $$invalidate(3, inTransition = $$new_props.inTransition);
			if ('inTransitionConfig' in $$props) $$invalidate(4, inTransitionConfig = $$new_props.inTransitionConfig);
			if ('outTransition' in $$props) $$invalidate(5, outTransition = $$new_props.outTransition);
			if ('outTransitionConfig' in $$props) $$invalidate(6, outTransitionConfig = $$new_props.outTransitionConfig);
			if ('asChild' in $$props) $$invalidate(7, asChild = $$new_props.asChild);
			if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
			if ('builder' in $$props) $$invalidate(8, builder = $$new_props.builder);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*$content*/ 16384) {
				$$invalidate(8, builder = $content(props));
			}

			if ($$self.$$.dirty & /*builder*/ 256) {
				Object.assign(builder, attrs);
			}
		};

		return [
			el,
			transition,
			transitionConfig,
			inTransition,
			inTransitionConfig,
			outTransition,
			outTransitionConfig,
			asChild,
			builder,
			$isSelected,
			content,
			isSelected,
			props,
			$$restProps,
			$content,
			$$scope,
			slots,
			div_binding,
			div_binding_1,
			div_binding_2,
			div_binding_3,
			div_binding_4
		];
	}

	let Accordion_content$1 = class Accordion_content extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$t, create_fragment$t, safe_not_equal, {
				transition: 1,
				transitionConfig: 2,
				inTransition: 3,
				inTransitionConfig: 4,
				outTransition: 5,
				outTransitionConfig: 6,
				asChild: 7,
				el: 0
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Accordion_content",
				options,
				id: create_fragment$t.name
			});
		}

		get transition() {
			throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set transition(value) {
			throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get transitionConfig() {
			throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set transitionConfig(value) {
			throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get inTransition() {
			throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set inTransition(value) {
			throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get inTransitionConfig() {
			throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set inTransitionConfig(value) {
			throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get outTransition() {
			throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set outTransition(value) {
			throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get outTransitionConfig() {
			throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set outTransitionConfig(value) {
			throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get asChild() {
			throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set asChild(value) {
			throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get el() {
			throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set el(value) {
			throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	};

	var AccordionPrimitive = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Content: Accordion_content$1,
		Header: Accordion_header,
		Item: Accordion_item$1,
		Root: Accordion$1,
		Trigger: Accordion_trigger$1
	});

	function builderActions(node, params) {
	    const unsubs = [];
	    params.builders.forEach((builder) => {
	        const act = builder.action(node);
	        if (act) {
	            unsubs.push(act);
	        }
	    });
	    return {
	        destroy: () => {
	            unsubs.forEach((unsub) => {
	                if (unsub.destroy) {
	                    unsub.destroy();
	                }
	            });
	        },
	    };
	}
	function getAttrs(builders) {
	    const attrs = {};
	    builders.forEach((builder) => {
	        Object.keys(builder).forEach((key) => {
	            if (key !== "action") {
	                attrs[key] = builder[key];
	            }
	        });
	    });
	    return attrs;
	}

	/* node_modules/bits-ui/dist/bits/button/components/button.svelte generated by Svelte v4.2.10 */
	const file$j = "node_modules/bits-ui/dist/bits/button/components/button.svelte";

	// (32:0) {:else}
	function create_else_block$b(ctx) {
		let previous_tag = /*href*/ ctx[1] ? "a" : "button";
		let svelte_element_anchor;
		let current;
		validate_dynamic_element(/*href*/ ctx[1] ? "a" : "button");
		validate_void_dynamic_element(/*href*/ ctx[1] ? "a" : "button");
		let svelte_element = (/*href*/ ctx[1] ? "a" : "button") && create_dynamic_element_1(ctx);

		const block = {
			c: function create() {
				if (svelte_element) svelte_element.c();
				svelte_element_anchor = empty();
			},
			m: function mount(target, anchor) {
				if (svelte_element) svelte_element.m(target, anchor);
				insert_dev(target, svelte_element_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (/*href*/ ctx[1] ? "a" : "button") {
					if (!previous_tag) {
						svelte_element = create_dynamic_element_1(ctx);
						previous_tag = /*href*/ ctx[1] ? "a" : "button";
						svelte_element.c();
						svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
					} else if (safe_not_equal(previous_tag, /*href*/ ctx[1] ? "a" : "button")) {
						svelte_element.d(1);
						validate_dynamic_element(/*href*/ ctx[1] ? "a" : "button");
						validate_void_dynamic_element(/*href*/ ctx[1] ? "a" : "button");
						svelte_element = create_dynamic_element_1(ctx);
						previous_tag = /*href*/ ctx[1] ? "a" : "button";
						svelte_element.c();
						svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
					} else {
						svelte_element.p(ctx, dirty);
					}
				} else if (previous_tag) {
					svelte_element.d(1);
					svelte_element = null;
					previous_tag = /*href*/ ctx[1] ? "a" : "button";
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(svelte_element, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(svelte_element, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svelte_element_anchor);
				}

				if (svelte_element) svelte_element.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$b.name,
			type: "else",
			source: "(32:0) {:else}",
			ctx
		});

		return block;
	}

	// (11:0) {#if builders && builders.length}
	function create_if_block$d(ctx) {
		let previous_tag = /*href*/ ctx[1] ? "a" : "button";
		let svelte_element_anchor;
		let current;
		validate_dynamic_element(/*href*/ ctx[1] ? "a" : "button");
		validate_void_dynamic_element(/*href*/ ctx[1] ? "a" : "button");
		let svelte_element = (/*href*/ ctx[1] ? "a" : "button") && create_dynamic_element(ctx);

		const block = {
			c: function create() {
				if (svelte_element) svelte_element.c();
				svelte_element_anchor = empty();
			},
			m: function mount(target, anchor) {
				if (svelte_element) svelte_element.m(target, anchor);
				insert_dev(target, svelte_element_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (/*href*/ ctx[1] ? "a" : "button") {
					if (!previous_tag) {
						svelte_element = create_dynamic_element(ctx);
						previous_tag = /*href*/ ctx[1] ? "a" : "button";
						svelte_element.c();
						svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
					} else if (safe_not_equal(previous_tag, /*href*/ ctx[1] ? "a" : "button")) {
						svelte_element.d(1);
						validate_dynamic_element(/*href*/ ctx[1] ? "a" : "button");
						validate_void_dynamic_element(/*href*/ ctx[1] ? "a" : "button");
						svelte_element = create_dynamic_element(ctx);
						previous_tag = /*href*/ ctx[1] ? "a" : "button";
						svelte_element.c();
						svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
					} else {
						svelte_element.p(ctx, dirty);
					}
				} else if (previous_tag) {
					svelte_element.d(1);
					svelte_element = null;
					previous_tag = /*href*/ ctx[1] ? "a" : "button";
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(svelte_element, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(svelte_element, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svelte_element_anchor);
				}

				if (svelte_element) svelte_element.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$d.name,
			type: "if",
			source: "(11:0) {#if builders && builders.length}",
			ctx
		});

		return block;
	}

	// (34:1) <svelte:element   this={href ? "a" : "button"}   type={href ? undefined : type}   {href}   on:click   on:change   on:keydown   on:keyup   on:mouseenter   on:mouseleave   tabindex="0"   {...$$restProps}   {...attrs}  >
	function create_dynamic_element_1(ctx) {
		let svelte_element;
		let svelte_element_type_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[7].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

		let svelte_element_levels = [
			{
				type: svelte_element_type_value = /*href*/ ctx[1] ? undefined : /*type*/ ctx[2]
			},
			{ href: /*href*/ ctx[1] },
			{ tabindex: "0" },
			/*$$restProps*/ ctx[5],
			/*attrs*/ ctx[4]
		];

		let svelte_element_data = {};

		for (let i = 0; i < svelte_element_levels.length; i += 1) {
			svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
		}

		const block = {
			c: function create() {
				svelte_element = element(/*href*/ ctx[1] ? "a" : "button");
				if (default_slot) default_slot.c();
				set_dynamic_element_data(/*href*/ ctx[1] ? "a" : "button")(svelte_element, svelte_element_data);
				add_location(svelte_element, file$j, 33, 1, 726);
			},
			m: function mount(target, anchor) {
				insert_dev(target, svelte_element, anchor);

				if (default_slot) {
					default_slot.m(svelte_element, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(svelte_element, "click", /*click_handler_1*/ ctx[14], false, false, false, false),
						listen_dev(svelte_element, "change", /*change_handler_1*/ ctx[15], false, false, false, false),
						listen_dev(svelte_element, "keydown", /*keydown_handler_1*/ ctx[16], false, false, false, false),
						listen_dev(svelte_element, "keyup", /*keyup_handler_1*/ ctx[17], false, false, false, false),
						listen_dev(svelte_element, "mouseenter", /*mouseenter_handler_1*/ ctx[18], false, false, false, false),
						listen_dev(svelte_element, "mouseleave", /*mouseleave_handler_1*/ ctx[19], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[6],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
							null
						);
					}
				}

				set_dynamic_element_data(/*href*/ ctx[1] ? "a" : "button")(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
					(!current || dirty & /*href, type*/ 6 && svelte_element_type_value !== (svelte_element_type_value = /*href*/ ctx[1] ? undefined : /*type*/ ctx[2])) && { type: svelte_element_type_value },
					(!current || dirty & /*href*/ 2) && { href: /*href*/ ctx[1] },
					{ tabindex: "0" },
					dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5],
					/*attrs*/ ctx[4]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svelte_element);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_dynamic_element_1.name,
			type: "child_dynamic_element",
			source: "(34:1) <svelte:element   this={href ? \\\"a\\\" : \\\"button\\\"}   type={href ? undefined : type}   {href}   on:click   on:change   on:keydown   on:keyup   on:mouseenter   on:mouseleave   tabindex=\\\"0\\\"   {...$$restProps}   {...attrs}  >",
			ctx
		});

		return block;
	}

	// (13:1) <svelte:element   this={href ? "a" : "button"}   bind:this={el}   type={href ? undefined : type}   {href}   on:click   on:change   on:keydown   on:keyup   on:mouseenter   on:mouseleave   tabindex="0"   use:builderActions={{ builders }}   {...getAttrs(builders)}   {...$$restProps}   {...attrs}  >
	function create_dynamic_element(ctx) {
		let svelte_element;
		let svelte_element_type_value;
		let builderActions_action;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[7].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

		let svelte_element_levels = [
			{
				type: svelte_element_type_value = /*href*/ ctx[1] ? undefined : /*type*/ ctx[2]
			},
			{ href: /*href*/ ctx[1] },
			{ tabindex: "0" },
			getAttrs(/*builders*/ ctx[3]),
			/*$$restProps*/ ctx[5],
			/*attrs*/ ctx[4]
		];

		let svelte_element_data = {};

		for (let i = 0; i < svelte_element_levels.length; i += 1) {
			svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
		}

		const block = {
			c: function create() {
				svelte_element = element(/*href*/ ctx[1] ? "a" : "button");
				if (default_slot) default_slot.c();
				set_dynamic_element_data(/*href*/ ctx[1] ? "a" : "button")(svelte_element, svelte_element_data);
				add_location(svelte_element, file$j, 12, 1, 330);
			},
			m: function mount(target, anchor) {
				insert_dev(target, svelte_element, anchor);

				if (default_slot) {
					default_slot.m(svelte_element, null);
				}

				/*svelte_element_binding*/ ctx[20](svelte_element);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(svelte_element, "click", /*click_handler*/ ctx[8], false, false, false, false),
						listen_dev(svelte_element, "change", /*change_handler*/ ctx[9], false, false, false, false),
						listen_dev(svelte_element, "keydown", /*keydown_handler*/ ctx[10], false, false, false, false),
						listen_dev(svelte_element, "keyup", /*keyup_handler*/ ctx[11], false, false, false, false),
						listen_dev(svelte_element, "mouseenter", /*mouseenter_handler*/ ctx[12], false, false, false, false),
						listen_dev(svelte_element, "mouseleave", /*mouseleave_handler*/ ctx[13], false, false, false, false),
						action_destroyer(builderActions_action = builderActions.call(null, svelte_element, { builders: /*builders*/ ctx[3] }))
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[6],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
							null
						);
					}
				}

				set_dynamic_element_data(/*href*/ ctx[1] ? "a" : "button")(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
					(!current || dirty & /*href, type*/ 6 && svelte_element_type_value !== (svelte_element_type_value = /*href*/ ctx[1] ? undefined : /*type*/ ctx[2])) && { type: svelte_element_type_value },
					(!current || dirty & /*href*/ 2) && { href: /*href*/ ctx[1] },
					{ tabindex: "0" },
					dirty & /*builders*/ 8 && getAttrs(/*builders*/ ctx[3]),
					dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5],
					/*attrs*/ ctx[4]
				]));

				if (builderActions_action && is_function(builderActions_action.update) && dirty & /*builders*/ 8) builderActions_action.update.call(null, { builders: /*builders*/ ctx[3] });
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svelte_element);
				}

				if (default_slot) default_slot.d(detaching);
				/*svelte_element_binding*/ ctx[20](null);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_dynamic_element.name,
			type: "child_dynamic_element",
			source: "(13:1) <svelte:element   this={href ? \\\"a\\\" : \\\"button\\\"}   bind:this={el}   type={href ? undefined : type}   {href}   on:click   on:change   on:keydown   on:keyup   on:mouseenter   on:mouseleave   tabindex=\\\"0\\\"   use:builderActions={{ builders }}   {...getAttrs(builders)}   {...$$restProps}   {...attrs}  >",
			ctx
		});

		return block;
	}

	function create_fragment$s(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$d, create_else_block$b];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*builders*/ ctx[3] && /*builders*/ ctx[3].length) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$s.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$s($$self, $$props, $$invalidate) {
		const omit_props_names = ["href","type","builders","el"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Button', slots, ['default']);
		let { href = void 0 } = $$props;
		let { type = void 0 } = $$props;
		let { builders = [] } = $$props;
		let { el = void 0 } = $$props;
		const attrs = { "data-button-root": "" };

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function change_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keydown_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keyup_handler(event) {
			bubble.call(this, $$self, event);
		}

		function mouseenter_handler(event) {
			bubble.call(this, $$self, event);
		}

		function mouseleave_handler(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		function change_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		function keydown_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		function keyup_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		function mouseenter_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		function mouseleave_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		function svelte_element_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('href' in $$new_props) $$invalidate(1, href = $$new_props.href);
			if ('type' in $$new_props) $$invalidate(2, type = $$new_props.type);
			if ('builders' in $$new_props) $$invalidate(3, builders = $$new_props.builders);
			if ('el' in $$new_props) $$invalidate(0, el = $$new_props.el);
			if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			builderActions,
			getAttrs,
			href,
			type,
			builders,
			el,
			attrs
		});

		$$self.$inject_state = $$new_props => {
			if ('href' in $$props) $$invalidate(1, href = $$new_props.href);
			if ('type' in $$props) $$invalidate(2, type = $$new_props.type);
			if ('builders' in $$props) $$invalidate(3, builders = $$new_props.builders);
			if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			el,
			href,
			type,
			builders,
			attrs,
			$$restProps,
			$$scope,
			slots,
			click_handler,
			change_handler,
			keydown_handler,
			keyup_handler,
			mouseenter_handler,
			mouseleave_handler,
			click_handler_1,
			change_handler_1,
			keydown_handler_1,
			keyup_handler_1,
			mouseenter_handler_1,
			mouseleave_handler_1,
			svelte_element_binding
		];
	}

	let Button$1 = class Button extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$s, create_fragment$s, safe_not_equal, { href: 1, type: 2, builders: 3, el: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Button",
				options,
				id: create_fragment$s.name
			});
		}

		get href() {
			throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set href(value) {
			throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get type() {
			throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set type(value) {
			throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get builders() {
			throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set builders(value) {
			throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get el() {
			throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set el(value) {
			throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	};

	var ButtonPrimitive = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Root: Button$1
	});

	function getSeparatorData() {
	    const NAME = "separator";
	    const PARTS = ["root"];
	    return {
	        NAME,
	        PARTS,
	    };
	}
	function setCtx$2(props) {
	    const { NAME, PARTS } = getSeparatorData();
	    const getAttrs = createBitAttrs(NAME, PARTS);
	    const separator = { ...createSeparator(removeUndefined(props)), getAttrs };
	    return {
	        ...separator,
	        updateOption: getOptionUpdater(separator.options),
	    };
	}

	/* node_modules/bits-ui/dist/bits/separator/components/separator.svelte generated by Svelte v4.2.10 */
	const file$i = "node_modules/bits-ui/dist/bits/separator/components/separator.svelte";
	const get_default_slot_changes$7 = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context$7 = ctx => ({ builder: /*builder*/ ctx[2] });

	// (25:0) {:else}
	function create_else_block$a(ctx) {
		let div;
		let mounted;
		let dispose;
		let div_levels = [/*builder*/ ctx[2], /*$$restProps*/ ctx[4]];
		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				set_attributes(div, div_data);
				add_location(div, file$i, 25, 1, 539);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				/*div_binding*/ ctx[10](div);

				if (!mounted) {
					dispose = action_destroyer(/*builder*/ ctx[2].action(div));
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				set_attributes(div, div_data = get_spread_update(div_levels, [
					dirty & /*builder*/ 4 && /*builder*/ ctx[2],
					dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4]
				]));
			},
			i: noop$3,
			o: noop$3,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				/*div_binding*/ ctx[10](null);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$a.name,
			type: "else",
			source: "(25:0) {:else}",
			ctx
		});

		return block;
	}

	// (23:0) {#if asChild}
	function create_if_block$c(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[9].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context$7);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 260)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[8],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, get_default_slot_changes$7),
							get_default_slot_context$7
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$c.name,
			type: "if",
			source: "(23:0) {#if asChild}",
			ctx
		});

		return block;
	}

	function create_fragment$r(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$c, create_else_block$a];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*asChild*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$r.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$r($$self, $$props, $$invalidate) {
		let builder;
		const omit_props_names = ["orientation","decorative","asChild","el"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let $root;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Separator', slots, ['default']);
		let { orientation = "horizontal" } = $$props;
		let { decorative = true } = $$props;
		let { asChild = false } = $$props;
		let { el = void 0 } = $$props;
		const { elements: { root }, updateOption, getAttrs } = setCtx$2({ orientation, decorative });
		validate_store(root, 'root');
		component_subscribe($$self, root, value => $$invalidate(7, $root = value));
		const attrs = getAttrs("root");

		function div_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('orientation' in $$new_props) $$invalidate(5, orientation = $$new_props.orientation);
			if ('decorative' in $$new_props) $$invalidate(6, decorative = $$new_props.decorative);
			if ('asChild' in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$new_props) $$invalidate(0, el = $$new_props.el);
			if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			melt,
			setCtx: setCtx$2,
			orientation,
			decorative,
			asChild,
			el,
			root,
			updateOption,
			getAttrs,
			attrs,
			builder,
			$root
		});

		$$self.$inject_state = $$new_props => {
			if ('orientation' in $$props) $$invalidate(5, orientation = $$new_props.orientation);
			if ('decorative' in $$props) $$invalidate(6, decorative = $$new_props.decorative);
			if ('asChild' in $$props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
			if ('builder' in $$props) $$invalidate(2, builder = $$new_props.builder);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*orientation*/ 32) {
				updateOption("orientation", orientation);
			}

			if ($$self.$$.dirty & /*decorative*/ 64) {
				updateOption("decorative", decorative);
			}

			if ($$self.$$.dirty & /*$root*/ 128) {
				$$invalidate(2, builder = $root);
			}

			if ($$self.$$.dirty & /*builder*/ 4) {
				Object.assign(builder, attrs);
			}
		};

		return [
			el,
			asChild,
			builder,
			root,
			$$restProps,
			orientation,
			decorative,
			$root,
			$$scope,
			slots,
			div_binding
		];
	}

	let Separator$1 = class Separator extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$r, create_fragment$r, safe_not_equal, {
				orientation: 5,
				decorative: 6,
				asChild: 1,
				el: 0
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Separator",
				options,
				id: create_fragment$r.name
			});
		}

		get orientation() {
			throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set orientation(value) {
			throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get decorative() {
			throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set decorative(value) {
			throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get asChild() {
			throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set asChild(value) {
			throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get el() {
			throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set el(value) {
			throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	};

	var SeparatorPrimitive = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Root: Separator$1
	});

	function getTabsData() {
	    const NAME = "tabs";
	    const PARTS = ["root", "content", "list", "trigger"];
	    return {
	        NAME,
	        PARTS,
	    };
	}
	function setCtx$1(props) {
	    const { NAME, PARTS } = getTabsData();
	    const getAttrs = createBitAttrs(NAME, PARTS);
	    const tabs = { ...createTabs(removeUndefined(props)), getAttrs };
	    setContext(NAME, tabs);
	    return {
	        ...tabs,
	        updateOption: getOptionUpdater(tabs.options),
	    };
	}
	function getCtx$1() {
	    const { NAME } = getTabsData();
	    return getContext(NAME);
	}

	/* node_modules/bits-ui/dist/bits/tabs/components/tabs.svelte generated by Svelte v4.2.10 */
	const file$h = "node_modules/bits-ui/dist/bits/tabs/components/tabs.svelte";

	const get_default_slot_changes_1$5 = dirty => ({
		builder: dirty & /*builder*/ 4,
		value: dirty & /*$localValue*/ 8
	});

	const get_default_slot_context_1$5 = ctx => ({
		builder: /*builder*/ ctx[2],
		value: /*$localValue*/ ctx[3]
	});

	const get_default_slot_changes$6 = dirty => ({
		builder: dirty & /*builder*/ 4,
		value: dirty & /*$localValue*/ 8
	});

	const get_default_slot_context$6 = ctx => ({
		builder: /*builder*/ ctx[2],
		value: /*$localValue*/ ctx[3]
	});

	// (49:0) {:else}
	function create_else_block$9(ctx) {
		let div;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[15].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], get_default_slot_context_1$5);
		let div_levels = [/*builder*/ ctx[2], /*$$restProps*/ ctx[6]];
		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$h, 49, 1, 1027);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				/*div_binding*/ ctx[16](div);
				current = true;

				if (!mounted) {
					dispose = action_destroyer(/*builder*/ ctx[2].action(div));
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder, $localValue*/ 16396)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[14],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, get_default_slot_changes_1$5),
							get_default_slot_context_1$5
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					dirty & /*builder*/ 4 && /*builder*/ ctx[2],
					dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
				/*div_binding*/ ctx[16](null);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$9.name,
			type: "else",
			source: "(49:0) {:else}",
			ctx
		});

		return block;
	}

	// (47:0) {#if asChild}
	function create_if_block$b(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[15].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], get_default_slot_context$6);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder, $localValue*/ 16396)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[14],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, get_default_slot_changes$6),
							get_default_slot_context$6
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$b.name,
			type: "if",
			source: "(47:0) {#if asChild}",
			ctx
		});

		return block;
	}

	function create_fragment$q(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$b, create_else_block$9];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*asChild*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$q.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$q($$self, $$props, $$invalidate) {
		let builder;

		const omit_props_names = [
			"orientation","activateOnFocus","loop","autoSet","value","onValueChange","asChild","el"
		];

		let $$restProps = compute_rest_props($$props, omit_props_names);
		let $root;
		let $localValue;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Tabs', slots, ['default']);
		let { orientation = void 0 } = $$props;
		let { activateOnFocus = void 0 } = $$props;
		let { loop = void 0 } = $$props;
		let { autoSet = void 0 } = $$props;
		let { value = void 0 } = $$props;
		let { onValueChange = void 0 } = $$props;
		let { asChild = false } = $$props;
		let { el = void 0 } = $$props;

		const { elements: { root }, states: { value: localValue }, updateOption, getAttrs } = setCtx$1({
			orientation,
			activateOnFocus,
			loop,
			autoSet,
			defaultValue: value,
			onValueChange: ({ next }) => {
				if (value !== next) {
					onValueChange?.(next);
					$$invalidate(7, value = next);
				}

				return next;
			}
		});

		validate_store(root, 'root');
		component_subscribe($$self, root, value => $$invalidate(13, $root = value));
		validate_store(localValue, 'localValue');
		component_subscribe($$self, localValue, value => $$invalidate(3, $localValue = value));
		const attrs = getAttrs("root");

		function div_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('orientation' in $$new_props) $$invalidate(8, orientation = $$new_props.orientation);
			if ('activateOnFocus' in $$new_props) $$invalidate(9, activateOnFocus = $$new_props.activateOnFocus);
			if ('loop' in $$new_props) $$invalidate(10, loop = $$new_props.loop);
			if ('autoSet' in $$new_props) $$invalidate(11, autoSet = $$new_props.autoSet);
			if ('value' in $$new_props) $$invalidate(7, value = $$new_props.value);
			if ('onValueChange' in $$new_props) $$invalidate(12, onValueChange = $$new_props.onValueChange);
			if ('asChild' in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$new_props) $$invalidate(0, el = $$new_props.el);
			if ('$$scope' in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			melt,
			setCtx: setCtx$1,
			orientation,
			activateOnFocus,
			loop,
			autoSet,
			value,
			onValueChange,
			asChild,
			el,
			root,
			localValue,
			updateOption,
			getAttrs,
			attrs,
			builder,
			$root,
			$localValue
		});

		$$self.$inject_state = $$new_props => {
			if ('orientation' in $$props) $$invalidate(8, orientation = $$new_props.orientation);
			if ('activateOnFocus' in $$props) $$invalidate(9, activateOnFocus = $$new_props.activateOnFocus);
			if ('loop' in $$props) $$invalidate(10, loop = $$new_props.loop);
			if ('autoSet' in $$props) $$invalidate(11, autoSet = $$new_props.autoSet);
			if ('value' in $$props) $$invalidate(7, value = $$new_props.value);
			if ('onValueChange' in $$props) $$invalidate(12, onValueChange = $$new_props.onValueChange);
			if ('asChild' in $$props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
			if ('builder' in $$props) $$invalidate(2, builder = $$new_props.builder);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*value*/ 128) {
				value !== void 0 && localValue.set(value);
			}

			if ($$self.$$.dirty & /*orientation*/ 256) {
				updateOption("orientation", orientation);
			}

			if ($$self.$$.dirty & /*activateOnFocus*/ 512) {
				updateOption("activateOnFocus", activateOnFocus);
			}

			if ($$self.$$.dirty & /*loop*/ 1024) {
				updateOption("loop", loop);
			}

			if ($$self.$$.dirty & /*autoSet*/ 2048) {
				updateOption("autoSet", autoSet);
			}

			if ($$self.$$.dirty & /*$root*/ 8192) {
				$$invalidate(2, builder = $root);
			}

			if ($$self.$$.dirty & /*builder*/ 4) {
				Object.assign(builder, attrs);
			}
		};

		return [
			el,
			asChild,
			builder,
			$localValue,
			root,
			localValue,
			$$restProps,
			value,
			orientation,
			activateOnFocus,
			loop,
			autoSet,
			onValueChange,
			$root,
			$$scope,
			slots,
			div_binding
		];
	}

	let Tabs$1 = class Tabs extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$q, create_fragment$q, safe_not_equal, {
				orientation: 8,
				activateOnFocus: 9,
				loop: 10,
				autoSet: 11,
				value: 7,
				onValueChange: 12,
				asChild: 1,
				el: 0
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Tabs",
				options,
				id: create_fragment$q.name
			});
		}

		get orientation() {
			throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set orientation(value) {
			throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get activateOnFocus() {
			throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set activateOnFocus(value) {
			throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get loop() {
			throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set loop(value) {
			throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get autoSet() {
			throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set autoSet(value) {
			throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get value() {
			throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set value(value) {
			throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get onValueChange() {
			throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set onValueChange(value) {
			throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get asChild() {
			throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set asChild(value) {
			throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get el() {
			throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set el(value) {
			throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	};

	/* node_modules/bits-ui/dist/bits/tabs/components/tabs-content.svelte generated by Svelte v4.2.10 */
	const file$g = "node_modules/bits-ui/dist/bits/tabs/components/tabs-content.svelte";
	const get_default_slot_changes_1$4 = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context_1$4 = ctx => ({ builder: /*builder*/ ctx[2] });
	const get_default_slot_changes$5 = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context$5 = ctx => ({ builder: /*builder*/ ctx[2] });

	// (19:0) {:else}
	function create_else_block$8(ctx) {
		let div;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[8].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context_1$4);
		let div_levels = [/*builder*/ ctx[2], /*$$restProps*/ ctx[4]];
		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$g, 19, 1, 369);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				/*div_binding*/ ctx[9](div);
				current = true;

				if (!mounted) {
					dispose = action_destroyer(/*builder*/ ctx[2].action(div));
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 132)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[7],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, get_default_slot_changes_1$4),
							get_default_slot_context_1$4
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					dirty & /*builder*/ 4 && /*builder*/ ctx[2],
					dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
				/*div_binding*/ ctx[9](null);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$8.name,
			type: "else",
			source: "(19:0) {:else}",
			ctx
		});

		return block;
	}

	// (17:0) {#if asChild}
	function create_if_block$a(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[8].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context$5);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 132)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[7],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, get_default_slot_changes$5),
							get_default_slot_context$5
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$a.name,
			type: "if",
			source: "(17:0) {#if asChild}",
			ctx
		});

		return block;
	}

	function create_fragment$p(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$a, create_else_block$8];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*asChild*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$p.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$p($$self, $$props, $$invalidate) {
		let builder;
		const omit_props_names = ["value","asChild","el"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let $content;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Tabs_content', slots, ['default']);
		let { value } = $$props;
		let { asChild = false } = $$props;
		let { el = void 0 } = $$props;
		const { elements: { content }, getAttrs } = getCtx$1();
		validate_store(content, 'content');
		component_subscribe($$self, content, value => $$invalidate(6, $content = value));
		const attrs = getAttrs("content");

		$$self.$$.on_mount.push(function () {
			if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
				console.warn("<Tabs_content> was created without expected prop 'value'");
			}
		});

		function div_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('value' in $$new_props) $$invalidate(5, value = $$new_props.value);
			if ('asChild' in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$new_props) $$invalidate(0, el = $$new_props.el);
			if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			melt,
			getCtx: getCtx$1,
			value,
			asChild,
			el,
			content,
			getAttrs,
			attrs,
			builder,
			$content
		});

		$$self.$inject_state = $$new_props => {
			if ('value' in $$props) $$invalidate(5, value = $$new_props.value);
			if ('asChild' in $$props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
			if ('builder' in $$props) $$invalidate(2, builder = $$new_props.builder);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*$content, value*/ 96) {
				$$invalidate(2, builder = $content(value));
			}

			if ($$self.$$.dirty & /*builder*/ 4) {
				Object.assign(builder, attrs);
			}
		};

		return [
			el,
			asChild,
			builder,
			content,
			$$restProps,
			value,
			$content,
			$$scope,
			slots,
			div_binding
		];
	}

	let Tabs_content$1 = class Tabs_content extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$p, create_fragment$p, safe_not_equal, { value: 5, asChild: 1, el: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Tabs_content",
				options,
				id: create_fragment$p.name
			});
		}

		get value() {
			throw new Error("<Tabs_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set value(value) {
			throw new Error("<Tabs_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get asChild() {
			throw new Error("<Tabs_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set asChild(value) {
			throw new Error("<Tabs_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get el() {
			throw new Error("<Tabs_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set el(value) {
			throw new Error("<Tabs_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	};

	/* node_modules/bits-ui/dist/bits/tabs/components/tabs-list.svelte generated by Svelte v4.2.10 */
	const file$f = "node_modules/bits-ui/dist/bits/tabs/components/tabs-list.svelte";
	const get_default_slot_changes_1$3 = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context_1$3 = ctx => ({ builder: /*builder*/ ctx[2] });
	const get_default_slot_changes$4 = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context$4 = ctx => ({ builder: /*builder*/ ctx[2] });

	// (18:0) {:else}
	function create_else_block$7(ctx) {
		let div;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[7].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], get_default_slot_context_1$3);
		let div_levels = [/*builder*/ ctx[2], /*$$restProps*/ ctx[4]];
		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$f, 18, 1, 335);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				/*div_binding*/ ctx[8](div);
				current = true;

				if (!mounted) {
					dispose = action_destroyer(/*builder*/ ctx[2].action(div));
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 68)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[6],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, get_default_slot_changes_1$3),
							get_default_slot_context_1$3
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					dirty & /*builder*/ 4 && /*builder*/ ctx[2],
					dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
				/*div_binding*/ ctx[8](null);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$7.name,
			type: "else",
			source: "(18:0) {:else}",
			ctx
		});

		return block;
	}

	// (16:0) {#if asChild}
	function create_if_block$9(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[7].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], get_default_slot_context$4);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 68)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[6],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, get_default_slot_changes$4),
							get_default_slot_context$4
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$9.name,
			type: "if",
			source: "(16:0) {#if asChild}",
			ctx
		});

		return block;
	}

	function create_fragment$o(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$9, create_else_block$7];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*asChild*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$o.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$o($$self, $$props, $$invalidate) {
		let builder;
		const omit_props_names = ["asChild","el"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let $list;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Tabs_list', slots, ['default']);
		let { asChild = false } = $$props;
		let { el = void 0 } = $$props;
		const { elements: { list }, getAttrs } = getCtx$1();
		validate_store(list, 'list');
		component_subscribe($$self, list, value => $$invalidate(5, $list = value));
		const attrs = getAttrs("list");

		function div_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('asChild' in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$new_props) $$invalidate(0, el = $$new_props.el);
			if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			melt,
			getCtx: getCtx$1,
			asChild,
			el,
			list,
			getAttrs,
			attrs,
			builder,
			$list
		});

		$$self.$inject_state = $$new_props => {
			if ('asChild' in $$props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
			if ('builder' in $$props) $$invalidate(2, builder = $$new_props.builder);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*$list*/ 32) {
				$$invalidate(2, builder = $list);
			}

			if ($$self.$$.dirty & /*builder*/ 4) {
				Object.assign(builder, attrs);
			}
		};

		return [el, asChild, builder, list, $$restProps, $list, $$scope, slots, div_binding];
	}

	let Tabs_list$1 = class Tabs_list extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$o, create_fragment$o, safe_not_equal, { asChild: 1, el: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Tabs_list",
				options,
				id: create_fragment$o.name
			});
		}

		get asChild() {
			throw new Error("<Tabs_list>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set asChild(value) {
			throw new Error("<Tabs_list>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get el() {
			throw new Error("<Tabs_list>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set el(value) {
			throw new Error("<Tabs_list>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	};

	/* node_modules/bits-ui/dist/bits/tabs/components/tabs-trigger.svelte generated by Svelte v4.2.10 */
	const file$e = "node_modules/bits-ui/dist/bits/tabs/components/tabs-trigger.svelte";
	const get_default_slot_changes_1$2 = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context_1$2 = ctx => ({ builder: /*builder*/ ctx[2] });
	const get_default_slot_changes$3 = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context$3 = ctx => ({ builder: /*builder*/ ctx[2] });

	// (22:0) {:else}
	function create_else_block$6(ctx) {
		let button;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[10].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], get_default_slot_context_1$2);
		let button_levels = [/*builder*/ ctx[2], { type: "button" }, /*$$restProps*/ ctx[5]];
		let button_data = {};

		for (let i = 0; i < button_levels.length; i += 1) {
			button_data = assign(button_data, button_levels[i]);
		}

		const block = {
			c: function create() {
				button = element("button");
				if (default_slot) default_slot.c();
				set_attributes(button, button_data);
				add_location(button, file$e, 22, 1, 514);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);

				if (default_slot) {
					default_slot.m(button, null);
				}

				if (button.autofocus) button.focus();
				/*button_binding*/ ctx[11](button);
				current = true;

				if (!mounted) {
					dispose = [
						action_destroyer(/*builder*/ ctx[2].action(button)),
						listen_dev(button, "m-click", /*dispatch*/ ctx[4], false, false, false, false),
						listen_dev(button, "m-focus", /*dispatch*/ ctx[4], false, false, false, false),
						listen_dev(button, "m-keydown", /*dispatch*/ ctx[4], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 516)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[9],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, get_default_slot_changes_1$2),
							get_default_slot_context_1$2
						);
					}
				}

				set_attributes(button, button_data = get_spread_update(button_levels, [
					dirty & /*builder*/ 4 && /*builder*/ ctx[2],
					{ type: "button" },
					dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				if (default_slot) default_slot.d(detaching);
				/*button_binding*/ ctx[11](null);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$6.name,
			type: "else",
			source: "(22:0) {:else}",
			ctx
		});

		return block;
	}

	// (20:0) {#if asChild}
	function create_if_block$8(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[10].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], get_default_slot_context$3);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 516)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[9],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, get_default_slot_changes$3),
							get_default_slot_context$3
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$8.name,
			type: "if",
			source: "(20:0) {#if asChild}",
			ctx
		});

		return block;
	}

	function create_fragment$n(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$8, create_else_block$6];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*asChild*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$n.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$n($$self, $$props, $$invalidate) {
		let builder;
		const omit_props_names = ["value","disabled","asChild","el"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let $trigger;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Tabs_trigger', slots, ['default']);
		let { value } = $$props;
		let { disabled = void 0 } = $$props;
		let { asChild = false } = $$props;
		let { el = void 0 } = $$props;
		const { elements: { trigger }, getAttrs } = getCtx$1();
		validate_store(trigger, 'trigger');
		component_subscribe($$self, trigger, value => $$invalidate(8, $trigger = value));
		const dispatch = createDispatcher();
		const attrs = getAttrs("trigger");

		$$self.$$.on_mount.push(function () {
			if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
				console.warn("<Tabs_trigger> was created without expected prop 'value'");
			}
		});

		function button_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('value' in $$new_props) $$invalidate(6, value = $$new_props.value);
			if ('disabled' in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
			if ('asChild' in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$new_props) $$invalidate(0, el = $$new_props.el);
			if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			melt,
			getCtx: getCtx$1,
			createDispatcher,
			value,
			disabled,
			asChild,
			el,
			trigger,
			getAttrs,
			dispatch,
			attrs,
			builder,
			$trigger
		});

		$$self.$inject_state = $$new_props => {
			if ('value' in $$props) $$invalidate(6, value = $$new_props.value);
			if ('disabled' in $$props) $$invalidate(7, disabled = $$new_props.disabled);
			if ('asChild' in $$props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
			if ('builder' in $$props) $$invalidate(2, builder = $$new_props.builder);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*$trigger, value, disabled*/ 448) {
				$$invalidate(2, builder = $trigger({ value, disabled }));
			}

			if ($$self.$$.dirty & /*builder*/ 4) {
				Object.assign(builder, attrs);
			}
		};

		return [
			el,
			asChild,
			builder,
			trigger,
			dispatch,
			$$restProps,
			value,
			disabled,
			$trigger,
			$$scope,
			slots,
			button_binding
		];
	}

	let Tabs_trigger$1 = class Tabs_trigger extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$n, create_fragment$n, safe_not_equal, { value: 6, disabled: 7, asChild: 1, el: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Tabs_trigger",
				options,
				id: create_fragment$n.name
			});
		}

		get value() {
			throw new Error("<Tabs_trigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set value(value) {
			throw new Error("<Tabs_trigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get disabled() {
			throw new Error("<Tabs_trigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set disabled(value) {
			throw new Error("<Tabs_trigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get asChild() {
			throw new Error("<Tabs_trigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set asChild(value) {
			throw new Error("<Tabs_trigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get el() {
			throw new Error("<Tabs_trigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set el(value) {
			throw new Error("<Tabs_trigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	};

	var TabsPrimitive = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Content: Tabs_content$1,
		List: Tabs_list$1,
		Root: Tabs$1,
		Trigger: Tabs_trigger$1
	});

	function getToggleGroupData() {
	    const NAME = "toggle-group";
	    const PARTS = ["root", "item"];
	    return {
	        NAME,
	        PARTS,
	    };
	}
	function setCtx(props) {
	    const { NAME, PARTS } = getToggleGroupData();
	    const getAttrs = createBitAttrs(NAME, PARTS);
	    const toggleGroup = { ...createToggleGroup(removeUndefined(props)), getAttrs };
	    setContext(NAME, toggleGroup);
	    return {
	        ...toggleGroup,
	        updateOption: getOptionUpdater(toggleGroup.options),
	    };
	}
	function getCtx() {
	    const { NAME } = getToggleGroupData();
	    return getContext(NAME);
	}

	/* node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group.svelte generated by Svelte v4.2.10 */
	const file$d = "node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group.svelte";
	const get_default_slot_changes_1$1 = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context_1$1 = ctx => ({ builder: /*builder*/ ctx[2] });
	const get_default_slot_changes$2 = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context$2 = ctx => ({ builder: /*builder*/ ctx[2] });

	// (58:0) {:else}
	function create_else_block$5(ctx) {
		let div;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[13].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context_1$1);
		let div_levels = [/*builder*/ ctx[2], /*$$restProps*/ ctx[4]];
		let div_data = {};

		for (let i = 0; i < div_levels.length; i += 1) {
			div_data = assign(div_data, div_levels[i]);
		}

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				set_attributes(div, div_data);
				add_location(div, file$d, 58, 1, 1272);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				/*div_binding*/ ctx[14](div);
				current = true;

				if (!mounted) {
					dispose = action_destroyer(/*builder*/ ctx[2].action(div));
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 4100)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[12],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, get_default_slot_changes_1$1),
							get_default_slot_context_1$1
						);
					}
				}

				set_attributes(div, div_data = get_spread_update(div_levels, [
					dirty & /*builder*/ 4 && /*builder*/ ctx[2],
					dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
				/*div_binding*/ ctx[14](null);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$5.name,
			type: "else",
			source: "(58:0) {:else}",
			ctx
		});

		return block;
	}

	// (56:0) {#if asChild}
	function create_if_block$7(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[13].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context$2);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 4100)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[12],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, get_default_slot_changes$2),
							get_default_slot_context$2
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$7.name,
			type: "if",
			source: "(56:0) {#if asChild}",
			ctx
		});

		return block;
	}

	function create_fragment$m(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$7, create_else_block$5];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*asChild*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$m.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$m($$self, $$props, $$invalidate) {
		let builder;
		const omit_props_names = ["type","disabled","loop","value","orientation","onValueChange","asChild","el"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let $root;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Toggle_group', slots, ['default']);
		let { type = "single" } = $$props;
		let { disabled = void 0 } = $$props;
		let { loop = void 0 } = $$props;
		let { value = void 0 } = $$props;
		let { orientation = void 0 } = $$props;
		let { onValueChange = void 0 } = $$props;
		let { asChild = false } = $$props;
		let { el = void 0 } = $$props;

		const { elements: { root }, states: { value: localValue }, updateOption, getAttrs } = setCtx({
			disabled,
			type,
			defaultValue: value,
			loop,
			orientation,
			onValueChange: ({ next }) => {
				if (Array.isArray(next)) {
					if (!Array.isArray(value) || !arraysAreEqual(value, next)) {
						onValueChange?.(next);
						$$invalidate(5, value = next);
						return next;
					}

					return next;
				}

				if (value !== next) {
					onValueChange?.(next);
					$$invalidate(5, value = next);
				}

				return next;
			}
		});

		validate_store(root, 'root');
		component_subscribe($$self, root, value => $$invalidate(11, $root = value));
		const attrs = getAttrs("root");

		function div_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('type' in $$new_props) $$invalidate(6, type = $$new_props.type);
			if ('disabled' in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
			if ('loop' in $$new_props) $$invalidate(8, loop = $$new_props.loop);
			if ('value' in $$new_props) $$invalidate(5, value = $$new_props.value);
			if ('orientation' in $$new_props) $$invalidate(9, orientation = $$new_props.orientation);
			if ('onValueChange' in $$new_props) $$invalidate(10, onValueChange = $$new_props.onValueChange);
			if ('asChild' in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$new_props) $$invalidate(0, el = $$new_props.el);
			if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			arraysAreEqual,
			melt,
			setCtx,
			type,
			disabled,
			loop,
			value,
			orientation,
			onValueChange,
			asChild,
			el,
			root,
			localValue,
			updateOption,
			getAttrs,
			attrs,
			builder,
			$root
		});

		$$self.$inject_state = $$new_props => {
			if ('type' in $$props) $$invalidate(6, type = $$new_props.type);
			if ('disabled' in $$props) $$invalidate(7, disabled = $$new_props.disabled);
			if ('loop' in $$props) $$invalidate(8, loop = $$new_props.loop);
			if ('value' in $$props) $$invalidate(5, value = $$new_props.value);
			if ('orientation' in $$props) $$invalidate(9, orientation = $$new_props.orientation);
			if ('onValueChange' in $$props) $$invalidate(10, onValueChange = $$new_props.onValueChange);
			if ('asChild' in $$props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
			if ('builder' in $$props) $$invalidate(2, builder = $$new_props.builder);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*value*/ 32) {
				value !== void 0 && localValue.set(Array.isArray(value) ? [...value] : value);
			}

			if ($$self.$$.dirty & /*disabled*/ 128) {
				updateOption("disabled", disabled);
			}

			if ($$self.$$.dirty & /*loop*/ 256) {
				updateOption("loop", loop);
			}

			if ($$self.$$.dirty & /*type*/ 64) {
				updateOption("type", type);
			}

			if ($$self.$$.dirty & /*orientation*/ 512) {
				updateOption("orientation", orientation);
			}

			if ($$self.$$.dirty & /*$root*/ 2048) {
				$$invalidate(2, builder = $root);
			}

			if ($$self.$$.dirty & /*builder*/ 4) {
				Object.assign(builder, attrs);
			}
		};

		return [
			el,
			asChild,
			builder,
			root,
			$$restProps,
			value,
			type,
			disabled,
			loop,
			orientation,
			onValueChange,
			$root,
			$$scope,
			slots,
			div_binding
		];
	}

	let Toggle_group$1 = class Toggle_group extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$m, create_fragment$m, safe_not_equal, {
				type: 6,
				disabled: 7,
				loop: 8,
				value: 5,
				orientation: 9,
				onValueChange: 10,
				asChild: 1,
				el: 0
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Toggle_group",
				options,
				id: create_fragment$m.name
			});
		}

		get type() {
			throw new Error("<Toggle_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set type(value) {
			throw new Error("<Toggle_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get disabled() {
			throw new Error("<Toggle_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set disabled(value) {
			throw new Error("<Toggle_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get loop() {
			throw new Error("<Toggle_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set loop(value) {
			throw new Error("<Toggle_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get value() {
			throw new Error("<Toggle_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set value(value) {
			throw new Error("<Toggle_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get orientation() {
			throw new Error("<Toggle_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set orientation(value) {
			throw new Error("<Toggle_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get onValueChange() {
			throw new Error("<Toggle_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set onValueChange(value) {
			throw new Error("<Toggle_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get asChild() {
			throw new Error("<Toggle_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set asChild(value) {
			throw new Error("<Toggle_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get el() {
			throw new Error("<Toggle_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set el(value) {
			throw new Error("<Toggle_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	};

	/* node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group-item.svelte generated by Svelte v4.2.10 */
	const file$c = "node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group-item.svelte";
	const get_default_slot_changes_1 = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context_1 = ctx => ({ builder: /*builder*/ ctx[2] });
	const get_default_slot_changes$1 = dirty => ({ builder: dirty & /*builder*/ 4 });
	const get_default_slot_context$1 = ctx => ({ builder: /*builder*/ ctx[2] });

	// (22:0) {:else}
	function create_else_block$4(ctx) {
		let button;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[10].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], get_default_slot_context_1);
		let button_levels = [/*builder*/ ctx[2], /*$$restProps*/ ctx[5]];
		let button_data = {};

		for (let i = 0; i < button_levels.length; i += 1) {
			button_data = assign(button_data, button_levels[i]);
		}

		const block = {
			c: function create() {
				button = element("button");
				if (default_slot) default_slot.c();
				set_attributes(button, button_data);
				add_location(button, file$c, 22, 1, 494);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);

				if (default_slot) {
					default_slot.m(button, null);
				}

				if (button.autofocus) button.focus();
				/*button_binding*/ ctx[11](button);
				current = true;

				if (!mounted) {
					dispose = [
						action_destroyer(/*builder*/ ctx[2].action(button)),
						listen_dev(button, "m-click", /*dispatch*/ ctx[4], false, false, false, false),
						listen_dev(button, "m-keydown", /*dispatch*/ ctx[4], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 516)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[9],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, get_default_slot_changes_1),
							get_default_slot_context_1
						);
					}
				}

				set_attributes(button, button_data = get_spread_update(button_levels, [
					dirty & /*builder*/ 4 && /*builder*/ ctx[2],
					dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				if (default_slot) default_slot.d(detaching);
				/*button_binding*/ ctx[11](null);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$4.name,
			type: "else",
			source: "(22:0) {:else}",
			ctx
		});

		return block;
	}

	// (20:0) {#if asChild}
	function create_if_block$6(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[10].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], get_default_slot_context$1);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 516)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[9],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, get_default_slot_changes$1),
							get_default_slot_context$1
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$6.name,
			type: "if",
			source: "(20:0) {#if asChild}",
			ctx
		});

		return block;
	}

	function create_fragment$l(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$6, create_else_block$4];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*asChild*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$l.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$l($$self, $$props, $$invalidate) {
		let builder;
		const omit_props_names = ["value","disabled","asChild","el"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let $item;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Toggle_group_item', slots, ['default']);
		let { value } = $$props;
		let { disabled = false } = $$props;
		let { asChild = false } = $$props;
		let { el = void 0 } = $$props;
		const { elements: { item }, getAttrs } = getCtx();
		validate_store(item, 'item');
		component_subscribe($$self, item, value => $$invalidate(8, $item = value));
		const dispatch = createDispatcher();
		const attrs = getAttrs("item");

		$$self.$$.on_mount.push(function () {
			if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
				console.warn("<Toggle_group_item> was created without expected prop 'value'");
			}
		});

		function button_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				el = $$value;
				$$invalidate(0, el);
			});
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('value' in $$new_props) $$invalidate(6, value = $$new_props.value);
			if ('disabled' in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
			if ('asChild' in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$new_props) $$invalidate(0, el = $$new_props.el);
			if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			melt,
			getCtx,
			createDispatcher,
			value,
			disabled,
			asChild,
			el,
			item,
			getAttrs,
			dispatch,
			attrs,
			builder,
			$item
		});

		$$self.$inject_state = $$new_props => {
			if ('value' in $$props) $$invalidate(6, value = $$new_props.value);
			if ('disabled' in $$props) $$invalidate(7, disabled = $$new_props.disabled);
			if ('asChild' in $$props) $$invalidate(1, asChild = $$new_props.asChild);
			if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
			if ('builder' in $$props) $$invalidate(2, builder = $$new_props.builder);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*$item, value, disabled*/ 448) {
				$$invalidate(2, builder = $item({ value, disabled }));
			}

			if ($$self.$$.dirty & /*builder*/ 4) {
				Object.assign(builder, attrs);
			}
		};

		return [
			el,
			asChild,
			builder,
			item,
			dispatch,
			$$restProps,
			value,
			disabled,
			$item,
			$$scope,
			slots,
			button_binding
		];
	}

	let Toggle_group_item$1 = class Toggle_group_item extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$l, create_fragment$l, safe_not_equal, { value: 6, disabled: 7, asChild: 1, el: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Toggle_group_item",
				options,
				id: create_fragment$l.name
			});
		}

		get value() {
			throw new Error("<Toggle_group_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set value(value) {
			throw new Error("<Toggle_group_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get disabled() {
			throw new Error("<Toggle_group_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set disabled(value) {
			throw new Error("<Toggle_group_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get asChild() {
			throw new Error("<Toggle_group_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set asChild(value) {
			throw new Error("<Toggle_group_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get el() {
			throw new Error("<Toggle_group_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set el(value) {
			throw new Error("<Toggle_group_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	};

	var ToggleGroupPrimitive = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Item: Toggle_group_item$1,
		Root: Toggle_group$1
	});

	/* src/lib/components/ui/tabs/tabs-content.svelte generated by Svelte v4.2.10 */

	// (8:0) <TabsPrimitive.Content  class={cn(   "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",   className  )}  {value}  {...$$restProps} >
	function create_default_slot$c(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[4],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$c.name,
			type: "slot",
			source: "(8:0) <TabsPrimitive.Content  class={cn(   \\\"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\\\",   className  )}  {value}  {...$$restProps} >",
			ctx
		});

		return block;
	}

	function create_fragment$k(ctx) {
		let tabsprimitive_content;
		let current;

		const tabsprimitive_content_spread_levels = [
			{
				class: cn("mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2", /*className*/ ctx[0])
			},
			{ value: /*value*/ ctx[1] },
			/*$$restProps*/ ctx[2]
		];

		let tabsprimitive_content_props = {
			$$slots: { default: [create_default_slot$c] },
			$$scope: { ctx }
		};

		for (let i = 0; i < tabsprimitive_content_spread_levels.length; i += 1) {
			tabsprimitive_content_props = assign(tabsprimitive_content_props, tabsprimitive_content_spread_levels[i]);
		}

		tabsprimitive_content = new Tabs_content$1({
				props: tabsprimitive_content_props,
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(tabsprimitive_content.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(tabsprimitive_content, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const tabsprimitive_content_changes = (dirty & /*className, value, $$restProps*/ 7)
				? get_spread_update(tabsprimitive_content_spread_levels, [
						dirty & /*className*/ 1 && {
							class: cn("mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2", /*className*/ ctx[0])
						},
						dirty & /*value*/ 2 && { value: /*value*/ ctx[1] },
						dirty & /*$$restProps*/ 4 && get_spread_object(/*$$restProps*/ ctx[2])
					])
				: {};

				if (dirty & /*$$scope*/ 16) {
					tabsprimitive_content_changes.$$scope = { dirty, ctx };
				}

				tabsprimitive_content.$set(tabsprimitive_content_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(tabsprimitive_content.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(tabsprimitive_content.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(tabsprimitive_content, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$k.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$k($$self, $$props, $$invalidate) {
		const omit_props_names = ["class","value"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Tabs_content', slots, ['default']);
		let { class: className = undefined } = $$props;
		let { value } = $$props;

		$$self.$$.on_mount.push(function () {
			if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
				console.warn("<Tabs_content> was created without expected prop 'value'");
			}
		});

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
			if ('value' in $$new_props) $$invalidate(1, value = $$new_props.value);
			if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({ TabsPrimitive, cn, className, value });

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
			if ('value' in $$props) $$invalidate(1, value = $$new_props.value);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [className, value, $$restProps, slots, $$scope];
	}

	class Tabs_content extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$k, create_fragment$k, safe_not_equal, { class: 0, value: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Tabs_content",
				options,
				id: create_fragment$k.name
			});
		}

		get class() {
			throw new Error("<Tabs_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Tabs_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get value() {
			throw new Error("<Tabs_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set value(value) {
			throw new Error("<Tabs_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/ui/tabs/tabs-list.svelte generated by Svelte v4.2.10 */

	// (7:0) <TabsPrimitive.List  class={cn(   "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",   className  )}  {...$$restProps} >
	function create_default_slot$b(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[2].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[3],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$b.name,
			type: "slot",
			source: "(7:0) <TabsPrimitive.List  class={cn(   \\\"inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground\\\",   className  )}  {...$$restProps} >",
			ctx
		});

		return block;
	}

	function create_fragment$j(ctx) {
		let tabsprimitive_list;
		let current;

		const tabsprimitive_list_spread_levels = [
			{
				class: cn("inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground", /*className*/ ctx[0])
			},
			/*$$restProps*/ ctx[1]
		];

		let tabsprimitive_list_props = {
			$$slots: { default: [create_default_slot$b] },
			$$scope: { ctx }
		};

		for (let i = 0; i < tabsprimitive_list_spread_levels.length; i += 1) {
			tabsprimitive_list_props = assign(tabsprimitive_list_props, tabsprimitive_list_spread_levels[i]);
		}

		tabsprimitive_list = new Tabs_list$1({
				props: tabsprimitive_list_props,
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(tabsprimitive_list.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(tabsprimitive_list, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const tabsprimitive_list_changes = (dirty & /*className, $$restProps*/ 3)
				? get_spread_update(tabsprimitive_list_spread_levels, [
						dirty & /*className*/ 1 && {
							class: cn("inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground", /*className*/ ctx[0])
						},
						dirty & /*$$restProps*/ 2 && get_spread_object(/*$$restProps*/ ctx[1])
					])
				: {};

				if (dirty & /*$$scope*/ 8) {
					tabsprimitive_list_changes.$$scope = { dirty, ctx };
				}

				tabsprimitive_list.$set(tabsprimitive_list_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(tabsprimitive_list.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(tabsprimitive_list.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(tabsprimitive_list, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$j.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$j($$self, $$props, $$invalidate) {
		const omit_props_names = ["class"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Tabs_list', slots, ['default']);
		let { class: className = undefined } = $$props;

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
			if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({ TabsPrimitive, cn, className });

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [className, $$restProps, slots, $$scope];
	}

	class Tabs_list extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$j, create_fragment$j, safe_not_equal, { class: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Tabs_list",
				options,
				id: create_fragment$j.name
			});
		}

		get class() {
			throw new Error("<Tabs_list>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Tabs_list>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/ui/tabs/tabs-trigger.svelte generated by Svelte v4.2.10 */

	// (8:0) <TabsPrimitive.Trigger  class={cn(   "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",   className  )}  {value}  {...$$restProps}  on:click  on:keydown  on:focus >
	function create_default_slot$a(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[7],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$a.name,
			type: "slot",
			source: "(8:0) <TabsPrimitive.Trigger  class={cn(   \\\"inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow\\\",   className  )}  {value}  {...$$restProps}  on:click  on:keydown  on:focus >",
			ctx
		});

		return block;
	}

	function create_fragment$i(ctx) {
		let tabsprimitive_trigger;
		let current;

		const tabsprimitive_trigger_spread_levels = [
			{
				class: cn("inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow", /*className*/ ctx[0])
			},
			{ value: /*value*/ ctx[1] },
			/*$$restProps*/ ctx[2]
		];

		let tabsprimitive_trigger_props = {
			$$slots: { default: [create_default_slot$a] },
			$$scope: { ctx }
		};

		for (let i = 0; i < tabsprimitive_trigger_spread_levels.length; i += 1) {
			tabsprimitive_trigger_props = assign(tabsprimitive_trigger_props, tabsprimitive_trigger_spread_levels[i]);
		}

		tabsprimitive_trigger = new Tabs_trigger$1({
				props: tabsprimitive_trigger_props,
				$$inline: true
			});

		tabsprimitive_trigger.$on("click", /*click_handler*/ ctx[4]);
		tabsprimitive_trigger.$on("keydown", /*keydown_handler*/ ctx[5]);
		tabsprimitive_trigger.$on("focus", /*focus_handler*/ ctx[6]);

		const block = {
			c: function create() {
				create_component(tabsprimitive_trigger.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(tabsprimitive_trigger, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const tabsprimitive_trigger_changes = (dirty & /*className, value, $$restProps*/ 7)
				? get_spread_update(tabsprimitive_trigger_spread_levels, [
						dirty & /*className*/ 1 && {
							class: cn("inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow", /*className*/ ctx[0])
						},
						dirty & /*value*/ 2 && { value: /*value*/ ctx[1] },
						dirty & /*$$restProps*/ 4 && get_spread_object(/*$$restProps*/ ctx[2])
					])
				: {};

				if (dirty & /*$$scope*/ 128) {
					tabsprimitive_trigger_changes.$$scope = { dirty, ctx };
				}

				tabsprimitive_trigger.$set(tabsprimitive_trigger_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(tabsprimitive_trigger.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(tabsprimitive_trigger.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(tabsprimitive_trigger, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$i.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$i($$self, $$props, $$invalidate) {
		const omit_props_names = ["class","value"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Tabs_trigger', slots, ['default']);
		let { class: className = undefined } = $$props;
		let { value } = $$props;

		$$self.$$.on_mount.push(function () {
			if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
				console.warn("<Tabs_trigger> was created without expected prop 'value'");
			}
		});

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keydown_handler(event) {
			bubble.call(this, $$self, event);
		}

		function focus_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
			if ('value' in $$new_props) $$invalidate(1, value = $$new_props.value);
			if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({ TabsPrimitive, cn, className, value });

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
			if ('value' in $$props) $$invalidate(1, value = $$new_props.value);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			className,
			value,
			$$restProps,
			slots,
			click_handler,
			keydown_handler,
			focus_handler,
			$$scope
		];
	}

	class Tabs_trigger extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$i, create_fragment$i, safe_not_equal, { class: 0, value: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Tabs_trigger",
				options,
				id: create_fragment$i.name
			});
		}

		get class() {
			throw new Error("<Tabs_trigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Tabs_trigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get value() {
			throw new Error("<Tabs_trigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set value(value) {
			throw new Error("<Tabs_trigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	const Root$1 = Tabs$1;

	var Tabs = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Content: Tabs_content,
		List: Tabs_list,
		Root: Root$1,
		Tabs: Root$1,
		TabsContent: Tabs_content,
		TabsList: Tabs_list,
		TabsTrigger: Tabs_trigger,
		Trigger: Tabs_trigger
	});

	var ElementStyleType;
	(function (ElementStyleType) {
	    ElementStyleType["Text"] = "text";
	    ElementStyleType["Number"] = "number";
	    ElementStyleType["Select"] = "select";
	    ElementStyleType["Color"] = "color";
	})(ElementStyleType || (ElementStyleType = {}));
	var ElementStyleGroup;
	(function (ElementStyleGroup) {
	    ElementStyleGroup["Size"] = "Size";
	    ElementStyleGroup["Position"] = "Position";
	    ElementStyleGroup["Style"] = "Style";
	    ElementStyleGroup["Text"] = "Text";
	    ElementStyleGroup["Spacing"] = "Padding & Margin";
	    ElementStyleGroup["Effects"] = "Effects";
	})(ElementStyleGroup || (ElementStyleGroup = {}));
	// Custom order for the groups
	const groupOrder = [
	    ElementStyleGroup.Size,
	    ElementStyleGroup.Position,
	    ElementStyleGroup.Style,
	    ElementStyleGroup.Text,
	    ElementStyleGroup.Spacing,
	    ElementStyleGroup.Effects,
	];
	class ElementStyle {
	    constructor(key, value, displayName, type, group, 
	    // Optional
	    options, units, max) {
	        this.key = key;
	        this.value = value;
	        this.displayName = displayName;
	        this.type = type;
	        this.group = group;
	        this.options = options;
	        this.units = units;
	        this.max = max;
	    }
	}
	// https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units
	const elementStyleUnits = ['px', '%', 'rem', 'vh', 'vw',];
	// Size: height, width, minHeight, minWidth, maxWidth, maxHeight, rotate, borderRadius
	// Position: position
	// Style: opacity, overflow, backgroundColor
	// Text: fontFamily fontSize fontWeight color letterSpacing lineHeight textAlign 
	// Spacing: marign padding
	// Effect: shadow border
	const elementStyles = [
	    // Size
	    new ElementStyle('width', '', 'W', ElementStyleType.Number, ElementStyleGroup.Size, [], elementStyleUnits, 1000),
	    new ElementStyle('height', '', 'H', ElementStyleType.Number, ElementStyleGroup.Size, [], elementStyleUnits, 1000),
	    new ElementStyle('minWidth', '', 'mW', ElementStyleType.Number, ElementStyleGroup.Size, [], elementStyleUnits, 1000),
	    new ElementStyle('minHeight', '', 'mH', ElementStyleType.Number, ElementStyleGroup.Size, [], elementStyleUnits, 1000),
	    new ElementStyle('maxWidth', '', 'MW', ElementStyleType.Number, ElementStyleGroup.Size, [], elementStyleUnits, 1000),
	    new ElementStyle('maxHeight', '', 'MH', ElementStyleType.Number, ElementStyleGroup.Size, [], elementStyleUnits, 1000),
	    new ElementStyle('rotate', '', 'Rot', ElementStyleType.Number, ElementStyleGroup.Size, [], ['deg', 'rad', 'grad', 'turn'], 1000),
	    new ElementStyle('borderRadius', '', 'Rad', ElementStyleType.Number, ElementStyleGroup.Size, [], elementStyleUnits, 1000),
	    // Position
	    new ElementStyle('position', 'relative', 'Type', ElementStyleType.Select, ElementStyleGroup.Position, ['relative', 'absolute', 'fixed', 'sticky', 'static']),
	    // Style
	    new ElementStyle('opacity', '100', 'Opacity', ElementStyleType.Number, ElementStyleGroup.Style, [], ['%'], 1),
	    new ElementStyle('overflow', 'visible', 'Overflow', ElementStyleType.Select, ElementStyleGroup.Style, ['visible', 'hidden', 'scroll', 'auto']),
	    new ElementStyle('backgroundColor', '', 'Background', ElementStyleType.Color, ElementStyleGroup.Style),
	    // Text
	    new ElementStyle('fontFamily', 'sans-serif', 'Font', ElementStyleType.Select, ElementStyleGroup.Text, [
	        'inherit',
	        'system-ui',
	        'serif',
	        'sans-serif',
	        'monospace',
	        'cursive',
	        'fantasy',
	        'emoji',
	        'math',
	        'fangsong'
	    ]),
	    new ElementStyle('fontSize', '16px', 'Font Size', ElementStyleType.Number, ElementStyleGroup.Text, [], elementStyleUnits, 100),
	    new ElementStyle('fontWeight', 'normal', 'Weight', ElementStyleType.Select, ElementStyleGroup.Text, [
	        'lighter',
	        'normal',
	        'bold',
	        'bolder',
	        '100',
	        '200',
	        '300',
	        '400',
	        '500',
	        '600',
	        '700',
	        '800',
	        '900'
	    ]),
	    new ElementStyle('color', 'rgba(0,0,0,1)', 'Color', ElementStyleType.Color, ElementStyleGroup.Text),
	    new ElementStyle('letterSpacing', '0px', 'Letter', ElementStyleType.Number, ElementStyleGroup.Text, [], elementStyleUnits, 100),
	    new ElementStyle('lineHeight', '100%', 'Line Height', ElementStyleType.Number, ElementStyleGroup.Text, [], elementStyleUnits, 100),
	    new ElementStyle('textAlign', 'start', 'Text Alignment', ElementStyleType.Select, ElementStyleGroup.Text, ['start', 'center', 'end',]),
	    // Spacing
	    new ElementStyle('marginTop', '', 'Margin Top', ElementStyleType.Number, ElementStyleGroup.Spacing, [], elementStyleUnits, 1000),
	    new ElementStyle('marginRight', '', 'Margin Right', ElementStyleType.Number, ElementStyleGroup.Spacing, [], elementStyleUnits, 1000),
	    new ElementStyle('marginBottom', '', 'Margin Bottom', ElementStyleType.Number, ElementStyleGroup.Spacing, [], elementStyleUnits, 1000),
	    new ElementStyle('marginLeft', '', 'Margin Left', ElementStyleType.Number, ElementStyleGroup.Spacing, [], elementStyleUnits, 1000),
	    new ElementStyle('paddingTop', '', 'Padding Top', ElementStyleType.Number, ElementStyleGroup.Spacing, [], elementStyleUnits, 1000),
	    new ElementStyle('paddingRight', '', 'Padding Right', ElementStyleType.Number, ElementStyleGroup.Spacing, [], elementStyleUnits, 1000),
	    new ElementStyle('paddingBottom', '', 'Padding Bottom', ElementStyleType.Number, ElementStyleGroup.Spacing, [], elementStyleUnits, 1000),
	    new ElementStyle('paddingLeft', '', 'Padding Left', ElementStyleType.Number, ElementStyleGroup.Spacing, [], elementStyleUnits, 1000),
	    // Effects
	    // TODO: Add effects
	];
	function sortGroupsByCustomOrder(groups) {
	    const sortedGroups = {};
	    // Iterate through the groupOrder array to ensure custom order
	    groupOrder.forEach(group => {
	        if (groups[group]) { // Check if the group exists in the input groups
	            sortedGroups[group] = groups[group];
	        }
	    });
	    return sortedGroups;
	}
	function groupElementStylesByGroup(elementStyles) {
	    return elementStyles.reduce((groups, style) => {
	        // Initialize the group if it doesn't exist
	        if (!groups[style.group]) {
	            groups[style.group] = [];
	        }
	        // Add the current style to the correct group
	        groups[style.group].push(style);
	        return sortGroupsByCustomOrder(groups);
	    }, {});
	}
	function getElementComputedStylesData(target) {
	    // Retrieve all computed styles for the clicked element
	    const computedStyles = getComputedStyle(target);
	    // TODO: Could get styles based on tag types
	    elementStyles.forEach((style) => {
	        const inlineStyle = target.style[style.key];
	        const computedStyle = computedStyles[style.key];
	        if (style.type === ElementStyleType.Number) {
	            style.value = (inlineStyle && inlineStyle !== '') ? inlineStyle : computedStyle;
	        }
	        else if (style.type === ElementStyleType.Color) {
	            style.value = inlineStyle && inlineStyle !== '' ? inlineStyle : computedStyle;
	        }
	        else {
	            style.value = inlineStyle && inlineStyle !== '' ? inlineStyle : computedStyle;
	        }
	    });
	    return elementStyles;
	}

	// License: MIT
	// Author: Anton Medvedev <anton@medv.io>
	// Source: https://github.com/antonmedv/finder
	let config$2;
	let rootDocument;
	function finder(input, options) {
	    if (input.nodeType !== Node.ELEMENT_NODE) {
	        throw new Error(`Can't generate CSS selector for non-element node type.`);
	    }
	    if ('html' === input.tagName.toLowerCase()) {
	        return 'html';
	    }
	    const defaults = {
	        root: document.body,
	        idName: (name) => true,
	        className: (name) => true,
	        tagName: (name) => true,
	        attr: (name, value) => false,
	        seedMinLength: 1,
	        optimizedMinLength: 2,
	        threshold: 1000,
	        maxNumberOfTries: 10000,
	    };
	    config$2 = { ...defaults, ...options };
	    rootDocument = findRootDocument(config$2.root, defaults);
	    let path = bottomUpSearch(input, 'all', () => bottomUpSearch(input, 'two', () => bottomUpSearch(input, 'one', () => bottomUpSearch(input, 'none'))));
	    if (path) {
	        const optimized = sort(optimize(path, input));
	        if (optimized.length > 0) {
	            path = optimized[0];
	        }
	        return selector(path);
	    }
	    else {
	        throw new Error(`Selector was not found.`);
	    }
	}
	function findRootDocument(rootNode, defaults) {
	    if (rootNode.nodeType === Node.DOCUMENT_NODE) {
	        return rootNode;
	    }
	    if (rootNode === defaults.root) {
	        return rootNode.ownerDocument;
	    }
	    return rootNode;
	}
	function bottomUpSearch(input, limit, fallback) {
	    let path = null;
	    let stack = [];
	    let current = input;
	    let i = 0;
	    while (current) {
	        let level = maybe(id(current)) ||
	            maybe(...attr(current)) ||
	            maybe(...classNames(current)) ||
	            maybe(tagName(current)) || [any()];
	        const nth = index(current);
	        if (limit == 'all') {
	            if (nth) {
	                level = level.concat(level.filter(dispensableNth).map((node) => nthChild(node, nth)));
	            }
	        }
	        else if (limit == 'two') {
	            level = level.slice(0, 1);
	            if (nth) {
	                level = level.concat(level.filter(dispensableNth).map((node) => nthChild(node, nth)));
	            }
	        }
	        else if (limit == 'one') {
	            const [node] = (level = level.slice(0, 1));
	            if (nth && dispensableNth(node)) {
	                level = [nthChild(node, nth)];
	            }
	        }
	        else if (limit == 'none') {
	            level = [any()];
	            if (nth) {
	                level = [nthChild(level[0], nth)];
	            }
	        }
	        for (let node of level) {
	            node.level = i;
	        }
	        stack.push(level);
	        if (stack.length >= config$2.seedMinLength) {
	            path = findUniquePath(stack, fallback);
	            if (path) {
	                break;
	            }
	        }
	        current = current.parentElement;
	        i++;
	    }
	    if (!path) {
	        path = findUniquePath(stack, fallback);
	    }
	    if (!path && fallback) {
	        return fallback();
	    }
	    return path;
	}
	function findUniquePath(stack, fallback) {
	    const paths = sort(combinations(stack));
	    if (paths.length > config$2.threshold) {
	        return fallback ? fallback() : null;
	    }
	    for (let candidate of paths) {
	        if (unique(candidate)) {
	            return candidate;
	        }
	    }
	    return null;
	}
	function selector(path) {
	    let node = path[0];
	    let query = node.name;
	    for (let i = 1; i < path.length; i++) {
	        const level = path[i].level || 0;
	        if (node.level === level - 1) {
	            query = `${path[i].name} > ${query}`;
	        }
	        else {
	            query = `${path[i].name} ${query}`;
	        }
	        node = path[i];
	    }
	    return query;
	}
	function penalty(path) {
	    return path.map((node) => node.penalty).reduce((acc, i) => acc + i, 0);
	}
	function unique(path) {
	    const css = selector(path);
	    switch (rootDocument.querySelectorAll(css).length) {
	        case 0:
	            throw new Error(`Can't select any node with this selector: ${css}`);
	        case 1:
	            return true;
	        default:
	            return false;
	    }
	}
	function id(input) {
	    const elementId = input.getAttribute('id');
	    if (elementId && config$2.idName(elementId)) {
	        return {
	            name: '#' + CSS.escape(elementId),
	            penalty: 0,
	        };
	    }
	    return null;
	}
	function attr(input) {
	    const attrs = Array.from(input.attributes).filter((attr) => config$2.attr(attr.name, attr.value));
	    return attrs.map((attr) => ({
	        name: `[${CSS.escape(attr.name)}="${CSS.escape(attr.value)}"]`,
	        penalty: 0.5,
	    }));
	}
	function classNames(input) {
	    const names = Array.from(input.classList).filter(config$2.className);
	    return names.map((name) => ({
	        name: '.' + CSS.escape(name),
	        penalty: 1,
	    }));
	}
	function tagName(input) {
	    const name = input.tagName.toLowerCase();
	    if (config$2.tagName(name)) {
	        return {
	            name,
	            penalty: 2,
	        };
	    }
	    return null;
	}
	function any() {
	    return {
	        name: '*',
	        penalty: 3,
	    };
	}
	function index(input) {
	    const parent = input.parentNode;
	    if (!parent) {
	        return null;
	    }
	    let child = parent.firstChild;
	    if (!child) {
	        return null;
	    }
	    let i = 0;
	    while (child) {
	        if (child.nodeType === Node.ELEMENT_NODE) {
	            i++;
	        }
	        if (child === input) {
	            break;
	        }
	        child = child.nextSibling;
	    }
	    return i;
	}
	function nthChild(node, i) {
	    return {
	        name: node.name + `:nth-child(${i})`,
	        penalty: node.penalty + 1,
	    };
	}
	function dispensableNth(node) {
	    return node.name !== 'html' && !node.name.startsWith('#');
	}
	function maybe(...level) {
	    const list = level.filter(notEmpty);
	    if (list.length > 0) {
	        return list;
	    }
	    return null;
	}
	function notEmpty(value) {
	    return value !== null && value !== undefined;
	}
	function* combinations(stack, path = []) {
	    if (stack.length > 0) {
	        for (let node of stack[0]) {
	            yield* combinations(stack.slice(1, stack.length), path.concat(node));
	        }
	    }
	    else {
	        yield path;
	    }
	}
	function sort(paths) {
	    return [...paths].sort((a, b) => penalty(a) - penalty(b));
	}
	function* optimize(path, input, scope = {
	    counter: 0,
	    visited: new Map(),
	}) {
	    if (path.length > 2 && path.length > config$2.optimizedMinLength) {
	        for (let i = 1; i < path.length - 1; i++) {
	            if (scope.counter > config$2.maxNumberOfTries) {
	                return; // Okay At least I tried!
	            }
	            scope.counter += 1;
	            const newPath = [...path];
	            newPath.splice(i, 1);
	            const newPathKey = selector(newPath);
	            if (scope.visited.has(newPathKey)) {
	                return;
	            }
	            if (unique(newPath) && same(newPath, input)) {
	                yield newPath;
	                scope.visited.set(newPathKey, true);
	                yield* optimize(newPath, input, scope);
	            }
	        }
	    }
	}
	function same(path, input) {
	    return rootDocument.querySelector(selector(path)) === input;
	}

	let historyStack = [];
	function addToHistory(event) {
	    // Merge to last item if styleType, selector and keys are the same
	    // Keeping oldest old val and newest new val
	    let lastEvent = peek();
	    if (lastEvent &&
	        lastEvent.detail.styleType === event.detail.styleType &&
	        lastEvent.detail.selector === event.detail.selector) {
	        lastEvent.detail.newVal = event.detail.newVal;
	    }
	    else {
	        historyStack.push(event);
	    }
	}
	function peek() {
	    return historyStack[historyStack.length - 1];
	}

	const STYLE_CHANGE = "STYLE_CHANGE";
	const OPEN_PROJECT = "OPEN_PROJECT";
	const elementSelectorCache = new WeakMap(); // Cache for element selectors
	function debounce(func, wait) {
	    const timeouts = {};
	    return function (...args) {
	        const context = this;
	        const element = args[0];
	        // Use cached selector if available, otherwise compute and cache it
	        if (!elementSelectorCache.has(element)) {
	            elementSelectorCache.set(element, finder(element, { className: () => false }));
	        }
	        const elementSelector = elementSelectorCache.get(element);
	        if (!timeouts[elementSelector]) {
	            func.apply(context, args); // Execute immediately
	        }
	        else {
	            clearTimeout(timeouts[elementSelector]);
	        }
	        const later = () => {
	            delete timeouts[elementSelector];
	            func.apply(context, args);
	        };
	        clearTimeout(timeouts[elementSelector]);
	        timeouts[elementSelector] = setTimeout(later, wait);
	    };
	}
	function postMessage(el, styleType, newValue, oldValue) {
	    const selector = elementSelectorCache.get(el) || finder(el, { className: () => false });
	    const event = {
	        type: STYLE_CHANGE,
	        detail: {
	            selector: selector,
	            styleType: styleType,
	            newVal: newValue,
	            oldVal: oldValue,
	            path: el.dataset.onlookId,
	        },
	    };
	    addToHistory(event);
	    window.postMessage(event, window.location.origin);
	}
	let debouncedPostMessage = debounce(postMessage, 1000);
	function emitStyleChangeEvent(el, styleType, newValue, oldValue) {
	    debouncedPostMessage(el, styleType, newValue, oldValue);
	}
	function emitOpenProjectMessage() {
	    window.postMessage({ type: OPEN_PROJECT }, window.location.origin);
	}

	/**
	 * Slides an element in and out.
	 *
	 * https://svelte.dev/docs/svelte-transition#slide
	 * @param {Element} node
	 * @param {import('./public').SlideParams} [params]
	 * @returns {import('./public').TransitionConfig}
	 */
	function slide(node, { delay = 0, duration = 400, easing = cubicOut, axis = 'y' } = {}) {
		const style = getComputedStyle(node);
		const opacity = +style.opacity;
		const primary_property = axis === 'y' ? 'height' : 'width';
		const primary_property_value = parseFloat(style[primary_property]);
		const secondary_properties = axis === 'y' ? ['top', 'bottom'] : ['left', 'right'];
		const capitalized_secondary_properties = secondary_properties.map(
			(e) => `${e[0].toUpperCase()}${e.slice(1)}`
		);
		const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
		const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
		const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
		const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
		const border_width_start_value = parseFloat(
			style[`border${capitalized_secondary_properties[0]}Width`]
		);
		const border_width_end_value = parseFloat(
			style[`border${capitalized_secondary_properties[1]}Width`]
		);
		return {
			delay,
			duration,
			easing,
			css: (t) =>
				'overflow: hidden;' +
				`opacity: ${Math.min(t * 20, 1) * opacity};` +
				`${primary_property}: ${t * primary_property_value}px;` +
				`padding-${secondary_properties[0]}: ${t * padding_start_value}px;` +
				`padding-${secondary_properties[1]}: ${t * padding_end_value}px;` +
				`margin-${secondary_properties[0]}: ${t * margin_start_value}px;` +
				`margin-${secondary_properties[1]}: ${t * margin_end_value}px;` +
				`border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;` +
				`border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`
		};
	}

	/* src/lib/components/ui/accordion/accordion-content.svelte generated by Svelte v4.2.10 */
	const file$b = "src/lib/components/ui/accordion/accordion-content.svelte";

	// (12:0) <AccordionPrimitive.Content  class={cn("overflow-hidden text-sm", className)}  {transition}  {transitionConfig}  {...$$restProps} >
	function create_default_slot$9(ctx) {
		let div;
		let current;
		const default_slot_template = /*#slots*/ ctx[4].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr_dev(div, "class", "pb-4 pt-0");
				add_location(div, file$b, 22, 1, 440);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[5],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$9.name,
			type: "slot",
			source: "(12:0) <AccordionPrimitive.Content  class={cn(\\\"overflow-hidden text-sm\\\", className)}  {transition}  {transitionConfig}  {...$$restProps} >",
			ctx
		});

		return block;
	}

	function create_fragment$h(ctx) {
		let accordionprimitive_content;
		let current;

		const accordionprimitive_content_spread_levels = [
			{
				class: cn("overflow-hidden text-sm", /*className*/ ctx[0])
			},
			{ transition: /*transition*/ ctx[1] },
			{
				transitionConfig: /*transitionConfig*/ ctx[2]
			},
			/*$$restProps*/ ctx[3]
		];

		let accordionprimitive_content_props = {
			$$slots: { default: [create_default_slot$9] },
			$$scope: { ctx }
		};

		for (let i = 0; i < accordionprimitive_content_spread_levels.length; i += 1) {
			accordionprimitive_content_props = assign(accordionprimitive_content_props, accordionprimitive_content_spread_levels[i]);
		}

		accordionprimitive_content = new Accordion_content$1({
				props: accordionprimitive_content_props,
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(accordionprimitive_content.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(accordionprimitive_content, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const accordionprimitive_content_changes = (dirty & /*className, transition, transitionConfig, $$restProps*/ 15)
				? get_spread_update(accordionprimitive_content_spread_levels, [
						dirty & /*className*/ 1 && {
							class: cn("overflow-hidden text-sm", /*className*/ ctx[0])
						},
						dirty & /*transition*/ 2 && { transition: /*transition*/ ctx[1] },
						dirty & /*transitionConfig*/ 4 && {
							transitionConfig: /*transitionConfig*/ ctx[2]
						},
						dirty & /*$$restProps*/ 8 && get_spread_object(/*$$restProps*/ ctx[3])
					])
				: {};

				if (dirty & /*$$scope*/ 32) {
					accordionprimitive_content_changes.$$scope = { dirty, ctx };
				}

				accordionprimitive_content.$set(accordionprimitive_content_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(accordionprimitive_content.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(accordionprimitive_content.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(accordionprimitive_content, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$h.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$h($$self, $$props, $$invalidate) {
		const omit_props_names = ["class","transition","transitionConfig"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Accordion_content', slots, ['default']);
		let { class: className = undefined } = $$props;
		let { transition = slide } = $$props;
		let { transitionConfig = { duration: 200 } } = $$props;

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
			if ('transition' in $$new_props) $$invalidate(1, transition = $$new_props.transition);
			if ('transitionConfig' in $$new_props) $$invalidate(2, transitionConfig = $$new_props.transitionConfig);
			if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			AccordionPrimitive,
			cn,
			slide,
			className,
			transition,
			transitionConfig
		});

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
			if ('transition' in $$props) $$invalidate(1, transition = $$new_props.transition);
			if ('transitionConfig' in $$props) $$invalidate(2, transitionConfig = $$new_props.transitionConfig);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [className, transition, transitionConfig, $$restProps, slots, $$scope];
	}

	class Accordion_content extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$h, create_fragment$h, safe_not_equal, {
				class: 0,
				transition: 1,
				transitionConfig: 2
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Accordion_content",
				options,
				id: create_fragment$h.name
			});
		}

		get class() {
			throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get transition() {
			throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set transition(value) {
			throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get transitionConfig() {
			throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set transitionConfig(value) {
			throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/ui/accordion/accordion-item.svelte generated by Svelte v4.2.10 */

	// (8:0) <AccordionPrimitive.Item {value} class={cn("border-b", className)} {...$$restProps}>
	function create_default_slot$8(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[4],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$8.name,
			type: "slot",
			source: "(8:0) <AccordionPrimitive.Item {value} class={cn(\\\"border-b\\\", className)} {...$$restProps}>",
			ctx
		});

		return block;
	}

	function create_fragment$g(ctx) {
		let accordionprimitive_item;
		let current;

		const accordionprimitive_item_spread_levels = [
			{ value: /*value*/ ctx[1] },
			{
				class: cn("border-b", /*className*/ ctx[0])
			},
			/*$$restProps*/ ctx[2]
		];

		let accordionprimitive_item_props = {
			$$slots: { default: [create_default_slot$8] },
			$$scope: { ctx }
		};

		for (let i = 0; i < accordionprimitive_item_spread_levels.length; i += 1) {
			accordionprimitive_item_props = assign(accordionprimitive_item_props, accordionprimitive_item_spread_levels[i]);
		}

		accordionprimitive_item = new Accordion_item$1({
				props: accordionprimitive_item_props,
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(accordionprimitive_item.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(accordionprimitive_item, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const accordionprimitive_item_changes = (dirty & /*value, className, $$restProps*/ 7)
				? get_spread_update(accordionprimitive_item_spread_levels, [
						dirty & /*value*/ 2 && { value: /*value*/ ctx[1] },
						dirty & /*className*/ 1 && {
							class: cn("border-b", /*className*/ ctx[0])
						},
						dirty & /*$$restProps*/ 4 && get_spread_object(/*$$restProps*/ ctx[2])
					])
				: {};

				if (dirty & /*$$scope*/ 16) {
					accordionprimitive_item_changes.$$scope = { dirty, ctx };
				}

				accordionprimitive_item.$set(accordionprimitive_item_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(accordionprimitive_item.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(accordionprimitive_item.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(accordionprimitive_item, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$g.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$g($$self, $$props, $$invalidate) {
		const omit_props_names = ["class","value"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Accordion_item', slots, ['default']);
		let { class: className = undefined } = $$props;
		let { value } = $$props;

		$$self.$$.on_mount.push(function () {
			if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
				console.warn("<Accordion_item> was created without expected prop 'value'");
			}
		});

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
			if ('value' in $$new_props) $$invalidate(1, value = $$new_props.value);
			if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({ AccordionPrimitive, cn, className, value });

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
			if ('value' in $$props) $$invalidate(1, value = $$new_props.value);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [className, value, $$restProps, slots, $$scope];
	}

	class Accordion_item extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$g, create_fragment$g, safe_not_equal, { class: 0, value: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Accordion_item",
				options,
				id: create_fragment$g.name
			});
		}

		get class() {
			throw new Error("<Accordion_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Accordion_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get value() {
			throw new Error("<Accordion_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set value(value) {
			throw new Error("<Accordion_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/ui/accordion/accordion-trigger.svelte generated by Svelte v4.2.10 */

	// (10:2) <AccordionPrimitive.Trigger     class={cn(       "flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",       className     )}     {...$$restProps}     on:click   >
	function create_default_slot_1$4(ctx) {
		let t;
		let chevrondown;
		let current;
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

		chevrondown = new ChevronDown$1({
				props: {
					class: "h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200"
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
				t = space();
				create_component(chevrondown.$$.fragment);
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				insert_dev(target, t, anchor);
				mount_component(chevrondown, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[5],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				transition_in(chevrondown.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				transition_out(chevrondown.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
				}

				if (default_slot) default_slot.d(detaching);
				destroy_component(chevrondown, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_1$4.name,
			type: "slot",
			source: "(10:2) <AccordionPrimitive.Trigger     class={cn(       \\\"flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180\\\",       className     )}     {...$$restProps}     on:click   >",
			ctx
		});

		return block;
	}

	// (9:0) <AccordionPrimitive.Header {level} class="flex">
	function create_default_slot$7(ctx) {
		let accordionprimitive_trigger;
		let current;

		const accordionprimitive_trigger_spread_levels = [
			{
				class: cn("flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180", /*className*/ ctx[0])
			},
			/*$$restProps*/ ctx[2]
		];

		let accordionprimitive_trigger_props = {
			$$slots: { default: [create_default_slot_1$4] },
			$$scope: { ctx }
		};

		for (let i = 0; i < accordionprimitive_trigger_spread_levels.length; i += 1) {
			accordionprimitive_trigger_props = assign(accordionprimitive_trigger_props, accordionprimitive_trigger_spread_levels[i]);
		}

		accordionprimitive_trigger = new Accordion_trigger$1({
				props: accordionprimitive_trigger_props,
				$$inline: true
			});

		accordionprimitive_trigger.$on("click", /*click_handler*/ ctx[4]);

		const block = {
			c: function create() {
				create_component(accordionprimitive_trigger.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(accordionprimitive_trigger, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const accordionprimitive_trigger_changes = (dirty & /*className, $$restProps*/ 5)
				? get_spread_update(accordionprimitive_trigger_spread_levels, [
						dirty & /*className*/ 1 && {
							class: cn("flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180", /*className*/ ctx[0])
						},
						dirty & /*$$restProps*/ 4 && get_spread_object(/*$$restProps*/ ctx[2])
					])
				: {};

				if (dirty & /*$$scope*/ 32) {
					accordionprimitive_trigger_changes.$$scope = { dirty, ctx };
				}

				accordionprimitive_trigger.$set(accordionprimitive_trigger_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(accordionprimitive_trigger.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(accordionprimitive_trigger.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(accordionprimitive_trigger, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$7.name,
			type: "slot",
			source: "(9:0) <AccordionPrimitive.Header {level} class=\\\"flex\\\">",
			ctx
		});

		return block;
	}

	function create_fragment$f(ctx) {
		let accordionprimitive_header;
		let current;

		accordionprimitive_header = new Accordion_header({
				props: {
					level: /*level*/ ctx[1],
					class: "flex",
					$$slots: { default: [create_default_slot$7] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(accordionprimitive_header.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(accordionprimitive_header, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const accordionprimitive_header_changes = {};
				if (dirty & /*level*/ 2) accordionprimitive_header_changes.level = /*level*/ ctx[1];

				if (dirty & /*$$scope, className, $$restProps*/ 37) {
					accordionprimitive_header_changes.$$scope = { dirty, ctx };
				}

				accordionprimitive_header.$set(accordionprimitive_header_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(accordionprimitive_header.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(accordionprimitive_header.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(accordionprimitive_header, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$f.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$f($$self, $$props, $$invalidate) {
		const omit_props_names = ["class","level"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Accordion_trigger', slots, ['default']);
		let { class: className = undefined } = $$props;
		let { level = 3 } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
			if ('level' in $$new_props) $$invalidate(1, level = $$new_props.level);
			if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			AccordionPrimitive,
			ChevronDown: ChevronDown$1,
			cn,
			className,
			level
		});

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
			if ('level' in $$props) $$invalidate(1, level = $$new_props.level);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [className, level, $$restProps, slots, click_handler, $$scope];
	}

	class Accordion_trigger extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$f, create_fragment$f, safe_not_equal, { class: 0, level: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Accordion_trigger",
				options,
				id: create_fragment$f.name
			});
		}

		get class() {
			throw new Error("<Accordion_trigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Accordion_trigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get level() {
			throw new Error("<Accordion_trigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set level(value) {
			throw new Error("<Accordion_trigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	const Root = Accordion$1;

	var Accordion = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Accordion: Root,
		AccordionContent: Accordion_content,
		AccordionItem: Accordion_item,
		AccordionTrigger: Accordion_trigger,
		Content: Accordion_content,
		Item: Accordion_item,
		Root: Root,
		Trigger: Accordion_trigger
	});

	/* src/lib/components/ui/input/input.svelte generated by Svelte v4.2.10 */
	const file$a = "src/lib/components/ui/input/input.svelte";

	function create_fragment$e(ctx) {
		let input;
		let input_class_value;
		let mounted;
		let dispose;

		let input_levels = [
			{
				class: input_class_value = cn("flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50", /*className*/ ctx[1])
			},
			/*$$restProps*/ ctx[2]
		];

		let input_data = {};

		for (let i = 0; i < input_levels.length; i += 1) {
			input_data = assign(input_data, input_levels[i]);
		}

		const block = {
			c: function create() {
				input = element("input");
				set_attributes(input, input_data);
				add_location(input, file$a, 13, 0, 150);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, input, anchor);
				if (input.autofocus) input.focus();
				set_input_value(input, /*value*/ ctx[0]);

				if (!mounted) {
					dispose = [
						listen_dev(input, "input", /*input_input_handler*/ ctx[17]),
						listen_dev(input, "blur", /*blur_handler*/ ctx[3], false, false, false, false),
						listen_dev(input, "change", /*change_handler*/ ctx[4], false, false, false, false),
						listen_dev(input, "click", /*click_handler*/ ctx[5], false, false, false, false),
						listen_dev(input, "focus", /*focus_handler*/ ctx[6], false, false, false, false),
						listen_dev(input, "focusin", /*focusin_handler*/ ctx[7], false, false, false, false),
						listen_dev(input, "focusout", /*focusout_handler*/ ctx[8], false, false, false, false),
						listen_dev(input, "keydown", /*keydown_handler*/ ctx[9], false, false, false, false),
						listen_dev(input, "keypress", /*keypress_handler*/ ctx[10], false, false, false, false),
						listen_dev(input, "keyup", /*keyup_handler*/ ctx[11], false, false, false, false),
						listen_dev(input, "mouseover", /*mouseover_handler*/ ctx[12], false, false, false, false),
						listen_dev(input, "mouseenter", /*mouseenter_handler*/ ctx[13], false, false, false, false),
						listen_dev(input, "mouseleave", /*mouseleave_handler*/ ctx[14], false, false, false, false),
						listen_dev(input, "paste", /*paste_handler*/ ctx[15], false, false, false, false),
						listen_dev(input, "input", /*input_handler*/ ctx[16], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				set_attributes(input, input_data = get_spread_update(input_levels, [
					dirty & /*className*/ 2 && input_class_value !== (input_class_value = cn("flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50", /*className*/ ctx[1])) && { class: input_class_value },
					dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2]
				]));

				if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
					set_input_value(input, /*value*/ ctx[0]);
				}
			},
			i: noop$3,
			o: noop$3,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(input);
				}

				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$e.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$e($$self, $$props, $$invalidate) {
		const omit_props_names = ["class","value"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Input', slots, []);
		let { class: className = undefined } = $$props;
		let { value = undefined } = $$props;

		function blur_handler(event) {
			bubble.call(this, $$self, event);
		}

		function change_handler(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function focus_handler(event) {
			bubble.call(this, $$self, event);
		}

		function focusin_handler(event) {
			bubble.call(this, $$self, event);
		}

		function focusout_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keydown_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keypress_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keyup_handler(event) {
			bubble.call(this, $$self, event);
		}

		function mouseover_handler(event) {
			bubble.call(this, $$self, event);
		}

		function mouseenter_handler(event) {
			bubble.call(this, $$self, event);
		}

		function mouseleave_handler(event) {
			bubble.call(this, $$self, event);
		}

		function paste_handler(event) {
			bubble.call(this, $$self, event);
		}

		function input_handler(event) {
			bubble.call(this, $$self, event);
		}

		function input_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
			if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
		};

		$$self.$capture_state = () => ({ cn, className, value });

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
			if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			value,
			className,
			$$restProps,
			blur_handler,
			change_handler,
			click_handler,
			focus_handler,
			focusin_handler,
			focusout_handler,
			keydown_handler,
			keypress_handler,
			keyup_handler,
			mouseover_handler,
			mouseenter_handler,
			mouseleave_handler,
			paste_handler,
			input_handler,
			input_input_handler
		];
	}

	class Input extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$e, create_fragment$e, safe_not_equal, { class: 1, value: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Input",
				options,
				id: create_fragment$e.name
			});
		}

		get class() {
			throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get value() {
			throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set value(value) {
			throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/ui/separator/separator.svelte generated by Svelte v4.2.10 */

	function create_fragment$d(ctx) {
		let separatorprimitive_root;
		let current;

		const separatorprimitive_root_spread_levels = [
			{
				class: cn(
					"shrink-0 bg-border",
					/*orientation*/ ctx[1] === "horizontal"
					? "h-[1px] w-full"
					: "h-full w-[1px]",
					/*className*/ ctx[0]
				)
			},
			{ orientation: /*orientation*/ ctx[1] },
			{ decorative: /*decorative*/ ctx[2] },
			/*$$restProps*/ ctx[3]
		];

		let separatorprimitive_root_props = {};

		for (let i = 0; i < separatorprimitive_root_spread_levels.length; i += 1) {
			separatorprimitive_root_props = assign(separatorprimitive_root_props, separatorprimitive_root_spread_levels[i]);
		}

		separatorprimitive_root = new Separator$1({
				props: separatorprimitive_root_props,
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(separatorprimitive_root.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(separatorprimitive_root, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const separatorprimitive_root_changes = (dirty & /*orientation, className, decorative, $$restProps*/ 15)
				? get_spread_update(separatorprimitive_root_spread_levels, [
						dirty & /*orientation, className*/ 3 && {
							class: cn(
								"shrink-0 bg-border",
								/*orientation*/ ctx[1] === "horizontal"
								? "h-[1px] w-full"
								: "h-full w-[1px]",
								/*className*/ ctx[0]
							)
						},
						dirty & /*orientation*/ 2 && { orientation: /*orientation*/ ctx[1] },
						dirty & /*decorative*/ 4 && { decorative: /*decorative*/ ctx[2] },
						dirty & /*$$restProps*/ 8 && get_spread_object(/*$$restProps*/ ctx[3])
					])
				: {};

				separatorprimitive_root.$set(separatorprimitive_root_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(separatorprimitive_root.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(separatorprimitive_root.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(separatorprimitive_root, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$d.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$d($$self, $$props, $$invalidate) {
		const omit_props_names = ["class","orientation","decorative"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Separator', slots, []);
		let { class: className = undefined } = $$props;
		let { orientation = "horizontal" } = $$props;
		let { decorative = undefined } = $$props;

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
			if ('orientation' in $$new_props) $$invalidate(1, orientation = $$new_props.orientation);
			if ('decorative' in $$new_props) $$invalidate(2, decorative = $$new_props.decorative);
		};

		$$self.$capture_state = () => ({
			SeparatorPrimitive,
			cn,
			className,
			orientation,
			decorative
		});

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
			if ('orientation' in $$props) $$invalidate(1, orientation = $$new_props.orientation);
			if ('decorative' in $$props) $$invalidate(2, decorative = $$new_props.decorative);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [className, orientation, decorative, $$restProps];
	}

	class Separator extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$d, create_fragment$d, safe_not_equal, { class: 0, orientation: 1, decorative: 2 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Separator",
				options,
				id: create_fragment$d.name
			});
		}

		get class() {
			throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get orientation() {
			throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set orientation(value) {
			throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get decorative() {
			throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set decorative(value) {
			throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/ui/toggle-group/toggle-group.svelte generated by Svelte v4.2.10 */
	const get_default_slot_changes = dirty => ({ builder: dirty & /*builder*/ 256 });
	const get_default_slot_context = ctx => ({ builder: /*builder*/ ctx[8] });

	// (15:0) <ToggleGroupPrimitive.Root  class={cn("flex items-center justify-center gap-1", className)}  bind:value  {...$$restProps}  let:builder >
	function create_default_slot$6(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[5].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope, builder*/ 384)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[7],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, get_default_slot_changes),
							get_default_slot_context
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$6.name,
			type: "slot",
			source: "(15:0) <ToggleGroupPrimitive.Root  class={cn(\\\"flex items-center justify-center gap-1\\\", className)}  bind:value  {...$$restProps}  let:builder >",
			ctx
		});

		return block;
	}

	function create_fragment$c(ctx) {
		let togglegroupprimitive_root;
		let updating_value;
		let current;

		const togglegroupprimitive_root_spread_levels = [
			{
				class: cn("flex items-center justify-center gap-1", /*className*/ ctx[1])
			},
			/*$$restProps*/ ctx[2]
		];

		function togglegroupprimitive_root_value_binding(value) {
			/*togglegroupprimitive_root_value_binding*/ ctx[6](value);
		}

		let togglegroupprimitive_root_props = {
			$$slots: {
				default: [
					create_default_slot$6,
					({ builder }) => ({ 8: builder }),
					({ builder }) => builder ? 256 : 0
				]
			},
			$$scope: { ctx }
		};

		for (let i = 0; i < togglegroupprimitive_root_spread_levels.length; i += 1) {
			togglegroupprimitive_root_props = assign(togglegroupprimitive_root_props, togglegroupprimitive_root_spread_levels[i]);
		}

		if (/*value*/ ctx[0] !== void 0) {
			togglegroupprimitive_root_props.value = /*value*/ ctx[0];
		}

		togglegroupprimitive_root = new Toggle_group$1({
				props: togglegroupprimitive_root_props,
				$$inline: true
			});

		binding_callbacks.push(() => bind(togglegroupprimitive_root, 'value', togglegroupprimitive_root_value_binding));

		const block = {
			c: function create() {
				create_component(togglegroupprimitive_root.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(togglegroupprimitive_root, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const togglegroupprimitive_root_changes = (dirty & /*className, $$restProps*/ 6)
				? get_spread_update(togglegroupprimitive_root_spread_levels, [
						dirty & /*className*/ 2 && {
							class: cn("flex items-center justify-center gap-1", /*className*/ ctx[1])
						},
						dirty & /*$$restProps*/ 4 && get_spread_object(/*$$restProps*/ ctx[2])
					])
				: {};

				if (dirty & /*$$scope, builder*/ 384) {
					togglegroupprimitive_root_changes.$$scope = { dirty, ctx };
				}

				if (!updating_value && dirty & /*value*/ 1) {
					updating_value = true;
					togglegroupprimitive_root_changes.value = /*value*/ ctx[0];
					add_flush_callback(() => updating_value = false);
				}

				togglegroupprimitive_root.$set(togglegroupprimitive_root_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(togglegroupprimitive_root.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(togglegroupprimitive_root.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(togglegroupprimitive_root, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$c.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$c($$self, $$props, $$invalidate) {
		const omit_props_names = ["class","variant","size","value"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Toggle_group', slots, ['default']);
		let { class: className = undefined } = $$props;
		let { variant = "default" } = $$props;
		let { size = "default" } = $$props;
		let { value = undefined } = $$props;
		setToggleGroupCtx({ variant, size });

		function togglegroupprimitive_root_value_binding(value$1) {
			value = value$1;
			$$invalidate(0, value);
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
			if ('variant' in $$new_props) $$invalidate(3, variant = $$new_props.variant);
			if ('size' in $$new_props) $$invalidate(4, size = $$new_props.size);
			if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
			if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			ToggleGroupPrimitive,
			setToggleGroupCtx,
			cn,
			className,
			variant,
			size,
			value
		});

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
			if ('variant' in $$props) $$invalidate(3, variant = $$new_props.variant);
			if ('size' in $$props) $$invalidate(4, size = $$new_props.size);
			if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			value,
			className,
			$$restProps,
			variant,
			size,
			slots,
			togglegroupprimitive_root_value_binding,
			$$scope
		];
	}

	class Toggle_group extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$c, create_fragment$c, safe_not_equal, { class: 1, variant: 3, size: 4, value: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Toggle_group",
				options,
				id: create_fragment$c.name
			});
		}

		get class() {
			throw new Error("<Toggle_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Toggle_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get variant() {
			throw new Error("<Toggle_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set variant(value) {
			throw new Error("<Toggle_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get size() {
			throw new Error("<Toggle_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set size(value) {
			throw new Error("<Toggle_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get value() {
			throw new Error("<Toggle_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set value(value) {
			throw new Error("<Toggle_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	var l=e=>typeof e=="boolean"?`${e}`:e===0?"0":e,u=e=>!e||typeof e!="object"||Object.keys(e).length===0,x=(e,o)=>JSON.stringify(e)===JSON.stringify(o);function i(e,o){e.forEach(function(r){Array.isArray(r)?i(r,o):o.push(r);});}function y(e){let o=[];return i(e,o),o}var a$1=(...e)=>y(e).filter(Boolean),p$1=(e,o)=>{let r={},c=Object.keys(e),f=Object.keys(o);for(let t of c)if(f.includes(t)){let s=e[t],n=o[t];typeof s=="object"&&typeof n=="object"?r[t]=p$1(s,n):Array.isArray(s)||Array.isArray(n)?r[t]=a$1(n,s):r[t]=n+" "+s;}else r[t]=e[t];for(let t of f)c.includes(t)||(r[t]=o[t]);return r},g$1=e=>!e||typeof e!="string"?e:e.replace(/\s+/g," ").trim();

	/**
	 * The code in this file is copied from https://github.com/lukeed/clsx and modified to suit the needs of tailwind-merge better.
	 *
	 * Specifically:
	 * - Runtime code from https://github.com/lukeed/clsx/blob/v1.2.1/src/index.js
	 * - TypeScript types from https://github.com/lukeed/clsx/blob/v1.2.1/clsx.d.ts
	 *
	 * Original code has MIT license: Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)
	 */
	function twJoin() {
	  var index = 0;
	  var argument;
	  var resolvedValue;
	  var string = '';
	  while (index < arguments.length) {
	    if (argument = arguments[index++]) {
	      if (resolvedValue = toValue(argument)) {
	        string && (string += ' ');
	        string += resolvedValue;
	      }
	    }
	  }
	  return string;
	}
	function toValue(mix) {
	  if (typeof mix === 'string') {
	    return mix;
	  }
	  var resolvedValue;
	  var string = '';
	  for (var k = 0; k < mix.length; k++) {
	    if (mix[k]) {
	      if (resolvedValue = toValue(mix[k])) {
	        string && (string += ' ');
	        string += resolvedValue;
	      }
	    }
	  }
	  return string;
	}

	var CLASS_PART_SEPARATOR = '-';
	function createClassUtils(config) {
	  var classMap = createClassMap(config);
	  var conflictingClassGroups = config.conflictingClassGroups,
	    _config$conflictingCl = config.conflictingClassGroupModifiers,
	    conflictingClassGroupModifiers = _config$conflictingCl === void 0 ? {} : _config$conflictingCl;
	  function getClassGroupId(className) {
	    var classParts = className.split(CLASS_PART_SEPARATOR);
	    // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.
	    if (classParts[0] === '' && classParts.length !== 1) {
	      classParts.shift();
	    }
	    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
	  }
	  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
	    var conflicts = conflictingClassGroups[classGroupId] || [];
	    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
	      return [].concat(conflicts, conflictingClassGroupModifiers[classGroupId]);
	    }
	    return conflicts;
	  }
	  return {
	    getClassGroupId: getClassGroupId,
	    getConflictingClassGroupIds: getConflictingClassGroupIds
	  };
	}
	function getGroupRecursive(classParts, classPartObject) {
	  if (classParts.length === 0) {
	    return classPartObject.classGroupId;
	  }
	  var currentClassPart = classParts[0];
	  var nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
	  var classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : undefined;
	  if (classGroupFromNextClassPart) {
	    return classGroupFromNextClassPart;
	  }
	  if (classPartObject.validators.length === 0) {
	    return undefined;
	  }
	  var classRest = classParts.join(CLASS_PART_SEPARATOR);
	  return classPartObject.validators.find(function (_ref) {
	    var validator = _ref.validator;
	    return validator(classRest);
	  })?.classGroupId;
	}
	var arbitraryPropertyRegex = /^\[(.+)\]$/;
	function getGroupIdForArbitraryProperty(className) {
	  if (arbitraryPropertyRegex.test(className)) {
	    var arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
	    var property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(':'));
	    if (property) {
	      // I use two dots here because one dot is used as prefix for class groups in plugins
	      return 'arbitrary..' + property;
	    }
	  }
	}
	/**
	 * Exported for testing only
	 */
	function createClassMap(config) {
	  var theme = config.theme,
	    prefix = config.prefix;
	  var classMap = {
	    nextPart: new Map(),
	    validators: []
	  };
	  var prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
	  prefixedClassGroupEntries.forEach(function (_ref2) {
	    var classGroupId = _ref2[0],
	      classGroup = _ref2[1];
	    processClassesRecursively(classGroup, classMap, classGroupId, theme);
	  });
	  return classMap;
	}
	function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
	  classGroup.forEach(function (classDefinition) {
	    if (typeof classDefinition === 'string') {
	      var classPartObjectToEdit = classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition);
	      classPartObjectToEdit.classGroupId = classGroupId;
	      return;
	    }
	    if (typeof classDefinition === 'function') {
	      if (isThemeGetter(classDefinition)) {
	        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
	        return;
	      }
	      classPartObject.validators.push({
	        validator: classDefinition,
	        classGroupId: classGroupId
	      });
	      return;
	    }
	    Object.entries(classDefinition).forEach(function (_ref3) {
	      var key = _ref3[0],
	        classGroup = _ref3[1];
	      processClassesRecursively(classGroup, getPart(classPartObject, key), classGroupId, theme);
	    });
	  });
	}
	function getPart(classPartObject, path) {
	  var currentClassPartObject = classPartObject;
	  path.split(CLASS_PART_SEPARATOR).forEach(function (pathPart) {
	    if (!currentClassPartObject.nextPart.has(pathPart)) {
	      currentClassPartObject.nextPart.set(pathPart, {
	        nextPart: new Map(),
	        validators: []
	      });
	    }
	    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
	  });
	  return currentClassPartObject;
	}
	function isThemeGetter(func) {
	  return func.isThemeGetter;
	}
	function getPrefixedClassGroupEntries(classGroupEntries, prefix) {
	  if (!prefix) {
	    return classGroupEntries;
	  }
	  return classGroupEntries.map(function (_ref4) {
	    var classGroupId = _ref4[0],
	      classGroup = _ref4[1];
	    var prefixedClassGroup = classGroup.map(function (classDefinition) {
	      if (typeof classDefinition === 'string') {
	        return prefix + classDefinition;
	      }
	      if (typeof classDefinition === 'object') {
	        return Object.fromEntries(Object.entries(classDefinition).map(function (_ref5) {
	          var key = _ref5[0],
	            value = _ref5[1];
	          return [prefix + key, value];
	        }));
	      }
	      return classDefinition;
	    });
	    return [classGroupId, prefixedClassGroup];
	  });
	}

	// LRU cache inspired from hashlru (https://github.com/dominictarr/hashlru/blob/v1.0.4/index.js) but object replaced with Map to improve performance
	function createLruCache(maxCacheSize) {
	  if (maxCacheSize < 1) {
	    return {
	      get: function get() {
	        return undefined;
	      },
	      set: function set() {}
	    };
	  }
	  var cacheSize = 0;
	  var cache = new Map();
	  var previousCache = new Map();
	  function update(key, value) {
	    cache.set(key, value);
	    cacheSize++;
	    if (cacheSize > maxCacheSize) {
	      cacheSize = 0;
	      previousCache = cache;
	      cache = new Map();
	    }
	  }
	  return {
	    get: function get(key) {
	      var value = cache.get(key);
	      if (value !== undefined) {
	        return value;
	      }
	      if ((value = previousCache.get(key)) !== undefined) {
	        update(key, value);
	        return value;
	      }
	    },
	    set: function set(key, value) {
	      if (cache.has(key)) {
	        cache.set(key, value);
	      } else {
	        update(key, value);
	      }
	    }
	  };
	}

	var IMPORTANT_MODIFIER = '!';
	function createSplitModifiers(config) {
	  var separator = config.separator || ':';
	  var isSeparatorSingleCharacter = separator.length === 1;
	  var firstSeparatorCharacter = separator[0];
	  var separatorLength = separator.length;
	  // splitModifiers inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js
	  return function splitModifiers(className) {
	    var modifiers = [];
	    var bracketDepth = 0;
	    var modifierStart = 0;
	    var postfixModifierPosition;
	    for (var index = 0; index < className.length; index++) {
	      var currentCharacter = className[index];
	      if (bracketDepth === 0) {
	        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index, index + separatorLength) === separator)) {
	          modifiers.push(className.slice(modifierStart, index));
	          modifierStart = index + separatorLength;
	          continue;
	        }
	        if (currentCharacter === '/') {
	          postfixModifierPosition = index;
	          continue;
	        }
	      }
	      if (currentCharacter === '[') {
	        bracketDepth++;
	      } else if (currentCharacter === ']') {
	        bracketDepth--;
	      }
	    }
	    var baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
	    var hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
	    var baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
	    var maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : undefined;
	    return {
	      modifiers: modifiers,
	      hasImportantModifier: hasImportantModifier,
	      baseClassName: baseClassName,
	      maybePostfixModifierPosition: maybePostfixModifierPosition
	    };
	  };
	}
	/**
	 * Sorts modifiers according to following schema:
	 * - Predefined modifiers are sorted alphabetically
	 * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it
	 */
	function sortModifiers(modifiers) {
	  if (modifiers.length <= 1) {
	    return modifiers;
	  }
	  var sortedModifiers = [];
	  var unsortedModifiers = [];
	  modifiers.forEach(function (modifier) {
	    var isArbitraryVariant = modifier[0] === '[';
	    if (isArbitraryVariant) {
	      sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort().concat([modifier]));
	      unsortedModifiers = [];
	    } else {
	      unsortedModifiers.push(modifier);
	    }
	  });
	  sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort());
	  return sortedModifiers;
	}

	function createConfigUtils(config) {
	  return {
	    cache: createLruCache(config.cacheSize),
	    splitModifiers: createSplitModifiers(config),
	    ...createClassUtils(config)
	  };
	}

	var SPLIT_CLASSES_REGEX = /\s+/;
	function mergeClassList(classList, configUtils) {
	  var splitModifiers = configUtils.splitModifiers,
	    getClassGroupId = configUtils.getClassGroupId,
	    getConflictingClassGroupIds = configUtils.getConflictingClassGroupIds;
	  /**
	   * Set of classGroupIds in following format:
	   * `{importantModifier}{variantModifiers}{classGroupId}`
	   * @example 'float'
	   * @example 'hover:focus:bg-color'
	   * @example 'md:!pr'
	   */
	  var classGroupsInConflict = new Set();
	  return classList.trim().split(SPLIT_CLASSES_REGEX).map(function (originalClassName) {
	    var _splitModifiers = splitModifiers(originalClassName),
	      modifiers = _splitModifiers.modifiers,
	      hasImportantModifier = _splitModifiers.hasImportantModifier,
	      baseClassName = _splitModifiers.baseClassName,
	      maybePostfixModifierPosition = _splitModifiers.maybePostfixModifierPosition;
	    var classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
	    var hasPostfixModifier = Boolean(maybePostfixModifierPosition);
	    if (!classGroupId) {
	      if (!maybePostfixModifierPosition) {
	        return {
	          isTailwindClass: false,
	          originalClassName: originalClassName
	        };
	      }
	      classGroupId = getClassGroupId(baseClassName);
	      if (!classGroupId) {
	        return {
	          isTailwindClass: false,
	          originalClassName: originalClassName
	        };
	      }
	      hasPostfixModifier = false;
	    }
	    var variantModifier = sortModifiers(modifiers).join(':');
	    var modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
	    return {
	      isTailwindClass: true,
	      modifierId: modifierId,
	      classGroupId: classGroupId,
	      originalClassName: originalClassName,
	      hasPostfixModifier: hasPostfixModifier
	    };
	  }).reverse()
	  // Last class in conflict wins, so we need to filter conflicting classes in reverse order.
	  .filter(function (parsed) {
	    if (!parsed.isTailwindClass) {
	      return true;
	    }
	    var modifierId = parsed.modifierId,
	      classGroupId = parsed.classGroupId,
	      hasPostfixModifier = parsed.hasPostfixModifier;
	    var classId = modifierId + classGroupId;
	    if (classGroupsInConflict.has(classId)) {
	      return false;
	    }
	    classGroupsInConflict.add(classId);
	    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach(function (group) {
	      return classGroupsInConflict.add(modifierId + group);
	    });
	    return true;
	  }).reverse().map(function (parsed) {
	    return parsed.originalClassName;
	  }).join(' ');
	}

	function createTailwindMerge() {
	  for (var _len = arguments.length, createConfig = new Array(_len), _key = 0; _key < _len; _key++) {
	    createConfig[_key] = arguments[_key];
	  }
	  var configUtils;
	  var cacheGet;
	  var cacheSet;
	  var functionToCall = initTailwindMerge;
	  function initTailwindMerge(classList) {
	    var firstCreateConfig = createConfig[0],
	      restCreateConfig = createConfig.slice(1);
	    var config = restCreateConfig.reduce(function (previousConfig, createConfigCurrent) {
	      return createConfigCurrent(previousConfig);
	    }, firstCreateConfig());
	    configUtils = createConfigUtils(config);
	    cacheGet = configUtils.cache.get;
	    cacheSet = configUtils.cache.set;
	    functionToCall = tailwindMerge;
	    return tailwindMerge(classList);
	  }
	  function tailwindMerge(classList) {
	    var cachedResult = cacheGet(classList);
	    if (cachedResult) {
	      return cachedResult;
	    }
	    var result = mergeClassList(classList, configUtils);
	    cacheSet(classList, result);
	    return result;
	  }
	  return function callTailwindMerge() {
	    return functionToCall(twJoin.apply(null, arguments));
	  };
	}

	function fromTheme$1(key) {
	  var themeGetter = function themeGetter(theme) {
	    return theme[key] || [];
	  };
	  themeGetter.isThemeGetter = true;
	  return themeGetter;
	}

	var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
	var fractionRegex = /^\d+\/\d+$/;
	var stringLengths = /*#__PURE__*/new Set(['px', 'full', 'screen']);
	var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
	var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
	// Shadow always begins with x and y offset separated by underscore
	var shadowRegex = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
	function isLength(value) {
	  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value) || isArbitraryLength(value);
	}
	function isArbitraryLength(value) {
	  return getIsArbitraryValue(value, 'length', isLengthOnly);
	}
	function isArbitrarySize(value) {
	  return getIsArbitraryValue(value, 'size', isNever);
	}
	function isArbitraryPosition(value) {
	  return getIsArbitraryValue(value, 'position', isNever);
	}
	function isArbitraryUrl(value) {
	  return getIsArbitraryValue(value, 'url', isUrl);
	}
	function isArbitraryNumber(value) {
	  return getIsArbitraryValue(value, 'number', isNumber);
	}
	function isNumber(value) {
	  return !Number.isNaN(Number(value));
	}
	function isPercent(value) {
	  return value.endsWith('%') && isNumber(value.slice(0, -1));
	}
	function isInteger(value) {
	  return isIntegerOnly(value) || getIsArbitraryValue(value, 'number', isIntegerOnly);
	}
	function isArbitraryValue(value) {
	  return arbitraryValueRegex.test(value);
	}
	function isAny() {
	  return true;
	}
	function isTshirtSize(value) {
	  return tshirtUnitRegex.test(value);
	}
	function isArbitraryShadow(value) {
	  return getIsArbitraryValue(value, '', isShadow);
	}
	function getIsArbitraryValue(value, label, testValue) {
	  var result = arbitraryValueRegex.exec(value);
	  if (result) {
	    if (result[1]) {
	      return result[1] === label;
	    }
	    return testValue(result[2]);
	  }
	  return false;
	}
	function isLengthOnly(value) {
	  return lengthUnitRegex.test(value);
	}
	function isNever() {
	  return false;
	}
	function isUrl(value) {
	  return value.startsWith('url(');
	}
	function isIntegerOnly(value) {
	  return Number.isInteger(Number(value));
	}
	function isShadow(value) {
	  return shadowRegex.test(value);
	}

	function getDefaultConfig() {
	  var colors = fromTheme$1('colors');
	  var spacing = fromTheme$1('spacing');
	  var blur = fromTheme$1('blur');
	  var brightness = fromTheme$1('brightness');
	  var borderColor = fromTheme$1('borderColor');
	  var borderRadius = fromTheme$1('borderRadius');
	  var borderSpacing = fromTheme$1('borderSpacing');
	  var borderWidth = fromTheme$1('borderWidth');
	  var contrast = fromTheme$1('contrast');
	  var grayscale = fromTheme$1('grayscale');
	  var hueRotate = fromTheme$1('hueRotate');
	  var invert = fromTheme$1('invert');
	  var gap = fromTheme$1('gap');
	  var gradientColorStops = fromTheme$1('gradientColorStops');
	  var gradientColorStopPositions = fromTheme$1('gradientColorStopPositions');
	  var inset = fromTheme$1('inset');
	  var margin = fromTheme$1('margin');
	  var opacity = fromTheme$1('opacity');
	  var padding = fromTheme$1('padding');
	  var saturate = fromTheme$1('saturate');
	  var scale = fromTheme$1('scale');
	  var sepia = fromTheme$1('sepia');
	  var skew = fromTheme$1('skew');
	  var space = fromTheme$1('space');
	  var translate = fromTheme$1('translate');
	  var getOverscroll = function getOverscroll() {
	    return ['auto', 'contain', 'none'];
	  };
	  var getOverflow = function getOverflow() {
	    return ['auto', 'hidden', 'clip', 'visible', 'scroll'];
	  };
	  var getSpacingWithAutoAndArbitrary = function getSpacingWithAutoAndArbitrary() {
	    return ['auto', isArbitraryValue, spacing];
	  };
	  var getSpacingWithArbitrary = function getSpacingWithArbitrary() {
	    return [isArbitraryValue, spacing];
	  };
	  var getLengthWithEmpty = function getLengthWithEmpty() {
	    return ['', isLength];
	  };
	  var getNumberWithAutoAndArbitrary = function getNumberWithAutoAndArbitrary() {
	    return ['auto', isNumber, isArbitraryValue];
	  };
	  var getPositions = function getPositions() {
	    return ['bottom', 'center', 'left', 'left-bottom', 'left-top', 'right', 'right-bottom', 'right-top', 'top'];
	  };
	  var getLineStyles = function getLineStyles() {
	    return ['solid', 'dashed', 'dotted', 'double', 'none'];
	  };
	  var getBlendModes = function getBlendModes() {
	    return ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity', 'plus-lighter'];
	  };
	  var getAlign = function getAlign() {
	    return ['start', 'end', 'center', 'between', 'around', 'evenly', 'stretch'];
	  };
	  var getZeroAndEmpty = function getZeroAndEmpty() {
	    return ['', '0', isArbitraryValue];
	  };
	  var getBreaks = function getBreaks() {
	    return ['auto', 'avoid', 'all', 'avoid-page', 'page', 'left', 'right', 'column'];
	  };
	  var getNumber = function getNumber() {
	    return [isNumber, isArbitraryNumber];
	  };
	  var getNumberAndArbitrary = function getNumberAndArbitrary() {
	    return [isNumber, isArbitraryValue];
	  };
	  return {
	    cacheSize: 500,
	    theme: {
	      colors: [isAny],
	      spacing: [isLength],
	      blur: ['none', '', isTshirtSize, isArbitraryValue],
	      brightness: getNumber(),
	      borderColor: [colors],
	      borderRadius: ['none', '', 'full', isTshirtSize, isArbitraryValue],
	      borderSpacing: getSpacingWithArbitrary(),
	      borderWidth: getLengthWithEmpty(),
	      contrast: getNumber(),
	      grayscale: getZeroAndEmpty(),
	      hueRotate: getNumberAndArbitrary(),
	      invert: getZeroAndEmpty(),
	      gap: getSpacingWithArbitrary(),
	      gradientColorStops: [colors],
	      gradientColorStopPositions: [isPercent, isArbitraryLength],
	      inset: getSpacingWithAutoAndArbitrary(),
	      margin: getSpacingWithAutoAndArbitrary(),
	      opacity: getNumber(),
	      padding: getSpacingWithArbitrary(),
	      saturate: getNumber(),
	      scale: getNumber(),
	      sepia: getZeroAndEmpty(),
	      skew: getNumberAndArbitrary(),
	      space: getSpacingWithArbitrary(),
	      translate: getSpacingWithArbitrary()
	    },
	    classGroups: {
	      // Layout
	      /**
	       * Aspect Ratio
	       * @see https://tailwindcss.com/docs/aspect-ratio
	       */
	      aspect: [{
	        aspect: ['auto', 'square', 'video', isArbitraryValue]
	      }],
	      /**
	       * Container
	       * @see https://tailwindcss.com/docs/container
	       */
	      container: ['container'],
	      /**
	       * Columns
	       * @see https://tailwindcss.com/docs/columns
	       */
	      columns: [{
	        columns: [isTshirtSize]
	      }],
	      /**
	       * Break After
	       * @see https://tailwindcss.com/docs/break-after
	       */
	      'break-after': [{
	        'break-after': getBreaks()
	      }],
	      /**
	       * Break Before
	       * @see https://tailwindcss.com/docs/break-before
	       */
	      'break-before': [{
	        'break-before': getBreaks()
	      }],
	      /**
	       * Break Inside
	       * @see https://tailwindcss.com/docs/break-inside
	       */
	      'break-inside': [{
	        'break-inside': ['auto', 'avoid', 'avoid-page', 'avoid-column']
	      }],
	      /**
	       * Box Decoration Break
	       * @see https://tailwindcss.com/docs/box-decoration-break
	       */
	      'box-decoration': [{
	        'box-decoration': ['slice', 'clone']
	      }],
	      /**
	       * Box Sizing
	       * @see https://tailwindcss.com/docs/box-sizing
	       */
	      box: [{
	        box: ['border', 'content']
	      }],
	      /**
	       * Display
	       * @see https://tailwindcss.com/docs/display
	       */
	      display: ['block', 'inline-block', 'inline', 'flex', 'inline-flex', 'table', 'inline-table', 'table-caption', 'table-cell', 'table-column', 'table-column-group', 'table-footer-group', 'table-header-group', 'table-row-group', 'table-row', 'flow-root', 'grid', 'inline-grid', 'contents', 'list-item', 'hidden'],
	      /**
	       * Floats
	       * @see https://tailwindcss.com/docs/float
	       */
	      "float": [{
	        "float": ['right', 'left', 'none']
	      }],
	      /**
	       * Clear
	       * @see https://tailwindcss.com/docs/clear
	       */
	      clear: [{
	        clear: ['left', 'right', 'both', 'none']
	      }],
	      /**
	       * Isolation
	       * @see https://tailwindcss.com/docs/isolation
	       */
	      isolation: ['isolate', 'isolation-auto'],
	      /**
	       * Object Fit
	       * @see https://tailwindcss.com/docs/object-fit
	       */
	      'object-fit': [{
	        object: ['contain', 'cover', 'fill', 'none', 'scale-down']
	      }],
	      /**
	       * Object Position
	       * @see https://tailwindcss.com/docs/object-position
	       */
	      'object-position': [{
	        object: [].concat(getPositions(), [isArbitraryValue])
	      }],
	      /**
	       * Overflow
	       * @see https://tailwindcss.com/docs/overflow
	       */
	      overflow: [{
	        overflow: getOverflow()
	      }],
	      /**
	       * Overflow X
	       * @see https://tailwindcss.com/docs/overflow
	       */
	      'overflow-x': [{
	        'overflow-x': getOverflow()
	      }],
	      /**
	       * Overflow Y
	       * @see https://tailwindcss.com/docs/overflow
	       */
	      'overflow-y': [{
	        'overflow-y': getOverflow()
	      }],
	      /**
	       * Overscroll Behavior
	       * @see https://tailwindcss.com/docs/overscroll-behavior
	       */
	      overscroll: [{
	        overscroll: getOverscroll()
	      }],
	      /**
	       * Overscroll Behavior X
	       * @see https://tailwindcss.com/docs/overscroll-behavior
	       */
	      'overscroll-x': [{
	        'overscroll-x': getOverscroll()
	      }],
	      /**
	       * Overscroll Behavior Y
	       * @see https://tailwindcss.com/docs/overscroll-behavior
	       */
	      'overscroll-y': [{
	        'overscroll-y': getOverscroll()
	      }],
	      /**
	       * Position
	       * @see https://tailwindcss.com/docs/position
	       */
	      position: ['static', 'fixed', 'absolute', 'relative', 'sticky'],
	      /**
	       * Top / Right / Bottom / Left
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      inset: [{
	        inset: [inset]
	      }],
	      /**
	       * Right / Left
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      'inset-x': [{
	        'inset-x': [inset]
	      }],
	      /**
	       * Top / Bottom
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      'inset-y': [{
	        'inset-y': [inset]
	      }],
	      /**
	       * Start
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      start: [{
	        start: [inset]
	      }],
	      /**
	       * End
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      end: [{
	        end: [inset]
	      }],
	      /**
	       * Top
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      top: [{
	        top: [inset]
	      }],
	      /**
	       * Right
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      right: [{
	        right: [inset]
	      }],
	      /**
	       * Bottom
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      bottom: [{
	        bottom: [inset]
	      }],
	      /**
	       * Left
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      left: [{
	        left: [inset]
	      }],
	      /**
	       * Visibility
	       * @see https://tailwindcss.com/docs/visibility
	       */
	      visibility: ['visible', 'invisible', 'collapse'],
	      /**
	       * Z-Index
	       * @see https://tailwindcss.com/docs/z-index
	       */
	      z: [{
	        z: ['auto', isInteger]
	      }],
	      // Flexbox and Grid
	      /**
	       * Flex Basis
	       * @see https://tailwindcss.com/docs/flex-basis
	       */
	      basis: [{
	        basis: getSpacingWithAutoAndArbitrary()
	      }],
	      /**
	       * Flex Direction
	       * @see https://tailwindcss.com/docs/flex-direction
	       */
	      'flex-direction': [{
	        flex: ['row', 'row-reverse', 'col', 'col-reverse']
	      }],
	      /**
	       * Flex Wrap
	       * @see https://tailwindcss.com/docs/flex-wrap
	       */
	      'flex-wrap': [{
	        flex: ['wrap', 'wrap-reverse', 'nowrap']
	      }],
	      /**
	       * Flex
	       * @see https://tailwindcss.com/docs/flex
	       */
	      flex: [{
	        flex: ['1', 'auto', 'initial', 'none', isArbitraryValue]
	      }],
	      /**
	       * Flex Grow
	       * @see https://tailwindcss.com/docs/flex-grow
	       */
	      grow: [{
	        grow: getZeroAndEmpty()
	      }],
	      /**
	       * Flex Shrink
	       * @see https://tailwindcss.com/docs/flex-shrink
	       */
	      shrink: [{
	        shrink: getZeroAndEmpty()
	      }],
	      /**
	       * Order
	       * @see https://tailwindcss.com/docs/order
	       */
	      order: [{
	        order: ['first', 'last', 'none', isInteger]
	      }],
	      /**
	       * Grid Template Columns
	       * @see https://tailwindcss.com/docs/grid-template-columns
	       */
	      'grid-cols': [{
	        'grid-cols': [isAny]
	      }],
	      /**
	       * Grid Column Start / End
	       * @see https://tailwindcss.com/docs/grid-column
	       */
	      'col-start-end': [{
	        col: ['auto', {
	          span: ['full', isInteger]
	        }, isArbitraryValue]
	      }],
	      /**
	       * Grid Column Start
	       * @see https://tailwindcss.com/docs/grid-column
	       */
	      'col-start': [{
	        'col-start': getNumberWithAutoAndArbitrary()
	      }],
	      /**
	       * Grid Column End
	       * @see https://tailwindcss.com/docs/grid-column
	       */
	      'col-end': [{
	        'col-end': getNumberWithAutoAndArbitrary()
	      }],
	      /**
	       * Grid Template Rows
	       * @see https://tailwindcss.com/docs/grid-template-rows
	       */
	      'grid-rows': [{
	        'grid-rows': [isAny]
	      }],
	      /**
	       * Grid Row Start / End
	       * @see https://tailwindcss.com/docs/grid-row
	       */
	      'row-start-end': [{
	        row: ['auto', {
	          span: [isInteger]
	        }, isArbitraryValue]
	      }],
	      /**
	       * Grid Row Start
	       * @see https://tailwindcss.com/docs/grid-row
	       */
	      'row-start': [{
	        'row-start': getNumberWithAutoAndArbitrary()
	      }],
	      /**
	       * Grid Row End
	       * @see https://tailwindcss.com/docs/grid-row
	       */
	      'row-end': [{
	        'row-end': getNumberWithAutoAndArbitrary()
	      }],
	      /**
	       * Grid Auto Flow
	       * @see https://tailwindcss.com/docs/grid-auto-flow
	       */
	      'grid-flow': [{
	        'grid-flow': ['row', 'col', 'dense', 'row-dense', 'col-dense']
	      }],
	      /**
	       * Grid Auto Columns
	       * @see https://tailwindcss.com/docs/grid-auto-columns
	       */
	      'auto-cols': [{
	        'auto-cols': ['auto', 'min', 'max', 'fr', isArbitraryValue]
	      }],
	      /**
	       * Grid Auto Rows
	       * @see https://tailwindcss.com/docs/grid-auto-rows
	       */
	      'auto-rows': [{
	        'auto-rows': ['auto', 'min', 'max', 'fr', isArbitraryValue]
	      }],
	      /**
	       * Gap
	       * @see https://tailwindcss.com/docs/gap
	       */
	      gap: [{
	        gap: [gap]
	      }],
	      /**
	       * Gap X
	       * @see https://tailwindcss.com/docs/gap
	       */
	      'gap-x': [{
	        'gap-x': [gap]
	      }],
	      /**
	       * Gap Y
	       * @see https://tailwindcss.com/docs/gap
	       */
	      'gap-y': [{
	        'gap-y': [gap]
	      }],
	      /**
	       * Justify Content
	       * @see https://tailwindcss.com/docs/justify-content
	       */
	      'justify-content': [{
	        justify: ['normal'].concat(getAlign())
	      }],
	      /**
	       * Justify Items
	       * @see https://tailwindcss.com/docs/justify-items
	       */
	      'justify-items': [{
	        'justify-items': ['start', 'end', 'center', 'stretch']
	      }],
	      /**
	       * Justify Self
	       * @see https://tailwindcss.com/docs/justify-self
	       */
	      'justify-self': [{
	        'justify-self': ['auto', 'start', 'end', 'center', 'stretch']
	      }],
	      /**
	       * Align Content
	       * @see https://tailwindcss.com/docs/align-content
	       */
	      'align-content': [{
	        content: ['normal'].concat(getAlign(), ['baseline'])
	      }],
	      /**
	       * Align Items
	       * @see https://tailwindcss.com/docs/align-items
	       */
	      'align-items': [{
	        items: ['start', 'end', 'center', 'baseline', 'stretch']
	      }],
	      /**
	       * Align Self
	       * @see https://tailwindcss.com/docs/align-self
	       */
	      'align-self': [{
	        self: ['auto', 'start', 'end', 'center', 'stretch', 'baseline']
	      }],
	      /**
	       * Place Content
	       * @see https://tailwindcss.com/docs/place-content
	       */
	      'place-content': [{
	        'place-content': [].concat(getAlign(), ['baseline'])
	      }],
	      /**
	       * Place Items
	       * @see https://tailwindcss.com/docs/place-items
	       */
	      'place-items': [{
	        'place-items': ['start', 'end', 'center', 'baseline', 'stretch']
	      }],
	      /**
	       * Place Self
	       * @see https://tailwindcss.com/docs/place-self
	       */
	      'place-self': [{
	        'place-self': ['auto', 'start', 'end', 'center', 'stretch']
	      }],
	      // Spacing
	      /**
	       * Padding
	       * @see https://tailwindcss.com/docs/padding
	       */
	      p: [{
	        p: [padding]
	      }],
	      /**
	       * Padding X
	       * @see https://tailwindcss.com/docs/padding
	       */
	      px: [{
	        px: [padding]
	      }],
	      /**
	       * Padding Y
	       * @see https://tailwindcss.com/docs/padding
	       */
	      py: [{
	        py: [padding]
	      }],
	      /**
	       * Padding Start
	       * @see https://tailwindcss.com/docs/padding
	       */
	      ps: [{
	        ps: [padding]
	      }],
	      /**
	       * Padding End
	       * @see https://tailwindcss.com/docs/padding
	       */
	      pe: [{
	        pe: [padding]
	      }],
	      /**
	       * Padding Top
	       * @see https://tailwindcss.com/docs/padding
	       */
	      pt: [{
	        pt: [padding]
	      }],
	      /**
	       * Padding Right
	       * @see https://tailwindcss.com/docs/padding
	       */
	      pr: [{
	        pr: [padding]
	      }],
	      /**
	       * Padding Bottom
	       * @see https://tailwindcss.com/docs/padding
	       */
	      pb: [{
	        pb: [padding]
	      }],
	      /**
	       * Padding Left
	       * @see https://tailwindcss.com/docs/padding
	       */
	      pl: [{
	        pl: [padding]
	      }],
	      /**
	       * Margin
	       * @see https://tailwindcss.com/docs/margin
	       */
	      m: [{
	        m: [margin]
	      }],
	      /**
	       * Margin X
	       * @see https://tailwindcss.com/docs/margin
	       */
	      mx: [{
	        mx: [margin]
	      }],
	      /**
	       * Margin Y
	       * @see https://tailwindcss.com/docs/margin
	       */
	      my: [{
	        my: [margin]
	      }],
	      /**
	       * Margin Start
	       * @see https://tailwindcss.com/docs/margin
	       */
	      ms: [{
	        ms: [margin]
	      }],
	      /**
	       * Margin End
	       * @see https://tailwindcss.com/docs/margin
	       */
	      me: [{
	        me: [margin]
	      }],
	      /**
	       * Margin Top
	       * @see https://tailwindcss.com/docs/margin
	       */
	      mt: [{
	        mt: [margin]
	      }],
	      /**
	       * Margin Right
	       * @see https://tailwindcss.com/docs/margin
	       */
	      mr: [{
	        mr: [margin]
	      }],
	      /**
	       * Margin Bottom
	       * @see https://tailwindcss.com/docs/margin
	       */
	      mb: [{
	        mb: [margin]
	      }],
	      /**
	       * Margin Left
	       * @see https://tailwindcss.com/docs/margin
	       */
	      ml: [{
	        ml: [margin]
	      }],
	      /**
	       * Space Between X
	       * @see https://tailwindcss.com/docs/space
	       */
	      'space-x': [{
	        'space-x': [space]
	      }],
	      /**
	       * Space Between X Reverse
	       * @see https://tailwindcss.com/docs/space
	       */
	      'space-x-reverse': ['space-x-reverse'],
	      /**
	       * Space Between Y
	       * @see https://tailwindcss.com/docs/space
	       */
	      'space-y': [{
	        'space-y': [space]
	      }],
	      /**
	       * Space Between Y Reverse
	       * @see https://tailwindcss.com/docs/space
	       */
	      'space-y-reverse': ['space-y-reverse'],
	      // Sizing
	      /**
	       * Width
	       * @see https://tailwindcss.com/docs/width
	       */
	      w: [{
	        w: ['auto', 'min', 'max', 'fit', isArbitraryValue, spacing]
	      }],
	      /**
	       * Min-Width
	       * @see https://tailwindcss.com/docs/min-width
	       */
	      'min-w': [{
	        'min-w': ['min', 'max', 'fit', isArbitraryValue, isLength]
	      }],
	      /**
	       * Max-Width
	       * @see https://tailwindcss.com/docs/max-width
	       */
	      'max-w': [{
	        'max-w': ['0', 'none', 'full', 'min', 'max', 'fit', 'prose', {
	          screen: [isTshirtSize]
	        }, isTshirtSize, isArbitraryValue]
	      }],
	      /**
	       * Height
	       * @see https://tailwindcss.com/docs/height
	       */
	      h: [{
	        h: [isArbitraryValue, spacing, 'auto', 'min', 'max', 'fit']
	      }],
	      /**
	       * Min-Height
	       * @see https://tailwindcss.com/docs/min-height
	       */
	      'min-h': [{
	        'min-h': ['min', 'max', 'fit', isArbitraryValue, isLength]
	      }],
	      /**
	       * Max-Height
	       * @see https://tailwindcss.com/docs/max-height
	       */
	      'max-h': [{
	        'max-h': [isArbitraryValue, spacing, 'min', 'max', 'fit']
	      }],
	      // Typography
	      /**
	       * Font Size
	       * @see https://tailwindcss.com/docs/font-size
	       */
	      'font-size': [{
	        text: ['base', isTshirtSize, isArbitraryLength]
	      }],
	      /**
	       * Font Smoothing
	       * @see https://tailwindcss.com/docs/font-smoothing
	       */
	      'font-smoothing': ['antialiased', 'subpixel-antialiased'],
	      /**
	       * Font Style
	       * @see https://tailwindcss.com/docs/font-style
	       */
	      'font-style': ['italic', 'not-italic'],
	      /**
	       * Font Weight
	       * @see https://tailwindcss.com/docs/font-weight
	       */
	      'font-weight': [{
	        font: ['thin', 'extralight', 'light', 'normal', 'medium', 'semibold', 'bold', 'extrabold', 'black', isArbitraryNumber]
	      }],
	      /**
	       * Font Family
	       * @see https://tailwindcss.com/docs/font-family
	       */
	      'font-family': [{
	        font: [isAny]
	      }],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-normal': ['normal-nums'],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-ordinal': ['ordinal'],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-slashed-zero': ['slashed-zero'],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-figure': ['lining-nums', 'oldstyle-nums'],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-spacing': ['proportional-nums', 'tabular-nums'],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-fraction': ['diagonal-fractions', 'stacked-fractons'],
	      /**
	       * Letter Spacing
	       * @see https://tailwindcss.com/docs/letter-spacing
	       */
	      tracking: [{
	        tracking: ['tighter', 'tight', 'normal', 'wide', 'wider', 'widest', isArbitraryValue]
	      }],
	      /**
	       * Line Clamp
	       * @see https://tailwindcss.com/docs/line-clamp
	       */
	      'line-clamp': [{
	        'line-clamp': ['none', isNumber, isArbitraryNumber]
	      }],
	      /**
	       * Line Height
	       * @see https://tailwindcss.com/docs/line-height
	       */
	      leading: [{
	        leading: ['none', 'tight', 'snug', 'normal', 'relaxed', 'loose', isArbitraryValue, isLength]
	      }],
	      /**
	       * List Style Image
	       * @see https://tailwindcss.com/docs/list-style-image
	       */
	      'list-image': [{
	        'list-image': ['none', isArbitraryValue]
	      }],
	      /**
	       * List Style Type
	       * @see https://tailwindcss.com/docs/list-style-type
	       */
	      'list-style-type': [{
	        list: ['none', 'disc', 'decimal', isArbitraryValue]
	      }],
	      /**
	       * List Style Position
	       * @see https://tailwindcss.com/docs/list-style-position
	       */
	      'list-style-position': [{
	        list: ['inside', 'outside']
	      }],
	      /**
	       * Placeholder Color
	       * @deprecated since Tailwind CSS v3.0.0
	       * @see https://tailwindcss.com/docs/placeholder-color
	       */
	      'placeholder-color': [{
	        placeholder: [colors]
	      }],
	      /**
	       * Placeholder Opacity
	       * @see https://tailwindcss.com/docs/placeholder-opacity
	       */
	      'placeholder-opacity': [{
	        'placeholder-opacity': [opacity]
	      }],
	      /**
	       * Text Alignment
	       * @see https://tailwindcss.com/docs/text-align
	       */
	      'text-alignment': [{
	        text: ['left', 'center', 'right', 'justify', 'start', 'end']
	      }],
	      /**
	       * Text Color
	       * @see https://tailwindcss.com/docs/text-color
	       */
	      'text-color': [{
	        text: [colors]
	      }],
	      /**
	       * Text Opacity
	       * @see https://tailwindcss.com/docs/text-opacity
	       */
	      'text-opacity': [{
	        'text-opacity': [opacity]
	      }],
	      /**
	       * Text Decoration
	       * @see https://tailwindcss.com/docs/text-decoration
	       */
	      'text-decoration': ['underline', 'overline', 'line-through', 'no-underline'],
	      /**
	       * Text Decoration Style
	       * @see https://tailwindcss.com/docs/text-decoration-style
	       */
	      'text-decoration-style': [{
	        decoration: [].concat(getLineStyles(), ['wavy'])
	      }],
	      /**
	       * Text Decoration Thickness
	       * @see https://tailwindcss.com/docs/text-decoration-thickness
	       */
	      'text-decoration-thickness': [{
	        decoration: ['auto', 'from-font', isLength]
	      }],
	      /**
	       * Text Underline Offset
	       * @see https://tailwindcss.com/docs/text-underline-offset
	       */
	      'underline-offset': [{
	        'underline-offset': ['auto', isArbitraryValue, isLength]
	      }],
	      /**
	       * Text Decoration Color
	       * @see https://tailwindcss.com/docs/text-decoration-color
	       */
	      'text-decoration-color': [{
	        decoration: [colors]
	      }],
	      /**
	       * Text Transform
	       * @see https://tailwindcss.com/docs/text-transform
	       */
	      'text-transform': ['uppercase', 'lowercase', 'capitalize', 'normal-case'],
	      /**
	       * Text Overflow
	       * @see https://tailwindcss.com/docs/text-overflow
	       */
	      'text-overflow': ['truncate', 'text-ellipsis', 'text-clip'],
	      /**
	       * Text Indent
	       * @see https://tailwindcss.com/docs/text-indent
	       */
	      indent: [{
	        indent: getSpacingWithArbitrary()
	      }],
	      /**
	       * Vertical Alignment
	       * @see https://tailwindcss.com/docs/vertical-align
	       */
	      'vertical-align': [{
	        align: ['baseline', 'top', 'middle', 'bottom', 'text-top', 'text-bottom', 'sub', 'super', isArbitraryValue]
	      }],
	      /**
	       * Whitespace
	       * @see https://tailwindcss.com/docs/whitespace
	       */
	      whitespace: [{
	        whitespace: ['normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'break-spaces']
	      }],
	      /**
	       * Word Break
	       * @see https://tailwindcss.com/docs/word-break
	       */
	      "break": [{
	        "break": ['normal', 'words', 'all', 'keep']
	      }],
	      /**
	       * Hyphens
	       * @see https://tailwindcss.com/docs/hyphens
	       */
	      hyphens: [{
	        hyphens: ['none', 'manual', 'auto']
	      }],
	      /**
	       * Content
	       * @see https://tailwindcss.com/docs/content
	       */
	      content: [{
	        content: ['none', isArbitraryValue]
	      }],
	      // Backgrounds
	      /**
	       * Background Attachment
	       * @see https://tailwindcss.com/docs/background-attachment
	       */
	      'bg-attachment': [{
	        bg: ['fixed', 'local', 'scroll']
	      }],
	      /**
	       * Background Clip
	       * @see https://tailwindcss.com/docs/background-clip
	       */
	      'bg-clip': [{
	        'bg-clip': ['border', 'padding', 'content', 'text']
	      }],
	      /**
	       * Background Opacity
	       * @deprecated since Tailwind CSS v3.0.0
	       * @see https://tailwindcss.com/docs/background-opacity
	       */
	      'bg-opacity': [{
	        'bg-opacity': [opacity]
	      }],
	      /**
	       * Background Origin
	       * @see https://tailwindcss.com/docs/background-origin
	       */
	      'bg-origin': [{
	        'bg-origin': ['border', 'padding', 'content']
	      }],
	      /**
	       * Background Position
	       * @see https://tailwindcss.com/docs/background-position
	       */
	      'bg-position': [{
	        bg: [].concat(getPositions(), [isArbitraryPosition])
	      }],
	      /**
	       * Background Repeat
	       * @see https://tailwindcss.com/docs/background-repeat
	       */
	      'bg-repeat': [{
	        bg: ['no-repeat', {
	          repeat: ['', 'x', 'y', 'round', 'space']
	        }]
	      }],
	      /**
	       * Background Size
	       * @see https://tailwindcss.com/docs/background-size
	       */
	      'bg-size': [{
	        bg: ['auto', 'cover', 'contain', isArbitrarySize]
	      }],
	      /**
	       * Background Image
	       * @see https://tailwindcss.com/docs/background-image
	       */
	      'bg-image': [{
	        bg: ['none', {
	          'gradient-to': ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl']
	        }, isArbitraryUrl]
	      }],
	      /**
	       * Background Color
	       * @see https://tailwindcss.com/docs/background-color
	       */
	      'bg-color': [{
	        bg: [colors]
	      }],
	      /**
	       * Gradient Color Stops From Position
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-from-pos': [{
	        from: [gradientColorStopPositions]
	      }],
	      /**
	       * Gradient Color Stops Via Position
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-via-pos': [{
	        via: [gradientColorStopPositions]
	      }],
	      /**
	       * Gradient Color Stops To Position
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-to-pos': [{
	        to: [gradientColorStopPositions]
	      }],
	      /**
	       * Gradient Color Stops From
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-from': [{
	        from: [gradientColorStops]
	      }],
	      /**
	       * Gradient Color Stops Via
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-via': [{
	        via: [gradientColorStops]
	      }],
	      /**
	       * Gradient Color Stops To
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-to': [{
	        to: [gradientColorStops]
	      }],
	      // Borders
	      /**
	       * Border Radius
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      rounded: [{
	        rounded: [borderRadius]
	      }],
	      /**
	       * Border Radius Start
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-s': [{
	        'rounded-s': [borderRadius]
	      }],
	      /**
	       * Border Radius End
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-e': [{
	        'rounded-e': [borderRadius]
	      }],
	      /**
	       * Border Radius Top
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-t': [{
	        'rounded-t': [borderRadius]
	      }],
	      /**
	       * Border Radius Right
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-r': [{
	        'rounded-r': [borderRadius]
	      }],
	      /**
	       * Border Radius Bottom
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-b': [{
	        'rounded-b': [borderRadius]
	      }],
	      /**
	       * Border Radius Left
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-l': [{
	        'rounded-l': [borderRadius]
	      }],
	      /**
	       * Border Radius Start Start
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-ss': [{
	        'rounded-ss': [borderRadius]
	      }],
	      /**
	       * Border Radius Start End
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-se': [{
	        'rounded-se': [borderRadius]
	      }],
	      /**
	       * Border Radius End End
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-ee': [{
	        'rounded-ee': [borderRadius]
	      }],
	      /**
	       * Border Radius End Start
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-es': [{
	        'rounded-es': [borderRadius]
	      }],
	      /**
	       * Border Radius Top Left
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-tl': [{
	        'rounded-tl': [borderRadius]
	      }],
	      /**
	       * Border Radius Top Right
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-tr': [{
	        'rounded-tr': [borderRadius]
	      }],
	      /**
	       * Border Radius Bottom Right
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-br': [{
	        'rounded-br': [borderRadius]
	      }],
	      /**
	       * Border Radius Bottom Left
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-bl': [{
	        'rounded-bl': [borderRadius]
	      }],
	      /**
	       * Border Width
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w': [{
	        border: [borderWidth]
	      }],
	      /**
	       * Border Width X
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-x': [{
	        'border-x': [borderWidth]
	      }],
	      /**
	       * Border Width Y
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-y': [{
	        'border-y': [borderWidth]
	      }],
	      /**
	       * Border Width Start
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-s': [{
	        'border-s': [borderWidth]
	      }],
	      /**
	       * Border Width End
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-e': [{
	        'border-e': [borderWidth]
	      }],
	      /**
	       * Border Width Top
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-t': [{
	        'border-t': [borderWidth]
	      }],
	      /**
	       * Border Width Right
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-r': [{
	        'border-r': [borderWidth]
	      }],
	      /**
	       * Border Width Bottom
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-b': [{
	        'border-b': [borderWidth]
	      }],
	      /**
	       * Border Width Left
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-l': [{
	        'border-l': [borderWidth]
	      }],
	      /**
	       * Border Opacity
	       * @see https://tailwindcss.com/docs/border-opacity
	       */
	      'border-opacity': [{
	        'border-opacity': [opacity]
	      }],
	      /**
	       * Border Style
	       * @see https://tailwindcss.com/docs/border-style
	       */
	      'border-style': [{
	        border: [].concat(getLineStyles(), ['hidden'])
	      }],
	      /**
	       * Divide Width X
	       * @see https://tailwindcss.com/docs/divide-width
	       */
	      'divide-x': [{
	        'divide-x': [borderWidth]
	      }],
	      /**
	       * Divide Width X Reverse
	       * @see https://tailwindcss.com/docs/divide-width
	       */
	      'divide-x-reverse': ['divide-x-reverse'],
	      /**
	       * Divide Width Y
	       * @see https://tailwindcss.com/docs/divide-width
	       */
	      'divide-y': [{
	        'divide-y': [borderWidth]
	      }],
	      /**
	       * Divide Width Y Reverse
	       * @see https://tailwindcss.com/docs/divide-width
	       */
	      'divide-y-reverse': ['divide-y-reverse'],
	      /**
	       * Divide Opacity
	       * @see https://tailwindcss.com/docs/divide-opacity
	       */
	      'divide-opacity': [{
	        'divide-opacity': [opacity]
	      }],
	      /**
	       * Divide Style
	       * @see https://tailwindcss.com/docs/divide-style
	       */
	      'divide-style': [{
	        divide: getLineStyles()
	      }],
	      /**
	       * Border Color
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color': [{
	        border: [borderColor]
	      }],
	      /**
	       * Border Color X
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-x': [{
	        'border-x': [borderColor]
	      }],
	      /**
	       * Border Color Y
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-y': [{
	        'border-y': [borderColor]
	      }],
	      /**
	       * Border Color Top
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-t': [{
	        'border-t': [borderColor]
	      }],
	      /**
	       * Border Color Right
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-r': [{
	        'border-r': [borderColor]
	      }],
	      /**
	       * Border Color Bottom
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-b': [{
	        'border-b': [borderColor]
	      }],
	      /**
	       * Border Color Left
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-l': [{
	        'border-l': [borderColor]
	      }],
	      /**
	       * Divide Color
	       * @see https://tailwindcss.com/docs/divide-color
	       */
	      'divide-color': [{
	        divide: [borderColor]
	      }],
	      /**
	       * Outline Style
	       * @see https://tailwindcss.com/docs/outline-style
	       */
	      'outline-style': [{
	        outline: [''].concat(getLineStyles())
	      }],
	      /**
	       * Outline Offset
	       * @see https://tailwindcss.com/docs/outline-offset
	       */
	      'outline-offset': [{
	        'outline-offset': [isArbitraryValue, isLength]
	      }],
	      /**
	       * Outline Width
	       * @see https://tailwindcss.com/docs/outline-width
	       */
	      'outline-w': [{
	        outline: [isLength]
	      }],
	      /**
	       * Outline Color
	       * @see https://tailwindcss.com/docs/outline-color
	       */
	      'outline-color': [{
	        outline: [colors]
	      }],
	      /**
	       * Ring Width
	       * @see https://tailwindcss.com/docs/ring-width
	       */
	      'ring-w': [{
	        ring: getLengthWithEmpty()
	      }],
	      /**
	       * Ring Width Inset
	       * @see https://tailwindcss.com/docs/ring-width
	       */
	      'ring-w-inset': ['ring-inset'],
	      /**
	       * Ring Color
	       * @see https://tailwindcss.com/docs/ring-color
	       */
	      'ring-color': [{
	        ring: [colors]
	      }],
	      /**
	       * Ring Opacity
	       * @see https://tailwindcss.com/docs/ring-opacity
	       */
	      'ring-opacity': [{
	        'ring-opacity': [opacity]
	      }],
	      /**
	       * Ring Offset Width
	       * @see https://tailwindcss.com/docs/ring-offset-width
	       */
	      'ring-offset-w': [{
	        'ring-offset': [isLength]
	      }],
	      /**
	       * Ring Offset Color
	       * @see https://tailwindcss.com/docs/ring-offset-color
	       */
	      'ring-offset-color': [{
	        'ring-offset': [colors]
	      }],
	      // Effects
	      /**
	       * Box Shadow
	       * @see https://tailwindcss.com/docs/box-shadow
	       */
	      shadow: [{
	        shadow: ['', 'inner', 'none', isTshirtSize, isArbitraryShadow]
	      }],
	      /**
	       * Box Shadow Color
	       * @see https://tailwindcss.com/docs/box-shadow-color
	       */
	      'shadow-color': [{
	        shadow: [isAny]
	      }],
	      /**
	       * Opacity
	       * @see https://tailwindcss.com/docs/opacity
	       */
	      opacity: [{
	        opacity: [opacity]
	      }],
	      /**
	       * Mix Blend Mode
	       * @see https://tailwindcss.com/docs/mix-blend-mode
	       */
	      'mix-blend': [{
	        'mix-blend': getBlendModes()
	      }],
	      /**
	       * Background Blend Mode
	       * @see https://tailwindcss.com/docs/background-blend-mode
	       */
	      'bg-blend': [{
	        'bg-blend': getBlendModes()
	      }],
	      // Filters
	      /**
	       * Filter
	       * @deprecated since Tailwind CSS v3.0.0
	       * @see https://tailwindcss.com/docs/filter
	       */
	      filter: [{
	        filter: ['', 'none']
	      }],
	      /**
	       * Blur
	       * @see https://tailwindcss.com/docs/blur
	       */
	      blur: [{
	        blur: [blur]
	      }],
	      /**
	       * Brightness
	       * @see https://tailwindcss.com/docs/brightness
	       */
	      brightness: [{
	        brightness: [brightness]
	      }],
	      /**
	       * Contrast
	       * @see https://tailwindcss.com/docs/contrast
	       */
	      contrast: [{
	        contrast: [contrast]
	      }],
	      /**
	       * Drop Shadow
	       * @see https://tailwindcss.com/docs/drop-shadow
	       */
	      'drop-shadow': [{
	        'drop-shadow': ['', 'none', isTshirtSize, isArbitraryValue]
	      }],
	      /**
	       * Grayscale
	       * @see https://tailwindcss.com/docs/grayscale
	       */
	      grayscale: [{
	        grayscale: [grayscale]
	      }],
	      /**
	       * Hue Rotate
	       * @see https://tailwindcss.com/docs/hue-rotate
	       */
	      'hue-rotate': [{
	        'hue-rotate': [hueRotate]
	      }],
	      /**
	       * Invert
	       * @see https://tailwindcss.com/docs/invert
	       */
	      invert: [{
	        invert: [invert]
	      }],
	      /**
	       * Saturate
	       * @see https://tailwindcss.com/docs/saturate
	       */
	      saturate: [{
	        saturate: [saturate]
	      }],
	      /**
	       * Sepia
	       * @see https://tailwindcss.com/docs/sepia
	       */
	      sepia: [{
	        sepia: [sepia]
	      }],
	      /**
	       * Backdrop Filter
	       * @deprecated since Tailwind CSS v3.0.0
	       * @see https://tailwindcss.com/docs/backdrop-filter
	       */
	      'backdrop-filter': [{
	        'backdrop-filter': ['', 'none']
	      }],
	      /**
	       * Backdrop Blur
	       * @see https://tailwindcss.com/docs/backdrop-blur
	       */
	      'backdrop-blur': [{
	        'backdrop-blur': [blur]
	      }],
	      /**
	       * Backdrop Brightness
	       * @see https://tailwindcss.com/docs/backdrop-brightness
	       */
	      'backdrop-brightness': [{
	        'backdrop-brightness': [brightness]
	      }],
	      /**
	       * Backdrop Contrast
	       * @see https://tailwindcss.com/docs/backdrop-contrast
	       */
	      'backdrop-contrast': [{
	        'backdrop-contrast': [contrast]
	      }],
	      /**
	       * Backdrop Grayscale
	       * @see https://tailwindcss.com/docs/backdrop-grayscale
	       */
	      'backdrop-grayscale': [{
	        'backdrop-grayscale': [grayscale]
	      }],
	      /**
	       * Backdrop Hue Rotate
	       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
	       */
	      'backdrop-hue-rotate': [{
	        'backdrop-hue-rotate': [hueRotate]
	      }],
	      /**
	       * Backdrop Invert
	       * @see https://tailwindcss.com/docs/backdrop-invert
	       */
	      'backdrop-invert': [{
	        'backdrop-invert': [invert]
	      }],
	      /**
	       * Backdrop Opacity
	       * @see https://tailwindcss.com/docs/backdrop-opacity
	       */
	      'backdrop-opacity': [{
	        'backdrop-opacity': [opacity]
	      }],
	      /**
	       * Backdrop Saturate
	       * @see https://tailwindcss.com/docs/backdrop-saturate
	       */
	      'backdrop-saturate': [{
	        'backdrop-saturate': [saturate]
	      }],
	      /**
	       * Backdrop Sepia
	       * @see https://tailwindcss.com/docs/backdrop-sepia
	       */
	      'backdrop-sepia': [{
	        'backdrop-sepia': [sepia]
	      }],
	      // Tables
	      /**
	       * Border Collapse
	       * @see https://tailwindcss.com/docs/border-collapse
	       */
	      'border-collapse': [{
	        border: ['collapse', 'separate']
	      }],
	      /**
	       * Border Spacing
	       * @see https://tailwindcss.com/docs/border-spacing
	       */
	      'border-spacing': [{
	        'border-spacing': [borderSpacing]
	      }],
	      /**
	       * Border Spacing X
	       * @see https://tailwindcss.com/docs/border-spacing
	       */
	      'border-spacing-x': [{
	        'border-spacing-x': [borderSpacing]
	      }],
	      /**
	       * Border Spacing Y
	       * @see https://tailwindcss.com/docs/border-spacing
	       */
	      'border-spacing-y': [{
	        'border-spacing-y': [borderSpacing]
	      }],
	      /**
	       * Table Layout
	       * @see https://tailwindcss.com/docs/table-layout
	       */
	      'table-layout': [{
	        table: ['auto', 'fixed']
	      }],
	      /**
	       * Caption Side
	       * @see https://tailwindcss.com/docs/caption-side
	       */
	      caption: [{
	        caption: ['top', 'bottom']
	      }],
	      // Transitions and Animation
	      /**
	       * Tranisition Property
	       * @see https://tailwindcss.com/docs/transition-property
	       */
	      transition: [{
	        transition: ['none', 'all', '', 'colors', 'opacity', 'shadow', 'transform', isArbitraryValue]
	      }],
	      /**
	       * Transition Duration
	       * @see https://tailwindcss.com/docs/transition-duration
	       */
	      duration: [{
	        duration: getNumberAndArbitrary()
	      }],
	      /**
	       * Transition Timing Function
	       * @see https://tailwindcss.com/docs/transition-timing-function
	       */
	      ease: [{
	        ease: ['linear', 'in', 'out', 'in-out', isArbitraryValue]
	      }],
	      /**
	       * Transition Delay
	       * @see https://tailwindcss.com/docs/transition-delay
	       */
	      delay: [{
	        delay: getNumberAndArbitrary()
	      }],
	      /**
	       * Animation
	       * @see https://tailwindcss.com/docs/animation
	       */
	      animate: [{
	        animate: ['none', 'spin', 'ping', 'pulse', 'bounce', isArbitraryValue]
	      }],
	      // Transforms
	      /**
	       * Transform
	       * @see https://tailwindcss.com/docs/transform
	       */
	      transform: [{
	        transform: ['', 'gpu', 'none']
	      }],
	      /**
	       * Scale
	       * @see https://tailwindcss.com/docs/scale
	       */
	      scale: [{
	        scale: [scale]
	      }],
	      /**
	       * Scale X
	       * @see https://tailwindcss.com/docs/scale
	       */
	      'scale-x': [{
	        'scale-x': [scale]
	      }],
	      /**
	       * Scale Y
	       * @see https://tailwindcss.com/docs/scale
	       */
	      'scale-y': [{
	        'scale-y': [scale]
	      }],
	      /**
	       * Rotate
	       * @see https://tailwindcss.com/docs/rotate
	       */
	      rotate: [{
	        rotate: [isInteger, isArbitraryValue]
	      }],
	      /**
	       * Translate X
	       * @see https://tailwindcss.com/docs/translate
	       */
	      'translate-x': [{
	        'translate-x': [translate]
	      }],
	      /**
	       * Translate Y
	       * @see https://tailwindcss.com/docs/translate
	       */
	      'translate-y': [{
	        'translate-y': [translate]
	      }],
	      /**
	       * Skew X
	       * @see https://tailwindcss.com/docs/skew
	       */
	      'skew-x': [{
	        'skew-x': [skew]
	      }],
	      /**
	       * Skew Y
	       * @see https://tailwindcss.com/docs/skew
	       */
	      'skew-y': [{
	        'skew-y': [skew]
	      }],
	      /**
	       * Transform Origin
	       * @see https://tailwindcss.com/docs/transform-origin
	       */
	      'transform-origin': [{
	        origin: ['center', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left', isArbitraryValue]
	      }],
	      // Interactivity
	      /**
	       * Accent Color
	       * @see https://tailwindcss.com/docs/accent-color
	       */
	      accent: [{
	        accent: ['auto', colors]
	      }],
	      /**
	       * Appearance
	       * @see https://tailwindcss.com/docs/appearance
	       */
	      appearance: ['appearance-none'],
	      /**
	       * Cursor
	       * @see https://tailwindcss.com/docs/cursor
	       */
	      cursor: [{
	        cursor: ['auto', 'default', 'pointer', 'wait', 'text', 'move', 'help', 'not-allowed', 'none', 'context-menu', 'progress', 'cell', 'crosshair', 'vertical-text', 'alias', 'copy', 'no-drop', 'grab', 'grabbing', 'all-scroll', 'col-resize', 'row-resize', 'n-resize', 'e-resize', 's-resize', 'w-resize', 'ne-resize', 'nw-resize', 'se-resize', 'sw-resize', 'ew-resize', 'ns-resize', 'nesw-resize', 'nwse-resize', 'zoom-in', 'zoom-out', isArbitraryValue]
	      }],
	      /**
	       * Caret Color
	       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
	       */
	      'caret-color': [{
	        caret: [colors]
	      }],
	      /**
	       * Pointer Events
	       * @see https://tailwindcss.com/docs/pointer-events
	       */
	      'pointer-events': [{
	        'pointer-events': ['none', 'auto']
	      }],
	      /**
	       * Resize
	       * @see https://tailwindcss.com/docs/resize
	       */
	      resize: [{
	        resize: ['none', 'y', 'x', '']
	      }],
	      /**
	       * Scroll Behavior
	       * @see https://tailwindcss.com/docs/scroll-behavior
	       */
	      'scroll-behavior': [{
	        scroll: ['auto', 'smooth']
	      }],
	      /**
	       * Scroll Margin
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-m': [{
	        'scroll-m': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin X
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-mx': [{
	        'scroll-mx': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Y
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-my': [{
	        'scroll-my': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Start
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-ms': [{
	        'scroll-ms': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin End
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-me': [{
	        'scroll-me': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Top
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-mt': [{
	        'scroll-mt': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Right
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-mr': [{
	        'scroll-mr': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Bottom
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-mb': [{
	        'scroll-mb': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Left
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-ml': [{
	        'scroll-ml': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-p': [{
	        'scroll-p': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding X
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-px': [{
	        'scroll-px': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Y
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-py': [{
	        'scroll-py': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Start
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-ps': [{
	        'scroll-ps': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding End
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-pe': [{
	        'scroll-pe': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Top
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-pt': [{
	        'scroll-pt': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Right
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-pr': [{
	        'scroll-pr': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Bottom
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-pb': [{
	        'scroll-pb': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Left
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-pl': [{
	        'scroll-pl': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Snap Align
	       * @see https://tailwindcss.com/docs/scroll-snap-align
	       */
	      'snap-align': [{
	        snap: ['start', 'end', 'center', 'align-none']
	      }],
	      /**
	       * Scroll Snap Stop
	       * @see https://tailwindcss.com/docs/scroll-snap-stop
	       */
	      'snap-stop': [{
	        snap: ['normal', 'always']
	      }],
	      /**
	       * Scroll Snap Type
	       * @see https://tailwindcss.com/docs/scroll-snap-type
	       */
	      'snap-type': [{
	        snap: ['none', 'x', 'y', 'both']
	      }],
	      /**
	       * Scroll Snap Type Strictness
	       * @see https://tailwindcss.com/docs/scroll-snap-type
	       */
	      'snap-strictness': [{
	        snap: ['mandatory', 'proximity']
	      }],
	      /**
	       * Touch Action
	       * @see https://tailwindcss.com/docs/touch-action
	       */
	      touch: [{
	        touch: ['auto', 'none', 'pinch-zoom', 'manipulation', {
	          pan: ['x', 'left', 'right', 'y', 'up', 'down']
	        }]
	      }],
	      /**
	       * User Select
	       * @see https://tailwindcss.com/docs/user-select
	       */
	      select: [{
	        select: ['none', 'text', 'all', 'auto']
	      }],
	      /**
	       * Will Change
	       * @see https://tailwindcss.com/docs/will-change
	       */
	      'will-change': [{
	        'will-change': ['auto', 'scroll', 'contents', 'transform', isArbitraryValue]
	      }],
	      // SVG
	      /**
	       * Fill
	       * @see https://tailwindcss.com/docs/fill
	       */
	      fill: [{
	        fill: [colors, 'none']
	      }],
	      /**
	       * Stroke Width
	       * @see https://tailwindcss.com/docs/stroke-width
	       */
	      'stroke-w': [{
	        stroke: [isLength, isArbitraryNumber]
	      }],
	      /**
	       * Stroke
	       * @see https://tailwindcss.com/docs/stroke
	       */
	      stroke: [{
	        stroke: [colors, 'none']
	      }],
	      // Accessibility
	      /**
	       * Screen Readers
	       * @see https://tailwindcss.com/docs/screen-readers
	       */
	      sr: ['sr-only', 'not-sr-only']
	    },
	    conflictingClassGroups: {
	      overflow: ['overflow-x', 'overflow-y'],
	      overscroll: ['overscroll-x', 'overscroll-y'],
	      inset: ['inset-x', 'inset-y', 'start', 'end', 'top', 'right', 'bottom', 'left'],
	      'inset-x': ['right', 'left'],
	      'inset-y': ['top', 'bottom'],
	      flex: ['basis', 'grow', 'shrink'],
	      gap: ['gap-x', 'gap-y'],
	      p: ['px', 'py', 'ps', 'pe', 'pt', 'pr', 'pb', 'pl'],
	      px: ['pr', 'pl'],
	      py: ['pt', 'pb'],
	      m: ['mx', 'my', 'ms', 'me', 'mt', 'mr', 'mb', 'ml'],
	      mx: ['mr', 'ml'],
	      my: ['mt', 'mb'],
	      'font-size': ['leading'],
	      'fvn-normal': ['fvn-ordinal', 'fvn-slashed-zero', 'fvn-figure', 'fvn-spacing', 'fvn-fraction'],
	      'fvn-ordinal': ['fvn-normal'],
	      'fvn-slashed-zero': ['fvn-normal'],
	      'fvn-figure': ['fvn-normal'],
	      'fvn-spacing': ['fvn-normal'],
	      'fvn-fraction': ['fvn-normal'],
	      rounded: ['rounded-s', 'rounded-e', 'rounded-t', 'rounded-r', 'rounded-b', 'rounded-l', 'rounded-ss', 'rounded-se', 'rounded-ee', 'rounded-es', 'rounded-tl', 'rounded-tr', 'rounded-br', 'rounded-bl'],
	      'rounded-s': ['rounded-ss', 'rounded-es'],
	      'rounded-e': ['rounded-se', 'rounded-ee'],
	      'rounded-t': ['rounded-tl', 'rounded-tr'],
	      'rounded-r': ['rounded-tr', 'rounded-br'],
	      'rounded-b': ['rounded-br', 'rounded-bl'],
	      'rounded-l': ['rounded-tl', 'rounded-bl'],
	      'border-spacing': ['border-spacing-x', 'border-spacing-y'],
	      'border-w': ['border-w-s', 'border-w-e', 'border-w-t', 'border-w-r', 'border-w-b', 'border-w-l'],
	      'border-w-x': ['border-w-r', 'border-w-l'],
	      'border-w-y': ['border-w-t', 'border-w-b'],
	      'border-color': ['border-color-t', 'border-color-r', 'border-color-b', 'border-color-l'],
	      'border-color-x': ['border-color-r', 'border-color-l'],
	      'border-color-y': ['border-color-t', 'border-color-b'],
	      'scroll-m': ['scroll-mx', 'scroll-my', 'scroll-ms', 'scroll-me', 'scroll-mt', 'scroll-mr', 'scroll-mb', 'scroll-ml'],
	      'scroll-mx': ['scroll-mr', 'scroll-ml'],
	      'scroll-my': ['scroll-mt', 'scroll-mb'],
	      'scroll-p': ['scroll-px', 'scroll-py', 'scroll-ps', 'scroll-pe', 'scroll-pt', 'scroll-pr', 'scroll-pb', 'scroll-pl'],
	      'scroll-px': ['scroll-pr', 'scroll-pl'],
	      'scroll-py': ['scroll-pt', 'scroll-pb']
	    },
	    conflictingClassGroupModifiers: {
	      'font-size': ['leading']
	    }
	  };
	}

	/**
	 * @param baseConfig Config where other config will be merged into. This object will be mutated.
	 * @param configExtension Partial config to merge into the `baseConfig`.
	 */
	function mergeConfigs(baseConfig, configExtension) {
	  for (var key in configExtension) {
	    mergePropertyRecursively(baseConfig, key, configExtension[key]);
	  }
	  return baseConfig;
	}
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var overrideTypes = /*#__PURE__*/new Set(['string', 'number', 'boolean']);
	function mergePropertyRecursively(baseObject, mergeKey, mergeValue) {
	  if (!hasOwnProperty.call(baseObject, mergeKey) || overrideTypes.has(typeof mergeValue) || mergeValue === null) {
	    baseObject[mergeKey] = mergeValue;
	    return;
	  }
	  if (Array.isArray(mergeValue) && Array.isArray(baseObject[mergeKey])) {
	    baseObject[mergeKey] = baseObject[mergeKey].concat(mergeValue);
	    return;
	  }
	  if (typeof mergeValue === 'object' && typeof baseObject[mergeKey] === 'object') {
	    if (baseObject[mergeKey] === null) {
	      baseObject[mergeKey] = mergeValue;
	      return;
	    }
	    for (var nextKey in mergeValue) {
	      mergePropertyRecursively(baseObject[mergeKey], nextKey, mergeValue[nextKey]);
	    }
	  }
	}

	function extendTailwindMerge(configExtension) {
	  for (var _len = arguments.length, createConfig = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    createConfig[_key - 1] = arguments[_key];
	  }
	  return typeof configExtension === 'function' ? createTailwindMerge.apply(void 0, [getDefaultConfig, configExtension].concat(createConfig)) : createTailwindMerge.apply(void 0, [function () {
	    return mergeConfigs(getDefaultConfig(), configExtension);
	  }].concat(createConfig));
	}

	var twMerge = /*#__PURE__*/createTailwindMerge(getDefaultConfig);

	var se={twMerge:!0,twMergeConfig:{},responsiveVariants:!1},_=s=>s||void 0,N=(...s)=>_(y(s).filter(Boolean).join(" ")),q=null,M={},F=!1,w=(...s)=>b$1=>b$1.twMerge?((!q||F)&&(F=!1,q=u(M)?twMerge:extendTailwindMerge(M)),_(q(N(s)))):N(s),Z=(s,b)=>{for(let e in b)s.hasOwnProperty(e)?s[e]=N(s[e],b[e]):s[e]=b[e];return s},ie=(s,b$1)=>{let{extend:e=null,slots:j={},variants:U={},compoundVariants:C=[],compoundSlots:V=[],defaultVariants:W={}}=s,m={...se,...b$1},S=e!=null&&e.base?N(e.base,s==null?void 0:s.base):s==null?void 0:s.base,g$1$1=e!=null&&e.variants&&!u(e.variants)?p$1(U,e.variants):U,A=e!=null&&e.defaultVariants&&!u(e.defaultVariants)?{...e.defaultVariants,...W}:W;!u(m.twMergeConfig)&&!x(m.twMergeConfig,M)&&(F=!0,M=m.twMergeConfig);let O=u(e==null?void 0:e.slots),$=u(j)?{}:{base:N(s==null?void 0:s.base,O&&(e==null?void 0:e.base)),...j},h$1=O?$:Z({...e==null?void 0:e.slots},u($)?{base:s==null?void 0:s.base}:$),v=l$1=>{if(u(g$1$1)&&u(j)&&O)return w(S,l$1==null?void 0:l$1.class,l$1==null?void 0:l$1.className)(m);if(C&&!Array.isArray(C))throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof C}`);if(V&&!Array.isArray(V))throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof V}`);let K=(t,n,a=[],i)=>{let r=a;if(typeof n=="string")r=r.concat(g$1(n).split(" ").map(c=>`${t}:${c}`));else if(Array.isArray(n))r=r.concat(n.reduce((c,f)=>c.concat(`${t}:${f}`),[]));else if(typeof n=="object"&&typeof i=="string"){for(let c in n)if(n.hasOwnProperty(c)&&c===i){let f=n[c];if(f&&typeof f=="string"){let o=g$1(f);r[i]?r[i]=r[i].concat(o.split(" ").map(u=>`${t}:${u}`)):r[i]=o.split(" ").map(u=>`${t}:${u}`);}else Array.isArray(f)&&f.length>0&&(r[i]=f.reduce((o,u)=>o.concat(`${t}:${u}`),[]));}}return r},z=(t,n=g$1$1,a$1=null,i=null)=>{var J;let r=n[t];if(!r||u(r))return null;let c=(J=i==null?void 0:i[t])!=null?J:l$1==null?void 0:l$1[t];if(c===null)return null;let f=l(c),o=Array.isArray(m.responsiveVariants)&&m.responsiveVariants.length>0||m.responsiveVariants===!0,u$1=A==null?void 0:A[t],d=[];if(typeof f=="object"&&o)for(let[k,L]of Object.entries(f)){let ae=r[L];if(k==="initial"){u$1=L;continue}Array.isArray(m.responsiveVariants)&&!m.responsiveVariants.includes(k)||(d=K(k,ae,d,a$1));}let T=r[f]||r[l(u$1)];return typeof d=="object"&&typeof a$1=="string"&&d[a$1]?Z(d,T):d.length>0?(d.push(T),d):T},P=()=>g$1$1?Object.keys(g$1$1).map(t=>z(t,g$1$1)):null,p=(t,n)=>{if(!g$1$1||typeof g$1$1!="object")return null;let a=new Array;for(let i in g$1$1){let r=z(i,g$1$1,t,n),c=t==="base"&&typeof r=="string"?r:r&&r[t];c&&(a[a.length]=c);}return a},D={};for(let t in l$1)l$1[t]!==void 0&&(D[t]=l$1[t]);let G=(t,n)=>{var i;let a=typeof(l$1==null?void 0:l$1[t])=="object"?{[t]:(i=l$1[t])==null?void 0:i.initial}:{};return {...A,...D,...a,...n}},H=(t=[],n)=>{let a=[];for(let{class:i,className:r,...c}of t){let f=!0;for(let[o,u]of Object.entries(c)){let d=G(o,n);if(Array.isArray(u)){if(!u.includes(d[o])){f=!1;break}}else if(d[o]!==u){f=!1;break}}f&&(i&&a.push(i),r&&a.push(r));}return a},I=t=>{let n=H(C,t),a=H(e==null?void 0:e.compoundVariants,t);return a$1(a,n)},ee=t=>{let n=I(t);if(!Array.isArray(n))return n;let a={};for(let i of n)if(typeof i=="string"&&(a.base=w(a.base,i)(m)),typeof i=="object")for(let[r,c]of Object.entries(i))a[r]=w(a[r],c)(m);return a},te=t=>{if(V.length<1)return null;let n={};for(let{slots:a=[],class:i,className:r,...c}of V){if(!u(c)){let f=!0;for(let o of Object.keys(c)){let u=G(o,t)[o];if(u===void 0||(Array.isArray(c[o])?!c[o].includes(u):c[o]!==u)){f=!1;break}}if(!f)continue}for(let f of a)n[f]=n[f]||[],n[f].push([i,r]);}return n};if(!u(j)||!O){let t={};if(typeof h$1=="object"&&!u(h$1))for(let n of Object.keys(h$1))t[n]=a=>{var i,r;return w(h$1[n],p(n,a),((i=ee(a))!=null?i:[])[n],((r=te(a))!=null?r:[])[n],a==null?void 0:a.class,a==null?void 0:a.className)(m)};return t}return w(S,P(),I(),l$1==null?void 0:l$1.class,l$1==null?void 0:l$1.className)(m)},x$1=()=>{if(!(!g$1$1||typeof g$1$1!="object"))return Object.keys(g$1$1)};return v.variantKeys=x$1(),v.extend=e,v.base=S,v.slots=h$1,v.variants=g$1$1,v.defaultVariants=A,v.compoundSlots=V,v.compoundVariants=C,v};

	const toggleVariants = ie({
	    base: "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
	    variants: {
	        variant: {
	            default: "bg-transparent",
	            outline: "border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground",
	        },
	        size: {
	            default: "h-9 px-3",
	            sm: "h-8 px-2",
	            lg: "h-10 px-3",
	        },
	    },
	    defaultVariants: {
	        variant: "default",
	        size: "default",
	    },
	});

	/* src/lib/components/ui/toggle-group/toggle-group-item.svelte generated by Svelte v4.2.10 */

	// (13:0) <ToggleGroupPrimitive.Item  class={cn(   toggleVariants({    variant: ctx.variant || variant,    size: ctx.size || size,   }),   className  )}  {value}  {...$$restProps} >
	function create_default_slot$5(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[6].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[7],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$5.name,
			type: "slot",
			source: "(13:0) <ToggleGroupPrimitive.Item  class={cn(   toggleVariants({    variant: ctx.variant || variant,    size: ctx.size || size,   }),   className  )}  {value}  {...$$restProps} >",
			ctx
		});

		return block;
	}

	function create_fragment$b(ctx) {
		let togglegroupprimitive_item;
		let current;

		const togglegroupprimitive_item_spread_levels = [
			{
				class: cn(
					toggleVariants({
						variant: /*ctx*/ ctx[4].variant || /*variant*/ ctx[1],
						size: /*ctx*/ ctx[4].size || /*size*/ ctx[2]
					}),
					/*className*/ ctx[0]
				)
			},
			{ value: /*value*/ ctx[3] },
			/*$$restProps*/ ctx[5]
		];

		let togglegroupprimitive_item_props = {
			$$slots: { default: [create_default_slot$5] },
			$$scope: { ctx }
		};

		for (let i = 0; i < togglegroupprimitive_item_spread_levels.length; i += 1) {
			togglegroupprimitive_item_props = assign(togglegroupprimitive_item_props, togglegroupprimitive_item_spread_levels[i]);
		}

		togglegroupprimitive_item = new Toggle_group_item$1({
				props: togglegroupprimitive_item_props,
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(togglegroupprimitive_item.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(togglegroupprimitive_item, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const togglegroupprimitive_item_changes = (dirty & /*ctx, variant, size, className, value, $$restProps*/ 63)
				? get_spread_update(togglegroupprimitive_item_spread_levels, [
						dirty & /*ctx, variant, size, className*/ 23 && {
							class: cn(
								toggleVariants({
									variant: /*ctx*/ ctx[4].variant || /*variant*/ ctx[1],
									size: /*ctx*/ ctx[4].size || /*size*/ ctx[2]
								}),
								/*className*/ ctx[0]
							)
						},
						dirty & /*value*/ 8 && { value: /*value*/ ctx[3] },
						dirty & /*$$restProps*/ 32 && get_spread_object(/*$$restProps*/ ctx[5])
					])
				: {};

				if (dirty & /*$$scope*/ 128) {
					togglegroupprimitive_item_changes.$$scope = { dirty, ctx };
				}

				togglegroupprimitive_item.$set(togglegroupprimitive_item_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(togglegroupprimitive_item.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(togglegroupprimitive_item.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(togglegroupprimitive_item, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$b.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$b($$self, $$props, $$invalidate) {
		const omit_props_names = ["class","variant","size","value"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Toggle_group_item', slots, ['default']);
		let { class: className = undefined } = $$props;
		let { variant = "default" } = $$props;
		let { size = "default" } = $$props;
		let { value } = $$props;
		const ctx = getToggleGroupCtx();

		$$self.$$.on_mount.push(function () {
			if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
				console.warn("<Toggle_group_item> was created without expected prop 'value'");
			}
		});

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
			if ('variant' in $$new_props) $$invalidate(1, variant = $$new_props.variant);
			if ('size' in $$new_props) $$invalidate(2, size = $$new_props.size);
			if ('value' in $$new_props) $$invalidate(3, value = $$new_props.value);
			if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			ToggleGroupPrimitive,
			cn,
			getToggleGroupCtx,
			toggleVariants,
			className,
			variant,
			size,
			value,
			ctx
		});

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
			if ('variant' in $$props) $$invalidate(1, variant = $$new_props.variant);
			if ('size' in $$props) $$invalidate(2, size = $$new_props.size);
			if ('value' in $$props) $$invalidate(3, value = $$new_props.value);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [className, variant, size, value, ctx, $$restProps, slots, $$scope];
	}

	class Toggle_group_item extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$b, create_fragment$b, safe_not_equal, { class: 0, variant: 1, size: 2, value: 3 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Toggle_group_item",
				options,
				id: create_fragment$b.name
			});
		}

		get class() {
			throw new Error("<Toggle_group_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Toggle_group_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get variant() {
			throw new Error("<Toggle_group_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set variant(value) {
			throw new Error("<Toggle_group_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get size() {
			throw new Error("<Toggle_group_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set size(value) {
			throw new Error("<Toggle_group_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get value() {
			throw new Error("<Toggle_group_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set value(value) {
			throw new Error("<Toggle_group_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	function setToggleGroupCtx(props) {
	    setContext("toggleGroup", props);
	}
	function getToggleGroupCtx() {
	    return getContext("toggleGroup");
	}

	var ToggleGroup = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Item: Toggle_group_item,
		Root: Toggle_group,
		ToggleGroup: Toggle_group,
		ToggleGroupItem: Toggle_group_item,
		getToggleGroupCtx: getToggleGroupCtx,
		setToggleGroupCtx: setToggleGroupCtx
	});

	/* src/lib/components/editor/inputs/SelectInput.svelte generated by Svelte v4.2.10 */
	const file$9 = "src/lib/components/editor/inputs/SelectInput.svelte";

	function get_each_context$3(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[4] = list[i];
		return child_ctx;
	}

	// (6:0) {#if elementStyle}
	function create_if_block$5(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_1$4, create_else_block$3];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*elementStyle*/ ctx[0].key === "textAlign") return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$5.name,
			type: "if",
			source: "(6:0) {#if elementStyle}",
			ctx
		});

		return block;
	}

	// (83:2) {:else}
	function create_else_block$3(ctx) {
		let select;
		let show_if = !/*elementStyle*/ ctx[0].options.includes(/*elementStyle*/ ctx[0].value);
		let if_block_anchor;
		let select_name_value;
		let select_value_value;
		let mounted;
		let dispose;
		let if_block = show_if && create_if_block_2$1(ctx);
		let each_value = ensure_array_like_dev(/*elementStyle*/ ctx[0].options ?? []);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
		}

		const block = {
			c: function create() {
				select = element("select");
				if (if_block) if_block.c();
				if_block_anchor = empty();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(select, "name", select_name_value = /*elementStyle*/ ctx[0].displayName);
				attr_dev(select, "class", "border-none text-xs text-text bg-background appearance-none text-end focus:outline-none focus:ring-0 capitalize");
				add_location(select, file$9, 86, 4, 2727);
			},
			m: function mount(target, anchor) {
				insert_dev(target, select, anchor);
				if (if_block) if_block.m(select, null);
				append_dev(select, if_block_anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(select, null);
					}
				}

				select_option(select, /*elementStyle*/ ctx[0].value);

				if (!mounted) {
					dispose = listen_dev(select, "input", /*input_handler*/ ctx[3], false, false, false, false);
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (dirty & /*elementStyle*/ 1) show_if = !/*elementStyle*/ ctx[0].options.includes(/*elementStyle*/ ctx[0].value);

				if (show_if) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_2$1(ctx);
						if_block.c();
						if_block.m(select, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (dirty & /*elementStyle*/ 1) {
					each_value = ensure_array_like_dev(/*elementStyle*/ ctx[0].options ?? []);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$3(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$3(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(select, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}

				if (dirty & /*elementStyle*/ 1 && select_name_value !== (select_name_value = /*elementStyle*/ ctx[0].displayName)) {
					attr_dev(select, "name", select_name_value);
				}

				if (dirty & /*elementStyle*/ 1 && select_value_value !== (select_value_value = /*elementStyle*/ ctx[0].value)) {
					select_option(select, /*elementStyle*/ ctx[0].value);
				}
			},
			i: noop$3,
			o: noop$3,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(select);
				}

				if (if_block) if_block.d();
				destroy_each(each_blocks, detaching);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$3.name,
			type: "else",
			source: "(83:2) {:else}",
			ctx
		});

		return block;
	}

	// (7:2) {#if elementStyle.key === "textAlign"}
	function create_if_block_1$4(ctx) {
		let togglegroup_root;
		let current;

		togglegroup_root = new Toggle_group({
				props: {
					type: "single",
					value: /*elementStyle*/ ctx[0].value,
					onValueChange: /*func*/ ctx[2],
					$$slots: { default: [create_default_slot$4] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(togglegroup_root.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(togglegroup_root, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const togglegroup_root_changes = {};
				if (dirty & /*elementStyle*/ 1) togglegroup_root_changes.value = /*elementStyle*/ ctx[0].value;
				if (dirty & /*updateElementStyle, elementStyle*/ 3) togglegroup_root_changes.onValueChange = /*func*/ ctx[2];

				if (dirty & /*$$scope*/ 128) {
					togglegroup_root_changes.$$scope = { dirty, ctx };
				}

				togglegroup_root.$set(togglegroup_root_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(togglegroup_root.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(togglegroup_root.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(togglegroup_root, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$4.name,
			type: "if",
			source: "(7:2) {#if elementStyle.key === \\\"textAlign\\\"}",
			ctx
		});

		return block;
	}

	// (92:6) {#if !elementStyle.options.includes(elementStyle.value)}
	function create_if_block_2$1(ctx) {
		let option_1;
		let t_value = /*elementStyle*/ ctx[0].value + "";
		let t;
		let option_1_value_value;

		const block = {
			c: function create() {
				option_1 = element("option");
				t = text(t_value);
				option_1.__value = option_1_value_value = /*elementStyle*/ ctx[0].value;
				set_input_value(option_1, option_1.__value);
				add_location(option_1, file$9, 95, 8, 3113);
			},
			m: function mount(target, anchor) {
				insert_dev(target, option_1, anchor);
				append_dev(option_1, t);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*elementStyle*/ 1 && t_value !== (t_value = /*elementStyle*/ ctx[0].value + "")) set_data_dev(t, t_value);

				if (dirty & /*elementStyle*/ 1 && option_1_value_value !== (option_1_value_value = /*elementStyle*/ ctx[0].value)) {
					prop_dev(option_1, "__value", option_1_value_value);
					set_input_value(option_1, option_1.__value);
				}
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(option_1);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$1.name,
			type: "if",
			source: "(92:6) {#if !elementStyle.options.includes(elementStyle.value)}",
			ctx
		});

		return block;
	}

	// (95:6) {#each elementStyle.options ?? [] as option}
	function create_each_block$3(ctx) {
		let option_1;
		let t_value = /*option*/ ctx[4] + "";
		let t;
		let option_1_value_value;

		const block = {
			c: function create() {
				option_1 = element("option");
				t = text(t_value);
				option_1.__value = option_1_value_value = /*option*/ ctx[4];
				set_input_value(option_1, option_1.__value);
				add_location(option_1, file$9, 98, 8, 3249);
			},
			m: function mount(target, anchor) {
				insert_dev(target, option_1, anchor);
				append_dev(option_1, t);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*elementStyle*/ 1 && t_value !== (t_value = /*option*/ ctx[4] + "")) set_data_dev(t, t_value);

				if (dirty & /*elementStyle*/ 1 && option_1_value_value !== (option_1_value_value = /*option*/ ctx[4])) {
					prop_dev(option_1, "__value", option_1_value_value);
					set_input_value(option_1, option_1.__value);
				}
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(option_1);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$3.name,
			type: "each",
			source: "(95:6) {#each elementStyle.options ?? [] as option}",
			ctx
		});

		return block;
	}

	// (19:6) <ToggleGroup.Item class="px-1.5" value="start"         >
	function create_default_slot_3$3(ctx) {
		let svg;
		let g;
		let path;
		let defs;
		let clipPath;
		let rect;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				g = svg_element("g");
				path = svg_element("path");
				defs = svg_element("defs");
				clipPath = svg_element("clipPath");
				rect = svg_element("rect");
				attr_dev(path, "d", "M12.5 12.5H2.5V14.1667H12.5V12.5ZM12.5 5.83333H2.5V7.5H12.5V5.83333ZM2.5 10.8333H17.5V9.16667H2.5V10.8333ZM2.5 17.5H17.5V15.8333H2.5V17.5ZM2.5 2.5V4.16667H17.5V2.5H2.5Z");
				attr_dev(path, "fill", "white");
				add_location(path, file$9, 30, 12, 765);
				attr_dev(g, "clip-path", "url(#clip0_134_5601)");
				add_location(g, file$9, 29, 10, 716);
				attr_dev(rect, "width", "20");
				attr_dev(rect, "height", "20");
				attr_dev(rect, "fill", "white");
				add_location(rect, file$9, 37, 14, 1089);
				attr_dev(clipPath, "id", "clip0_134_5601");
				add_location(clipPath, file$9, 36, 12, 1044);
				add_location(defs, file$9, 35, 10, 1025);
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 20 20");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$9, 22, 9, 551);
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, g);
				append_dev(g, path);
				append_dev(svg, defs);
				append_dev(defs, clipPath);
				append_dev(clipPath, rect);
			},
			p: noop$3,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_3$3.name,
			type: "slot",
			source: "(19:6) <ToggleGroup.Item class=\\\"px-1.5\\\" value=\\\"start\\\"         >",
			ctx
		});

		return block;
	}

	// (40:6) <ToggleGroup.Item value="center" class="px-1.5"         >
	function create_default_slot_2$3(ctx) {
		let svg;
		let g;
		let path;
		let defs;
		let clipPath;
		let rect;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				g = svg_element("g");
				path = svg_element("path");
				defs = svg_element("defs");
				clipPath = svg_element("clipPath");
				rect = svg_element("rect");
				attr_dev(path, "d", "M5.83333 12.5V14.1667H14.1667V12.5H5.83333ZM2.5 17.5H17.5V15.8333H2.5V17.5ZM2.5 10.8333H17.5V9.16667H2.5V10.8333ZM5.83333 5.83333V7.5H14.1667V5.83333H5.83333ZM2.5 2.5V4.16667H17.5V2.5H2.5Z");
				attr_dev(path, "fill", "white");
				add_location(path, file$9, 51, 12, 1494);
				attr_dev(g, "clip-path", "url(#clip0_134_5604)");
				add_location(g, file$9, 50, 10, 1445);
				attr_dev(rect, "width", "20");
				attr_dev(rect, "height", "20");
				attr_dev(rect, "fill", "white");
				add_location(rect, file$9, 58, 14, 1838);
				attr_dev(clipPath, "id", "clip0_134_5604");
				add_location(clipPath, file$9, 57, 12, 1793);
				add_location(defs, file$9, 56, 10, 1774);
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 20 20");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$9, 43, 9, 1280);
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, g);
				append_dev(g, path);
				append_dev(svg, defs);
				append_dev(defs, clipPath);
				append_dev(clipPath, rect);
			},
			p: noop$3,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_2$3.name,
			type: "slot",
			source: "(40:6) <ToggleGroup.Item value=\\\"center\\\" class=\\\"px-1.5\\\"         >",
			ctx
		});

		return block;
	}

	// (61:6) <ToggleGroup.Item value="end" class="px-1.5"         >
	function create_default_slot_1$3(ctx) {
		let svg;
		let g;
		let path;
		let defs;
		let clipPath;
		let rect;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				g = svg_element("g");
				path = svg_element("path");
				defs = svg_element("defs");
				clipPath = svg_element("clipPath");
				rect = svg_element("rect");
				attr_dev(path, "d", "M2.5 17.5H17.5V15.8333H2.5V17.5ZM7.5 14.1667H17.5V12.5H7.5V14.1667ZM2.5 10.8333H17.5V9.16667H2.5V10.8333ZM7.5 7.5H17.5V5.83333H7.5V7.5ZM2.5 2.5V4.16667H17.5V2.5H2.5Z");
				attr_dev(path, "fill", "white");
				add_location(path, file$9, 72, 12, 2240);
				attr_dev(g, "clip-path", "url(#clip0_134_5607)");
				add_location(g, file$9, 71, 10, 2191);
				attr_dev(rect, "width", "20");
				attr_dev(rect, "height", "20");
				attr_dev(rect, "fill", "white");
				add_location(rect, file$9, 79, 14, 2561);
				attr_dev(clipPath, "id", "clip0_134_5607");
				add_location(clipPath, file$9, 78, 12, 2516);
				add_location(defs, file$9, 77, 10, 2497);
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 20 20");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$9, 64, 9, 2026);
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, g);
				append_dev(g, path);
				append_dev(svg, defs);
				append_dev(defs, clipPath);
				append_dev(clipPath, rect);
			},
			p: noop$3,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_1$3.name,
			type: "slot",
			source: "(61:6) <ToggleGroup.Item value=\\\"end\\\" class=\\\"px-1.5\\\"         >",
			ctx
		});

		return block;
	}

	// (8:4) <ToggleGroup.Root       type="single"       value={elementStyle.value}       onValueChange={(val) => {         if (!val) {           updateElementStyle(elementStyle.key, "inherit");           return;         }         updateElementStyle(elementStyle.key, val);       }}     >
	function create_default_slot$4(ctx) {
		let togglegroup_item0;
		let t0;
		let togglegroup_item1;
		let t1;
		let togglegroup_item2;
		let current;

		togglegroup_item0 = new Toggle_group_item({
				props: {
					class: "px-1.5",
					value: "start",
					$$slots: { default: [create_default_slot_3$3] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		togglegroup_item1 = new Toggle_group_item({
				props: {
					value: "center",
					class: "px-1.5",
					$$slots: { default: [create_default_slot_2$3] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		togglegroup_item2 = new Toggle_group_item({
				props: {
					value: "end",
					class: "px-1.5",
					$$slots: { default: [create_default_slot_1$3] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(togglegroup_item0.$$.fragment);
				t0 = space();
				create_component(togglegroup_item1.$$.fragment);
				t1 = space();
				create_component(togglegroup_item2.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(togglegroup_item0, target, anchor);
				insert_dev(target, t0, anchor);
				mount_component(togglegroup_item1, target, anchor);
				insert_dev(target, t1, anchor);
				mount_component(togglegroup_item2, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const togglegroup_item0_changes = {};

				if (dirty & /*$$scope*/ 128) {
					togglegroup_item0_changes.$$scope = { dirty, ctx };
				}

				togglegroup_item0.$set(togglegroup_item0_changes);
				const togglegroup_item1_changes = {};

				if (dirty & /*$$scope*/ 128) {
					togglegroup_item1_changes.$$scope = { dirty, ctx };
				}

				togglegroup_item1.$set(togglegroup_item1_changes);
				const togglegroup_item2_changes = {};

				if (dirty & /*$$scope*/ 128) {
					togglegroup_item2_changes.$$scope = { dirty, ctx };
				}

				togglegroup_item2.$set(togglegroup_item2_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(togglegroup_item0.$$.fragment, local);
				transition_in(togglegroup_item1.$$.fragment, local);
				transition_in(togglegroup_item2.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(togglegroup_item0.$$.fragment, local);
				transition_out(togglegroup_item1.$$.fragment, local);
				transition_out(togglegroup_item2.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t0);
					detach_dev(t1);
				}

				destroy_component(togglegroup_item0, detaching);
				destroy_component(togglegroup_item1, detaching);
				destroy_component(togglegroup_item2, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$4.name,
			type: "slot",
			source: "(8:4) <ToggleGroup.Root       type=\\\"single\\\"       value={elementStyle.value}       onValueChange={(val) => {         if (!val) {           updateElementStyle(elementStyle.key, \\\"inherit\\\");           return;         }         updateElementStyle(elementStyle.key, val);       }}     >",
			ctx
		});

		return block;
	}

	function create_fragment$a(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*elementStyle*/ ctx[0] && create_if_block$5(ctx);

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (/*elementStyle*/ ctx[0]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*elementStyle*/ 1) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$5(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$a.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$a($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('SelectInput', slots, []);
		let { elementStyle } = $$props;
		let { updateElementStyle } = $$props;

		$$self.$$.on_mount.push(function () {
			if (elementStyle === undefined && !('elementStyle' in $$props || $$self.$$.bound[$$self.$$.props['elementStyle']])) {
				console.warn("<SelectInput> was created without expected prop 'elementStyle'");
			}

			if (updateElementStyle === undefined && !('updateElementStyle' in $$props || $$self.$$.bound[$$self.$$.props['updateElementStyle']])) {
				console.warn("<SelectInput> was created without expected prop 'updateElementStyle'");
			}
		});

		const writable_props = ['elementStyle', 'updateElementStyle'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SelectInput> was created with unknown prop '${key}'`);
		});

		const func = val => {
			if (!val) {
				updateElementStyle(elementStyle.key, "inherit");
				return;
			}

			updateElementStyle(elementStyle.key, val);
		};

		const input_handler = event => {
			updateElementStyle(elementStyle.key, event.target.value);
		};

		$$self.$$set = $$props => {
			if ('elementStyle' in $$props) $$invalidate(0, elementStyle = $$props.elementStyle);
			if ('updateElementStyle' in $$props) $$invalidate(1, updateElementStyle = $$props.updateElementStyle);
		};

		$$self.$capture_state = () => ({
			ToggleGroup,
			elementStyle,
			updateElementStyle
		});

		$$self.$inject_state = $$props => {
			if ('elementStyle' in $$props) $$invalidate(0, elementStyle = $$props.elementStyle);
			if ('updateElementStyle' in $$props) $$invalidate(1, updateElementStyle = $$props.updateElementStyle);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [elementStyle, updateElementStyle, func, input_handler];
	}

	class SelectInput extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$a, create_fragment$a, safe_not_equal, { elementStyle: 0, updateElementStyle: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "SelectInput",
				options,
				id: create_fragment$a.name
			});
		}

		get elementStyle() {
			throw new Error("<SelectInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set elementStyle(value) {
			throw new Error("<SelectInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get updateElementStyle() {
			throw new Error("<SelectInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set updateElementStyle(value) {
			throw new Error("<SelectInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	// A is m x n. B is n x p. product is m x p.
	function multiplyMatrices (A, B) {
		let m = A.length;

		if (!Array.isArray(A[0])) {
			// A is vector, convert to [[a, b, c, ...]]
			A = [A];
		}

		if (!Array.isArray(B[0])) {
			// B is vector, convert to [[a], [b], [c], ...]]
			B = B.map(x => [x]);
		}

		let p = B[0].length;
		let B_cols = B[0].map((_, i) => B.map(x => x[i])); // transpose B
		let product = A.map(row => B_cols.map(col => {
			let ret = 0;

			if (!Array.isArray(row)) {
				for (let c of col) {
					ret += row * c;
				}

				return ret;
			}

			for (let i=0; i < row.length; i++) {
				ret += row[i] * (col[i] || 0);
			}

			return ret;
		}));

		if (m === 1) {
			product = product[0]; // Avoid [[a, b, c, ...]]
		}

		if (p === 1) {
			return product.map(x => x[0]); // Avoid [[a], [b], [c], ...]]
		}

		return product;
	}

	/**
	 * Various utility functions
	 */


	/**
	 * Check if a value is a string (including a String object)
	 * @param {*} str - Value to check
	 * @returns {boolean}
	 */
	function isString (str) {
		return type(str) === "string";
	}

	/**
	 * Determine the internal JavaScript [[Class]] of an object.
	 * @param {*} o - Value to check
	 * @returns {string}
	 */
	function type (o) {
		let str = Object.prototype.toString.call(o);

		return (str.match(/^\[object\s+(.*?)\]$/)[1] || "").toLowerCase();
	}

	/**
	 * Round a number to a certain number of significant digits
	 * @param {number} n - The number to round
	 * @param {number} precision - Number of significant digits
	 */
	function toPrecision (n, precision) {
		n = +n;
		precision = +precision;
		let integerLength = (Math.floor(n) + "").length;

		if (precision > integerLength) {
			return +n.toFixed(precision - integerLength);
		}
		else {
			let p10 = 10 ** (integerLength - precision);
			return Math.round(n / p10) * p10;
		}
	}

	/**
	* Parse a CSS function, regardless of its name and arguments
	* @param String str String to parse
	* @return {{name, args, rawArgs}}
	*/
	function parseFunction (str) {
		if (!str) {
			return;
		}

		str = str.trim();

		const isFunctionRegex = /^([a-z]+)\((.+?)\)$/i;
		const isNumberRegex = /^-?[\d.]+$/;
		let parts = str.match(isFunctionRegex);

		if (parts) {
			// It is a function, parse args
			let args = [];
			parts[2].replace(/\/?\s*([-\w.]+(?:%|deg)?)/g, ($0, arg) => {
				if (/%$/.test(arg)) {
					// Convert percentages to 0-1 numbers
					arg = new Number(arg.slice(0, -1) / 100);
					arg.type = "<percentage>";
				}
				else if (/deg$/.test(arg)) {
					// Drop deg from degrees and convert to number
					// TODO handle other units too
					arg = new Number(+arg.slice(0, -3));
					arg.type = "<angle>";
					arg.unit = "deg";
				}
				else if (isNumberRegex.test(arg)) {
					// Convert numerical args to numbers
					arg = new Number(arg);
					arg.type = "<number>";
				}

				if ($0.startsWith("/")) {
					// It's alpha
					arg = arg instanceof Number? arg : new Number(arg);
					arg.alpha = true;
				}

				args.push(arg);
			});

			return {
				name: parts[1].toLowerCase(),
				rawName: parts[1],
				rawArgs: parts[2],
				// An argument could be (as of css-color-4):
				// a number, percentage, degrees (hue), ident (in color())
				args
			};
		}
	}

	function last (arr) {
		return arr[arr.length - 1];
	}

	function interpolate (start, end, p) {
		if (isNaN(start)) {
			return end;
		}

		if (isNaN(end)) {
			return start;
		}

		return start + (end - start) * p;
	}

	function interpolateInv (start, end, value) {
		return (value - start) / (end - start);
	}

	function mapRange (from, to, value) {
		return interpolate(to[0], to[1], interpolateInv(from[0], from[1], value));
	}

	function parseCoordGrammar (coordGrammars) {
		return coordGrammars.map(coordGrammar => {
			return coordGrammar.split("|").map(type => {
				type = type.trim();
				let range = type.match(/^(<[a-z]+>)\[(-?[.\d]+),\s*(-?[.\d]+)\]?$/);

				if (range) {
					let ret = new String(range[1]);
					ret.range = [+range[2], +range[3]];
					return ret;
				}

				return type;
			});
		});
	}

	var util = /*#__PURE__*/Object.freeze({
		__proto__: null,
		interpolate: interpolate,
		interpolateInv: interpolateInv,
		isString: isString,
		last: last,
		mapRange: mapRange,
		multiplyMatrices: multiplyMatrices,
		parseCoordGrammar: parseCoordGrammar,
		parseFunction: parseFunction,
		toPrecision: toPrecision,
		type: type
	});

	/**
	 * A class for adding deep extensibility to any piece of JS code
	 */
	class Hooks {
		add (name, callback, first) {
			if (typeof arguments[0] != "string") {
				// Multiple hooks
				for (var name in arguments[0]) {
					this.add(name, arguments[0][name], arguments[1]);
				}

				return;
			}

			(Array.isArray(name)? name : [name]).forEach(function (name) {
				this[name] = this[name] || [];

				if (callback) {
					this[name][first? "unshift" : "push"](callback);
				}
			}, this);
		}

		run (name, env) {
			this[name] = this[name] || [];
			this[name].forEach(function (callback) {
				callback.call(env && env.context? env.context : env, env);
			});
		}
	}
	/**
	 * The instance of {@link Hooks} used throughout Color.js
	 */
	const hooks = new Hooks();

	// Global defaults one may want to configure

	var defaults = {
		gamut_mapping: "lch.c",
		precision: 5,
		deltaE: "76", // Default deltaE method
	};

	const WHITES = {
		// for compatibility, the four-digit chromaticity-derived ones everyone else uses
		D50: [0.3457 / 0.3585, 1.00000, (1.0 - 0.3457 - 0.3585) / 0.3585],
		D65: [0.3127 / 0.3290, 1.00000, (1.0 - 0.3127 - 0.3290) / 0.3290],
	};

	function getWhite (name) {
		if (Array.isArray(name)) {
			return name;
		}

		return WHITES[name];
	}

	// Adapt XYZ from white point W1 to W2
	function adapt$1 (W1, W2, XYZ, options = {}) {
		W1 = getWhite(W1);
		W2 = getWhite(W2);

		if (!W1 || !W2) {
			throw new TypeError(`Missing white point to convert ${!W1? "from" : ""}${!W1&&!W2? "/" : ""}${!W2? "to" : ""}`);
		}

		if (W1 === W2) {
			// Same whitepoints, no conversion needed
			return XYZ;
		}

		let env = {W1, W2, XYZ, options};

		hooks.run("chromatic-adaptation-start", env);

		if (!env.M) {
			if (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) {
				env.M = [
					[  1.0479298208405488,    0.022946793341019088,  -0.05019222954313557 ],
					[  0.029627815688159344,  0.990434484573249,     -0.01707382502938514 ],
					[ -0.009243058152591178,  0.015055144896577895,   0.7518742899580008  ]
				];
			}
			else if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) {

				env.M = [
					[  0.9554734527042182,   -0.023098536874261423,  0.0632593086610217   ],
					[ -0.028369706963208136,  1.0099954580058226,    0.021041398966943008 ],
					[  0.012314001688319899, -0.020507696433477912,  1.3303659366080753   ]
				];
			}
		}

		hooks.run("chromatic-adaptation-end", env);

		if (env.M) {
			return multiplyMatrices(env.M, env.XYZ);
		}
		else {
			throw new TypeError("Only Bradford CAT with white points D50 and D65 supported for now.");
		}
	}

	const ε$4 = .000075;

	/**
	 * Class to represent a color space
	 */
	class ColorSpace {
		constructor (options) {
			this.id = options.id;
			this.name = options.name;
			this.base = options.base ? ColorSpace.get(options.base) : null;
			this.aliases = options.aliases;

			if (this.base) {
				this.fromBase = options.fromBase;
				this.toBase = options.toBase;
			}

			// Coordinate metadata

			let coords = options.coords ?? this.base.coords;

			for (let name in coords) {
				if (!("name" in coords[name])) {
					coords[name].name = name;
				}
			}
			this.coords = coords;

			// White point

			let white = options.white ?? this.base.white ?? "D65";
			this.white = getWhite(white);

			// Sort out formats

			this.formats = options.formats ?? {};

			for (let name in this.formats) {
				let format = this.formats[name];
				format.type ||= "function";
				format.name ||= name;
			}

			if (options.cssId && !this.formats.functions?.color) {
				this.formats.color = { id: options.cssId };
				Object.defineProperty(this, "cssId", {value: options.cssId});
			}
			else if (this.formats?.color && !this.formats?.color.id) {
				this.formats.color.id = this.id;
			}

			// Other stuff
			this.referred = options.referred;

			// Compute ancestors and store them, since they will never change
			Object.defineProperty(this, "path", {
				value: getPath(this).reverse(),
				writable: false,
				enumerable: true,
				configurable: true,
			});

			hooks.run("colorspace-init-end", this);
		}

		inGamut (coords, {epsilon = ε$4} = {}) {
			if (this.isPolar) {
				// Do not check gamut through polar coordinates
				coords = this.toBase(coords);

				return this.base.inGamut(coords, {epsilon});
			}

			let coordMeta = Object.values(this.coords);

			return coords.every((c, i) => {
				let meta = coordMeta[i];

				if (meta.type !== "angle" && meta.range) {
					if (Number.isNaN(c)) {
						// NaN is always in gamut
						return true;
					}

					let [min, max] = meta.range;
					return (min === undefined || c >= min - epsilon)
					    && (max === undefined || c <= max + epsilon);
				}

				return true;
			});
		}

		get cssId () {
			return this.formats.functions?.color?.id || this.id;
		}

		get isPolar () {
			for (let id in this.coords) {
				if (this.coords[id].type === "angle") {
					return true;
				}
			}

			return false;
		}

		getFormat (format) {
			if (typeof format === "object") {
				format = processFormat(format, this);
				return format;
			}

			let ret;
			if (format === "default") {
				// Get first format
				ret = Object.values(this.formats)[0];
			}
			else {
				ret = this.formats[format];
			}

			if (ret) {
				ret = processFormat(ret, this);
				return ret;
			}

			return null;
		}

		// We cannot rely on simple === because then ColorSpace objects cannot be proxied
		equals (space) {
			if (!space) {
				return false;
			}

			return this === space || this.id === space.id;
		}

		to (space, coords) {
			if (arguments.length === 1) {
				[space, coords] = [space.space, space.coords];
			}

			space = ColorSpace.get(space);

			if (this.equals(space)) {
				// Same space, no change needed
				return coords;
			}

			// Convert NaN to 0, which seems to be valid in every coordinate of every color space
			coords = coords.map(c => Number.isNaN(c)? 0 : c);

			// Find connection space = lowest common ancestor in the base tree
			let myPath = this.path;
			let otherPath = space.path;

			let connectionSpace, connectionSpaceIndex;

			for (let i=0; i < myPath.length; i++) {
				if (myPath[i].equals(otherPath[i])) {
					connectionSpace = myPath[i];
					connectionSpaceIndex = i;
				}
				else {
					break;
				}
			}

			if (!connectionSpace) {
				// This should never happen
				throw new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);
			}

			// Go up from current space to connection space
			for (let i = myPath.length - 1; i > connectionSpaceIndex; i--) {
				coords = myPath[i].toBase(coords);
			}

			// Go down from connection space to target space
			for (let i = connectionSpaceIndex + 1; i < otherPath.length; i++) {
				coords = otherPath[i].fromBase(coords);
			}

			return coords;
		}

		from (space, coords) {
			if (arguments.length === 1) {
				[space, coords] = [space.space, space.coords];
			}

			space = ColorSpace.get(space);

			return space.to(this, coords);
		}

		toString () {
			return `${this.name} (${this.id})`;
		}

		getMinCoords () {
			let ret = [];

			for (let id in this.coords) {
				let meta = this.coords[id];
				let range = meta.range || meta.refRange;
				ret.push(range?.min ?? 0);
			}

			return ret;
		}

		static registry = {};

		// Returns array of unique color spaces
		static get all () {
			return [...new Set(Object.values(ColorSpace.registry))];
		}

		static register (id, space) {
			if (arguments.length === 1) {
				space = arguments[0];
				id = space.id;
			}

			space = this.get(space);

			if (this.registry[id] && this.registry[id] !== space) {
				throw new Error(`Duplicate color space registration: '${id}'`);
			}
			this.registry[id] = space;

			// Register aliases when called without an explicit ID.
			if (arguments.length === 1 && space.aliases) {
				for (let alias of space.aliases) {
					this.register(alias, space);
				}
			}

			return space;
		}

		/**
		 * Lookup ColorSpace object by name
		 * @param {ColorSpace | string} name
		 */
		static get (space, ...alternatives) {
			if (!space || space instanceof ColorSpace) {
				return space;
			}

			let argType = type(space);

			if (argType === "string") {
				// It's a color space id
				let ret = ColorSpace.registry[space.toLowerCase()];

				if (!ret) {
					throw new TypeError(`No color space found with id = "${space}"`);
				}

				return ret;
			}

			if (alternatives.length) {
				return ColorSpace.get(...alternatives);
			}

			throw new TypeError(`${space} is not a valid color space`);
		}

		/**
		 * Get metadata about a coordinate of a color space
		 *
		 * @static
		 * @param {Array | string} ref
		 * @param {ColorSpace | string} [workingSpace]
		 * @return {Object}
		 */
		static resolveCoord (ref, workingSpace) {
			let coordType = type(ref);
			let space, coord;

			if (coordType === "string") {
				if (ref.includes(".")) {
					// Absolute coordinate
					[space, coord] = ref.split(".");
				}
				else {
					// Relative coordinate
					[space, coord] = [, ref];
				}
			}
			else if (Array.isArray(ref)) {
				[space, coord] = ref;
			}
			else {
				// Object
				space = ref.space;
				coord = ref.coordId;
			}

			space = ColorSpace.get(space);

			if (!space) {
				space = workingSpace;
			}

			if (!space) {
				throw new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);
			}

			coordType = type(coord);

			if (coordType === "number" || coordType === "string" && coord >= 0) {
				// Resolve numerical coord
				let meta = Object.entries(space.coords)[coord];

				if (meta) {
					return {space, id: meta[0], index: coord, ...meta[1]};
				}
			}

			space = ColorSpace.get(space);

			let normalizedCoord = coord.toLowerCase();

			let i = 0;
			for (let id in space.coords) {
				let meta = space.coords[id];

				if (id.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) {
					return {space, id, index: i, ...meta};
				}

				i++;
			}

			throw new TypeError(`No "${coord}" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(", ")}`);
		}

		static DEFAULT_FORMAT = {
			type: "functions",
			name: "color",
		};
	}

	function getPath (space) {
		let ret = [space];

		for (let s = space; s = s.base;) {
			ret.push(s);
		}

		return ret;
	}

	function processFormat (format, {coords} = {}) {
		if (format.coords && !format.coordGrammar) {
			format.type ||= "function";
			format.name ||= "color";

			// Format has not been processed
			format.coordGrammar = parseCoordGrammar(format.coords);

			let coordFormats = Object.entries(coords).map(([id, coordMeta], i) => {
				// Preferred format for each coord is the first one
				let outputType = format.coordGrammar[i][0];

				let fromRange = coordMeta.range || coordMeta.refRange;
				let toRange = outputType.range, suffix = "";

				// Non-strict equals intentional since outputType could be a string object
				if (outputType == "<percentage>") {
					toRange = [0, 100];
					suffix = "%";
				}
				else if (outputType == "<angle>") {
					suffix = "deg";
				}

				return  {fromRange, toRange, suffix};
			});

			format.serializeCoords = (coords, precision) => {
				return coords.map((c, i) => {
					let {fromRange, toRange, suffix} = coordFormats[i];

					if (fromRange && toRange) {
						c = mapRange(fromRange, toRange, c);
					}

					c = toPrecision(c, precision);

					if (suffix) {
						c += suffix;
					}

					return c;
				});
			};
		}

		return format;
	}

	var XYZ_D65 = new ColorSpace({
		id: "xyz-d65",
		name: "XYZ D65",
		coords: {
			x: {name: "X"},
			y: {name: "Y"},
			z: {name: "Z"},
		},
		white: "D65",
		formats: {
			color: {
				ids: ["xyz-d65", "xyz"],
			}
		},
		aliases: ["xyz"],
	});

	/**
	 * Convenience class for RGB color spaces
	 * @extends {ColorSpace}
	 */
	class RGBColorSpace extends ColorSpace {
		/**
		 * Creates a new RGB ColorSpace.
		 * If coords are not specified, they will use the default RGB coords.
		 * Instead of `fromBase()` and `toBase()` functions,
		 * you can specify to/from XYZ matrices and have `toBase()` and `fromBase()` automatically generated.
		 * @param {*} options - Same options as {@link ColorSpace} plus:
		 * @param {number[][]} options.toXYZ_M - Matrix to convert to XYZ
		 * @param {number[][]} options.fromXYZ_M - Matrix to convert from XYZ
		 */
		constructor (options) {
			if (!options.coords) {
				options.coords = {
					r: {
						range: [0, 1],
						name: "Red"
					},
					g: {
						range: [0, 1],
						name: "Green"
					},
					b: {
						range: [0, 1],
						name: "Blue"
					}
				};
			}

			if (!options.base) {
				options.base = XYZ_D65;
			}

			if (options.toXYZ_M && options.fromXYZ_M) {
				options.toBase ??= rgb => {
					let xyz = multiplyMatrices(options.toXYZ_M, rgb);

					if (this.white !== this.base.white) {
						// Perform chromatic adaptation
						xyz = adapt$1(this.white, this.base.white, xyz);
					}

					return xyz;
				};

				options.fromBase ??= xyz => {
					xyz = adapt$1(this.base.white, this.white, xyz);
					return multiplyMatrices(options.fromXYZ_M, xyz);
				};
			}

			options.referred ??= "display";

			super(options);
		}
	}

	/**
	 * Convert a CSS Color string to a color object
	 * @param {string} str
	 * @param {object} [options]
	 * @param {object} [options.meta] - Object for additional information about the parsing
	 * @returns { Color }
	 */
	function parse$1 (str, {meta} = {}) {
		let env = {"str": String(str)?.trim()};
		hooks.run("parse-start", env);

		if (env.color) {
			return env.color;
		}

		env.parsed = parseFunction(env.str);

		if (env.parsed) {
			// Is a functional syntax
			let name = env.parsed.name;

			if (name === "color") {
				// color() function
				let id = env.parsed.args.shift();
				let alpha = env.parsed.rawArgs.indexOf("/") > 0? env.parsed.args.pop() : 1;

				for (let space of ColorSpace.all) {
					let colorSpec = space.getFormat("color");

					if (colorSpec) {
						if (id === colorSpec.id || colorSpec.ids?.includes(id)) {
							// From https://drafts.csswg.org/css-color-4/#color-function
							// If more <number>s or <percentage>s are provided than parameters that the colorspace takes, the excess <number>s at the end are ignored.
							// If less <number>s or <percentage>s are provided than parameters that the colorspace takes, the missing parameters default to 0. (This is particularly convenient for multichannel printers where the additional inks are spot colors or varnishes that most colors on the page won’t use.)
							const coords = Object.keys(space.coords).map((_, i) => env.parsed.args[i] || 0);

							if (meta) {
								meta.formatId = "color";
							}

							return {spaceId: space.id, coords, alpha};
						}
					}
				}

				// Not found
				let didYouMean = "";
				if (id in ColorSpace.registry) {
					// Used color space id instead of color() id, these are often different
					let cssId = ColorSpace.registry[id].formats?.functions?.color?.id;

					if (cssId) {
						didYouMean = `Did you mean color(${cssId})?`;
					}
				}

				throw new TypeError(`Cannot parse color(${id}). ` + (didYouMean || "Missing a plugin?"));
			}
			else {
				for (let space of ColorSpace.all) {
					// color space specific function
					let format = space.getFormat(name);
					if (format && format.type === "function") {
						let alpha = 1;

						if (format.lastAlpha || last(env.parsed.args).alpha) {
							alpha = env.parsed.args.pop();
						}

						let coords = env.parsed.args;

						let types;

						if (format.coordGrammar) {
							types = Object.entries(space.coords).map(([id, coordMeta], i) => {
								let coordGrammar = format.coordGrammar[i];
								let providedType = coords[i]?.type;

								// Find grammar alternative that matches the provided type
								// Non-strict equals is intentional because we are comparing w/ string objects
								let type = coordGrammar.find(c => c == providedType);

								// Check that each coord conforms to its grammar
								if (!type) {
									// Type does not exist in the grammar, throw
									let coordName = coordMeta.name || id;
									throw new TypeError(`${providedType} not allowed for ${coordName} in ${name}()`);
								}

								let fromRange = type.range;

								if (providedType === "<percentage>") {
									fromRange ||= [0, 1];
								}

								let toRange = coordMeta.range || coordMeta.refRange;

								if (fromRange && toRange) {
									coords[i] = mapRange(fromRange, toRange, coords[i]);
								}

								return type;
							});
						}

						if (meta) {
							Object.assign(meta, {formatId: format.name, types});
						}

						return {
							spaceId: space.id,
							coords, alpha
						};
					}
				}
			}
		}
		else {
			// Custom, colorspace-specific format
			for (let space of ColorSpace.all) {
				for (let formatId in space.formats) {
					let format = space.formats[formatId];

					if (format.type !== "custom") {
						continue;
					}

					if (format.test && !format.test(env.str)) {
						continue;
					}

					let color = format.parse(env.str);

					if (color) {
						color.alpha ??= 1;

						if (meta) {
							meta.formatId = formatId;
						}

						return color;
					}
				}
			}
		}


		// If we're here, we couldn't parse
		throw new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);
	}

	/**
	 * Resolves a color reference (object or string) to a plain color object
	 * @param {Color | {space, coords, alpha} | string} color
	 * @returns {{space, coords, alpha}}
	 */
	function getColor (color) {
		if (!color) {
			throw new TypeError("Empty color reference");
		}

		if (isString(color)) {
			color = parse$1(color);
		}

		// Object fixup
		let space = color.space || color.spaceId;

		if (!(space instanceof ColorSpace)) {
			// Convert string id to color space object
			color.space = ColorSpace.get(space);
		}

		if (color.alpha === undefined) {
			color.alpha = 1;
		}

		return color;
	}

	/**
	 * Get the coordinates of a color in another color space
	 *
	 * @param {string | ColorSpace} space
	 * @returns {number[]}
	 */
	function getAll (color, space) {
		space = ColorSpace.get(space);
		return space.from(color);
	}

	function get (color, prop) {
		let {space, index} = ColorSpace.resolveCoord(prop, color.space);
		let coords = getAll(color, space);
		return coords[index];
	}

	function setAll (color, space, coords) {
		space = ColorSpace.get(space);
		color.coords = space.to(color.space, coords);
		return color;
	}

	// Set properties and return current instance
	function set (color, prop, value) {
		color = getColor(color);

		if (arguments.length === 2 && type(arguments[1]) === "object") {
			// Argument is an object literal
			let object = arguments[1];
			for (let p in object) {
				set(color, p, object[p]);
			}
		}
		else {
			if (typeof value === "function") {
				value = value(get(color, prop));
			}

			let {space, index} = ColorSpace.resolveCoord(prop, color.space);
			let coords = getAll(color, space);
			coords[index] = value;
			setAll(color, space, coords);
		}

		return color;
	}

	var XYZ_D50 = new ColorSpace({
		id: "xyz-d50",
		name: "XYZ D50",
		white: "D50",
		base: XYZ_D65,
		fromBase: coords => adapt$1(XYZ_D65.white, "D50", coords),
		toBase: coords => adapt$1("D50", XYZ_D65.white, coords),
		formats: {
			color: {}
		},
	});

	// κ * ε  = 2^3 = 8
	const ε$3 = 216/24389;  // 6^3/29^3 == (24/116)^3
	const ε3$1 = 24/116;
	const κ$1 = 24389/27;   // 29^3/3^3

	let white$1 = WHITES.D50;

	var lab = new ColorSpace({
		id: "lab",
		name: "Lab",
		coords: {
			l: {
				refRange: [0, 100],
				name: "L"
			},
			a: {
				refRange: [-125, 125]
			},
			b: {
				refRange: [-125, 125]
			}
		},

		// Assuming XYZ is relative to D50, convert to CIE Lab
		// from CIE standard, which now defines these as a rational fraction
		white: white$1,

		base: XYZ_D50,
		// Convert D50-adapted XYX to Lab
		//  CIE 15.3:2004 section 8.2.1.1
		fromBase (XYZ) {
			// compute xyz, which is XYZ scaled relative to reference white
			let xyz = XYZ.map((value, i) => value / white$1[i]);

			// now compute f
			let f = xyz.map(value => value > ε$3 ? Math.cbrt(value) : (κ$1 * value + 16)/116);

			return [
				(116 * f[1]) - 16, 	 // L
				500 * (f[0] - f[1]), // a
				200 * (f[1] - f[2])  // b
			];
		},
		// Convert Lab to D50-adapted XYZ
		// Same result as CIE 15.3:2004 Appendix D although the derivation is different
		// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
		toBase (Lab) {
			// compute f, starting with the luminance-related term
			let f = [];
			f[1] = (Lab[0] + 16)/116;
			f[0] = Lab[1]/500 + f[1];
			f[2] = f[1] - Lab[2]/200;

			// compute xyz
			let xyz = [
				f[0]   > ε3$1  ?  Math.pow(f[0], 3)            : (116*f[0]-16)/κ$1,
				Lab[0] > 8   ?  Math.pow((Lab[0]+16)/116, 3) : Lab[0]/κ$1,
				f[2]   > ε3$1  ?  Math.pow(f[2], 3)            : (116*f[2]-16)/κ$1
			];

			// Compute XYZ by scaling xyz by reference white
			return xyz.map((value, i) => value * white$1[i]);
		},

		formats: {
			"lab": {
				coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"],
			}
		}
	});

	function constrain (angle) {
		return ((angle % 360) + 360) % 360;
	}

	function adjust (arc, angles) {
		if (arc === "raw") {
			return angles;
		}

		let [a1, a2] = angles.map(constrain);

		let angleDiff = a2 - a1;

		if (arc === "increasing") {
			if (angleDiff < 0) {
				a2 += 360;
			}
		}
		else if (arc === "decreasing") {
			if (angleDiff > 0) {
				a1 += 360;
			}
		}
		else if (arc === "longer") {
			if (-180 < angleDiff && angleDiff < 180) {
				if (angleDiff > 0) {
					a1 += 360;
				}
				else {
					a2 += 360;
				}
			}
		}
		else if (arc === "shorter") {
			if (angleDiff > 180) {
				a1 += 360;
			}
			else if (angleDiff < -180) {
				a2 += 360;
			}
		}

		return [a1, a2];
	}

	var lch = new ColorSpace({
		id: "lch",
		name: "LCH",
		coords: {
			l: {
				refRange: [0, 100],
				name: "Lightness"
			},
			c: {
				refRange: [0, 150],
				name: "Chroma"
			},
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			}
		},

		base: lab,
		fromBase (Lab) {
			// Convert to polar form
			let [L, a, b] = Lab;
			let hue;
			const ε = 0.02;

			if (Math.abs(a) < ε && Math.abs(b) < ε) {
				hue = NaN;
			}
			else {
				hue = Math.atan2(b, a) * 180 / Math.PI;
			}

			return [
				L, // L is still L
				Math.sqrt(a ** 2 + b ** 2), // Chroma
				constrain(hue) // Hue, in degrees [0 to 360)
			];
		},
		toBase (LCH) {
			// Convert from polar form
			let [Lightness, Chroma, Hue] = LCH;
			// Clamp any negative Chroma
			if (Chroma < 0) {
				Chroma = 0;
			}		// Deal with NaN Hue
			if (isNaN(Hue)) {
				Hue = 0;
			}
			return [
				Lightness, // L is still L
				Chroma * Math.cos(Hue * Math.PI / 180), // a
				Chroma * Math.sin(Hue * Math.PI / 180)  // b
			];
		},

		formats: {
			"lch": {
				coords: ["<number> | <percentage>", "<number> | <percentage>", "<number> | <angle>"],
			}
		}
	});

	// deltaE2000 is a statistically significant improvement
	// and is recommended by the CIE and Idealliance
	// especially for color differences less than 10 deltaE76
	// but is wicked complicated
	// and many implementations have small errors!
	// DeltaE2000 is also discontinuous; in case this
	// matters to you, use deltaECMC instead.

	const Gfactor = 25 ** 7;
	const π$1 = Math.PI;
	const r2d = 180 / π$1;
	const d2r$1 = π$1 / 180;

	function deltaE2000 (color, sample, {kL = 1, kC = 1, kH = 1} = {}) {
		// Given this color as the reference
		// and the function parameter as the sample,
		// calculate deltaE 2000.

		// This implementation assumes the parametric
		// weighting factors kL, kC and kH
		// for the influence of viewing conditions
		// are all 1, as sadly seems typical.
		// kL should be increased for lightness texture or noise
		// and kC increased for chroma noise

		let [L1, a1, b1] = lab.from(color);
		let C1 = lch.from(lab, [L1, a1, b1])[1];
		let [L2, a2, b2] = lab.from(sample);
		let C2 = lch.from(lab, [L2, a2, b2])[1];

		// Check for negative Chroma,
		// which might happen through
		// direct user input of LCH values

		if (C1 < 0) {
			C1 = 0;
		}
		if (C2 < 0) {
			C2 = 0;
		}

		let Cbar = (C1 + C2)/2; // mean Chroma

		// calculate a-axis asymmetry factor from mean Chroma
		// this turns JND ellipses for near-neutral colors back into circles
		let C7 = Cbar ** 7;

		let G = 0.5 * (1 - Math.sqrt(C7/(C7 + Gfactor)));

		// scale a axes by asymmetry factor
		// this by the way is why there is no Lab2000 colorspace
		let adash1 = (1 + G) * a1;
		let adash2 = (1 + G) * a2;

		// calculate new Chroma from scaled a and original b axes
		let Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);
		let Cdash2 = Math.sqrt(adash2 ** 2 + b2 ** 2);

		// calculate new hues, with zero hue for true neutrals
		// and in degrees, not radians

		let h1 = (adash1 === 0 && b1 === 0)? 0: Math.atan2(b1, adash1);
		let h2 = (adash2 === 0 && b2 === 0)? 0: Math.atan2(b2, adash2);

		if (h1 < 0) {
			h1 += 2 * π$1;
		}
		if (h2 < 0) {
			h2 += 2 * π$1;
		}

		h1 *= r2d;
		h2 *= r2d;

		// Lightness and Chroma differences; sign matters
		let ΔL = L2 - L1;
		let ΔC = Cdash2 - Cdash1;

		// Hue difference, getting the sign correct
		let hdiff = h2 - h1;
		let hsum = h1 + h2;
		let habs = Math.abs(hdiff);
		let Δh;

		if (Cdash1 * Cdash2 === 0) {
			Δh = 0;
		}
		else if (habs <= 180) {
			Δh = hdiff;
		}
		else if (hdiff > 180) {
			Δh = hdiff - 360;
		}
		else if (hdiff < -180) {
			Δh = hdiff + 360;
		}
		else {
			console.log("the unthinkable has happened");
		}

		// weighted Hue difference, more for larger Chroma
		let ΔH = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(Δh * d2r$1 / 2);

		// calculate mean Lightness and Chroma
		let Ldash = (L1 + L2)/2;
		let Cdash = (Cdash1 + Cdash2)/2;
		let Cdash7 = Math.pow(Cdash, 7);

		// Compensate for non-linearity in the blue region of Lab.
		// Four possibilities for hue weighting factor,
		// depending on the angles, to get the correct sign
		let hdash;
		if (Cdash1 * Cdash2 === 0) {
			hdash = hsum;   // which should be zero
		}
		else if (habs <= 180) {
			hdash = hsum / 2;
		}
		else if (hsum < 360) {
			hdash = (hsum + 360) / 2;
		}
		else {
			hdash = (hsum - 360) / 2;
		}

		// positional corrections to the lack of uniformity of CIELAB
		// These are all trying to make JND ellipsoids more like spheres

		// SL Lightness crispening factor
		// a background with L=50 is assumed
		let lsq = (Ldash - 50) ** 2;
		let SL = 1 + ((0.015 * lsq) / Math.sqrt(20 + lsq));

		// SC Chroma factor, similar to those in CMC and deltaE 94 formulae
		let SC = 1 + 0.045 * Cdash;

		// Cross term T for blue non-linearity
		let T = 1;
		T -= (0.17 * Math.cos((     hdash - 30)  * d2r$1));
		T += (0.24 * Math.cos(  2 * hdash        * d2r$1));
		T += (0.32 * Math.cos(((3 * hdash) + 6)  * d2r$1));
		T -= (0.20 * Math.cos(((4 * hdash) - 63) * d2r$1));

		// SH Hue factor depends on Chroma,
		// as well as adjusted hue angle like deltaE94.
		let SH = 1 + 0.015 * Cdash * T;

		// RT Hue rotation term compensates for rotation of JND ellipses
		// and Munsell constant hue lines
		// in the medium-high Chroma blue region
		// (Hue 225 to 315)
		let Δθ = 30 * Math.exp(-1 * (((hdash - 275)/25) ** 2));
		let RC = 2 * Math.sqrt(Cdash7/(Cdash7 + Gfactor));
		let RT = -1 * Math.sin(2 * Δθ * d2r$1) * RC;

		// Finally calculate the deltaE, term by term as root sume of squares
		let dE = (ΔL / (kL * SL)) ** 2;
		dE += (ΔC / (kC * SC)) ** 2;
		dE += (ΔH / (kH * SH)) ** 2;
		dE += RT * (ΔC / (kC * SC)) * (ΔH / (kH * SH));
		return Math.sqrt(dE);
		// Yay!!!
	}

	const ε$2 = .000075;

	/**
	 * Check if a color is in gamut of either its own or another color space
	 * @return {Boolean} Is the color in gamut?
	 */
	function inGamut (color, space = color.space, {epsilon = ε$2} = {}) {
		color = getColor(color);
		space = ColorSpace.get(space);
		let coords = color.coords;

		if (space !== color.space) {
			coords = space.from(color);
		}

		return space.inGamut(coords, {epsilon});
	}

	function clone (color) {
		return {
			space: color.space,
			coords: color.coords.slice(),
			alpha: color.alpha
		};
	}

	/**
	 * Force coordinates to be in gamut of a certain color space.
	 * Mutates the color it is passed.
	 * @param {Object} options
	 * @param {string} options.method - How to force into gamut.
	 *        If "clip", coordinates are just clipped to their reference range.
	 *        If in the form [colorSpaceId].[coordName], that coordinate is reduced
	 *        until the color is in gamut. Please note that this may produce nonsensical
	 *        results for certain coordinates (e.g. hue) or infinite loops if reducing the coordinate never brings the color in gamut.
	 * @param {ColorSpace|string} options.space - The space whose gamut we want to map to
	 */
	function toGamut (color, {method = defaults.gamut_mapping, space = color.space} = {}) {
		if (isString(arguments[1])) {
			space = arguments[1];
		}

		space = ColorSpace.get(space);

		if (inGamut(color, space, {epsilon: 0})) {
			return getColor(color);
		}

		// 3 spaces:
		// color.space: current color space
		// space: space whose gamut we are mapping to
		// mapSpace: space with the coord we're reducing
		let spaceColor = to(color, space);

		if (method !== "clip" && !inGamut(color, space)) {
			let clipped = toGamut(clone(spaceColor), {method: "clip", space});
			if (deltaE2000(color, clipped) > 2) {
				// Reduce a coordinate of a certain color space until the color is in gamut
				let coordMeta = ColorSpace.resolveCoord(method);
				let mapSpace = coordMeta.space;
				let coordId = coordMeta.id;

				let mappedColor = to(spaceColor, mapSpace);
				let bounds = coordMeta.range || coordMeta.refRange;
				let min = bounds[0];
				let ε = .01; // for deltaE
				let low = min;
				let high = get(mappedColor, coordId);

				while (high - low > ε) {
					let clipped = clone(mappedColor);
					clipped = toGamut(clipped, {space, method: "clip"});
					let deltaE = deltaE2000(mappedColor, clipped);

					if (deltaE - 2 < ε) {
						low = get(mappedColor, coordId);
					}
					else {
						high = get(mappedColor, coordId);
					}

					set(mappedColor, coordId, (low + high) / 2);
				}

				spaceColor = to(mappedColor, space);
			}
			else {
				spaceColor = clipped;
			}
		}

		if (method === "clip" // Dumb coord clipping
			// finish off smarter gamut mapping with clip to get rid of ε, see #17
			|| !inGamut(spaceColor, space, {epsilon: 0})
		) {
			let bounds = Object.values(space.coords).map(c => c.range || []);

			spaceColor.coords = spaceColor.coords.map((c, i) => {
				let [min, max] = bounds[i];

				if (min !== undefined) {
					c = Math.max(min, c);
				}

				if (max !== undefined) {
					c = Math.min(c, max);
				}

				return c;
			});
		}

		if (space !== color.space) {
			spaceColor = to(spaceColor, color.space);
		}

		color.coords = spaceColor.coords;
		return color;
	}

	toGamut.returns = "color";

	/**
	 * Convert to color space and return a new color
	 * @param {Object|string} space - Color space object or id
	 * @param {Object} options
	 * @param {boolean} options.inGamut - Whether to force resulting color in gamut
	 * @returns {Color}
	 */
	function to (color, space, {inGamut} = {}) {
		color = getColor(color);
		space = ColorSpace.get(space);

		let coords = space.from(color);
		let ret = {space, coords, alpha: color.alpha};

		if (inGamut) {
			ret = toGamut(ret);
		}

		return ret;
	}

	to.returns = "color";

	/**
	 * Generic toString() method, outputs a color(spaceId ...coords) function, a functional syntax, or custom formats defined by the color space
	 * @param {Object} options
	 * @param {number} options.precision - Significant digits
	 * @param {boolean} options.inGamut - Adjust coordinates to fit in gamut first? [default: false]
	 */
	function serialize$1 (color, {
		precision = defaults.precision,
		format = "default",
		inGamut: inGamut$1 = true,
		...customOptions
	} = {}) {
		let ret;

		color = getColor(color);

		let formatId = format;
		format = color.space.getFormat(format)
			   ?? color.space.getFormat("default")
			   ?? ColorSpace.DEFAULT_FORMAT;

		inGamut$1 ||= format.toGamut;

		let coords = color.coords;

		// Convert NaN to zeros to have a chance at a valid CSS color
		// Also convert -0 to 0
		// This also clones it so we can manipulate it
		coords = coords.map(c => c? c : 0);

		if (inGamut$1 && !inGamut(color)) {
			coords = toGamut(clone(color), inGamut$1 === true? undefined : inGamut$1).coords;
		}

		if (format.type === "custom") {
			customOptions.precision = precision;

			if (format.serialize) {
				ret = format.serialize(coords, color.alpha, customOptions);
			}
			else {
				throw new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);
			}
		}
		else {
			// Functional syntax
			let name = format.name || "color";

			if (format.serializeCoords) {
				coords = format.serializeCoords(coords, precision);
			}
			else {
				if (precision !== null) {
					coords = coords.map(c => toPrecision(c, precision));
				}
			}

			let args = [...coords];

			if (name === "color") {
				// If output is a color() function, add colorspace id as first argument
				let cssId = format.id || format.ids?.[0] || color.space.id;
				args.unshift(cssId);
			}

			let alpha = color.alpha;
			if (precision !== null) {
				alpha = toPrecision(alpha, precision);
			}

			let strAlpha = color.alpha < 1 && !format.noAlpha? `${format.commas? "," : " /"} ${alpha}` : "";
			ret = `${name}(${args.join(format.commas? ", " : " ")}${strAlpha})`;
		}

		return ret;
	}

	// convert an array of linear-light rec2020 values to CIE XYZ
	// using  D65 (no chromatic adaptation)
	// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
	// 0 is actually calculated as  4.994106574466076e-17
	const toXYZ_M$5 = [
		[ 0.6369580483012914, 0.14461690358620832,  0.1688809751641721  ],
		[ 0.2627002120112671, 0.6779980715188708,   0.05930171646986196 ],
		[ 0.000000000000000,  0.028072693049087428, 1.060985057710791   ]
	];

	// from ITU-R BT.2124-0 Annex 2 p.3
	const fromXYZ_M$5 = [
		[  1.716651187971268,  -0.355670783776392, -0.253366281373660  ],
		[ -0.666684351832489,   1.616481236634939,  0.0157685458139111 ],
		[  0.017639857445311,  -0.042770613257809,  0.942103121235474  ]
	];

	var REC2020Linear = new RGBColorSpace({
		id: "rec2020-linear",
		name: "Linear REC.2020",
		white: "D65",
		toXYZ_M: toXYZ_M$5,
		fromXYZ_M: fromXYZ_M$5,
		formats: {
			color: {},
		}
	});

	// import sRGB from "./srgb.js";

	const α = 1.09929682680944;
	const β = 0.018053968510807;

	var REC2020 = new RGBColorSpace({
		id: "rec2020",
		name: "REC.2020",
		base: REC2020Linear,
		// Non-linear transfer function from Rec. ITU-R BT.2020-2 table 4
		toBase (RGB) {
			return RGB.map(function (val) {
				if (val < β * 4.5 ) {
					return val / 4.5;
				}

				return Math.pow((val + α -1 ) / α, 1/0.45);
			});
		},
		fromBase (RGB) {
			return RGB.map(function (val) {
				if (val >= β ) {
					return α * Math.pow(val, 0.45) - (α - 1);
				}

				return 4.5 * val;
			});
		},
		formats: {
			color: {},
		}
	});

	const toXYZ_M$4 = [
		[0.4865709486482162, 0.26566769316909306, 0.1982172852343625],
		[0.2289745640697488, 0.6917385218365064,  0.079286914093745],
		[0.0000000000000000, 0.04511338185890264, 1.043944368900976]
	];

	const fromXYZ_M$4 = [
		[ 2.493496911941425,   -0.9313836179191239, -0.40271078445071684],
		[-0.8294889695615747,   1.7626640603183463,  0.023624685841943577],
		[ 0.03584583024378447, -0.07617238926804182, 0.9568845240076872]
	];

	var P3Linear = new RGBColorSpace({
		id: "p3-linear",
		name: "Linear P3",
		white: "D65",
		toXYZ_M: toXYZ_M$4,
		fromXYZ_M: fromXYZ_M$4
	});

	// This is the linear-light version of sRGB
	// as used for example in SVG filters
	// or in Canvas

	// This matrix was calculated directly from the RGB and white chromaticities
	// when rounded to 8 decimal places, it agrees completely with the official matrix
	// see https://github.com/w3c/csswg-drafts/issues/5922
	const toXYZ_M$3 = [
		[ 0.41239079926595934, 0.357584339383878,   0.1804807884018343  ],
		[ 0.21263900587151027, 0.715168678767756,   0.07219231536073371 ],
		[ 0.01933081871559182, 0.11919477979462598, 0.9505321522496607  ]
	];

	// This matrix is the inverse of the above;
	// again it agrees with the official definition when rounded to 8 decimal places
	const fromXYZ_M$3 = [
		[  3.2409699419045226,  -1.537383177570094,   -0.4986107602930034  ],
		[ -0.9692436362808796,   1.8759675015077202,   0.04155505740717559 ],
		[  0.05563007969699366, -0.20397695888897652,  1.0569715142428786  ]
	];

	var sRGBLinear = new RGBColorSpace({
		id: "srgb-linear",
		name: "Linear sRGB",
		white: "D65",
		toXYZ_M: toXYZ_M$3,
		fromXYZ_M: fromXYZ_M$3,
		formats: {
			color: {}
		},
	});

	/* List of CSS color keywords
	 * Note that this does not include currentColor, transparent,
	 * or system colors
	 */

	// To produce: Visit https://www.w3.org/TR/css-color-4/#named-colors
	// and run in the console:
	// copy($$("tr", $(".named-color-table tbody")).map(tr => `"${tr.cells[2].textContent.trim()}": [${tr.cells[4].textContent.trim().split(/\s+/).map(c => c === "0"? "0" : c === "255"? "1" : c + " / 255").join(", ")}]`).join(",\n"))
	var KEYWORDS = {
		"aliceblue": [240 / 255, 248 / 255, 1],
		"antiquewhite": [250 / 255, 235 / 255, 215 / 255],
		"aqua": [0, 1, 1],
		"aquamarine": [127 / 255, 1, 212 / 255],
		"azure": [240 / 255, 1, 1],
		"beige": [245 / 255, 245 / 255, 220 / 255],
		"bisque": [1, 228 / 255, 196 / 255],
		"black": [0, 0, 0],
		"blanchedalmond": [1, 235 / 255, 205 / 255],
		"blue": [0, 0, 1],
		"blueviolet": [138 / 255, 43 / 255, 226 / 255],
		"brown": [165 / 255, 42 / 255, 42 / 255],
		"burlywood": [222 / 255, 184 / 255, 135 / 255],
		"cadetblue": [95 / 255, 158 / 255, 160 / 255],
		"chartreuse": [127 / 255, 1, 0],
		"chocolate": [210 / 255, 105 / 255, 30 / 255],
		"coral": [1, 127 / 255, 80 / 255],
		"cornflowerblue": [100 / 255, 149 / 255, 237 / 255],
		"cornsilk": [1, 248 / 255, 220 / 255],
		"crimson": [220 / 255, 20 / 255, 60 / 255],
		"cyan": [0, 1, 1],
		"darkblue": [0, 0, 139 / 255],
		"darkcyan": [0, 139 / 255, 139 / 255],
		"darkgoldenrod": [184 / 255, 134 / 255, 11 / 255],
		"darkgray": [169 / 255, 169 / 255, 169 / 255],
		"darkgreen": [0, 100 / 255, 0],
		"darkgrey": [169 / 255, 169 / 255, 169 / 255],
		"darkkhaki": [189 / 255, 183 / 255, 107 / 255],
		"darkmagenta": [139 / 255, 0, 139 / 255],
		"darkolivegreen": [85 / 255, 107 / 255, 47 / 255],
		"darkorange": [1, 140 / 255, 0],
		"darkorchid": [153 / 255, 50 / 255, 204 / 255],
		"darkred": [139 / 255, 0, 0],
		"darksalmon": [233 / 255, 150 / 255, 122 / 255],
		"darkseagreen": [143 / 255, 188 / 255, 143 / 255],
		"darkslateblue": [72 / 255, 61 / 255, 139 / 255],
		"darkslategray": [47 / 255, 79 / 255, 79 / 255],
		"darkslategrey": [47 / 255, 79 / 255, 79 / 255],
		"darkturquoise": [0, 206 / 255, 209 / 255],
		"darkviolet": [148 / 255, 0, 211 / 255],
		"deeppink": [1, 20 / 255, 147 / 255],
		"deepskyblue": [0, 191 / 255, 1],
		"dimgray": [105 / 255, 105 / 255, 105 / 255],
		"dimgrey": [105 / 255, 105 / 255, 105 / 255],
		"dodgerblue": [30 / 255, 144 / 255, 1],
		"firebrick": [178 / 255, 34 / 255, 34 / 255],
		"floralwhite": [1, 250 / 255, 240 / 255],
		"forestgreen": [34 / 255, 139 / 255, 34 / 255],
		"fuchsia": [1, 0, 1],
		"gainsboro": [220 / 255, 220 / 255, 220 / 255],
		"ghostwhite": [248 / 255, 248 / 255, 1],
		"gold": [1, 215 / 255, 0],
		"goldenrod": [218 / 255, 165 / 255, 32 / 255],
		"gray": [128 / 255, 128 / 255, 128 / 255],
		"green": [0, 128 / 255, 0],
		"greenyellow": [173 / 255, 1, 47 / 255],
		"grey": [128 / 255, 128 / 255, 128 / 255],
		"honeydew": [240 / 255, 1, 240 / 255],
		"hotpink": [1, 105 / 255, 180 / 255],
		"indianred": [205 / 255, 92 / 255, 92 / 255],
		"indigo": [75 / 255, 0, 130 / 255],
		"ivory": [1, 1, 240 / 255],
		"khaki": [240 / 255, 230 / 255, 140 / 255],
		"lavender": [230 / 255, 230 / 255, 250 / 255],
		"lavenderblush": [1, 240 / 255, 245 / 255],
		"lawngreen": [124 / 255, 252 / 255, 0],
		"lemonchiffon": [1, 250 / 255, 205 / 255],
		"lightblue": [173 / 255, 216 / 255, 230 / 255],
		"lightcoral": [240 / 255, 128 / 255, 128 / 255],
		"lightcyan": [224 / 255, 1, 1],
		"lightgoldenrodyellow": [250 / 255, 250 / 255, 210 / 255],
		"lightgray": [211 / 255, 211 / 255, 211 / 255],
		"lightgreen": [144 / 255, 238 / 255, 144 / 255],
		"lightgrey": [211 / 255, 211 / 255, 211 / 255],
		"lightpink": [1, 182 / 255, 193 / 255],
		"lightsalmon": [1, 160 / 255, 122 / 255],
		"lightseagreen": [32 / 255, 178 / 255, 170 / 255],
		"lightskyblue": [135 / 255, 206 / 255, 250 / 255],
		"lightslategray": [119 / 255, 136 / 255, 153 / 255],
		"lightslategrey": [119 / 255, 136 / 255, 153 / 255],
		"lightsteelblue": [176 / 255, 196 / 255, 222 / 255],
		"lightyellow": [1, 1, 224 / 255],
		"lime": [0, 1, 0],
		"limegreen": [50 / 255, 205 / 255, 50 / 255],
		"linen": [250 / 255, 240 / 255, 230 / 255],
		"magenta": [1, 0, 1],
		"maroon": [128 / 255, 0, 0],
		"mediumaquamarine": [102 / 255, 205 / 255, 170 / 255],
		"mediumblue": [0, 0, 205 / 255],
		"mediumorchid": [186 / 255, 85 / 255, 211 / 255],
		"mediumpurple": [147 / 255, 112 / 255, 219 / 255],
		"mediumseagreen": [60 / 255, 179 / 255, 113 / 255],
		"mediumslateblue": [123 / 255, 104 / 255, 238 / 255],
		"mediumspringgreen": [0, 250 / 255, 154 / 255],
		"mediumturquoise": [72 / 255, 209 / 255, 204 / 255],
		"mediumvioletred": [199 / 255, 21 / 255, 133 / 255],
		"midnightblue": [25 / 255, 25 / 255, 112 / 255],
		"mintcream": [245 / 255, 1, 250 / 255],
		"mistyrose": [1, 228 / 255, 225 / 255],
		"moccasin": [1, 228 / 255, 181 / 255],
		"navajowhite": [1, 222 / 255, 173 / 255],
		"navy": [0, 0, 128 / 255],
		"oldlace": [253 / 255, 245 / 255, 230 / 255],
		"olive": [128 / 255, 128 / 255, 0],
		"olivedrab": [107 / 255, 142 / 255, 35 / 255],
		"orange": [1, 165 / 255, 0],
		"orangered": [1, 69 / 255, 0],
		"orchid": [218 / 255, 112 / 255, 214 / 255],
		"palegoldenrod": [238 / 255, 232 / 255, 170 / 255],
		"palegreen": [152 / 255, 251 / 255, 152 / 255],
		"paleturquoise": [175 / 255, 238 / 255, 238 / 255],
		"palevioletred": [219 / 255, 112 / 255, 147 / 255],
		"papayawhip": [1, 239 / 255, 213 / 255],
		"peachpuff": [1, 218 / 255, 185 / 255],
		"peru": [205 / 255, 133 / 255, 63 / 255],
		"pink": [1, 192 / 255, 203 / 255],
		"plum": [221 / 255, 160 / 255, 221 / 255],
		"powderblue": [176 / 255, 224 / 255, 230 / 255],
		"purple": [128 / 255, 0, 128 / 255],
		"rebeccapurple": [102 / 255, 51 / 255, 153 / 255],
		"red": [1, 0, 0],
		"rosybrown": [188 / 255, 143 / 255, 143 / 255],
		"royalblue": [65 / 255, 105 / 255, 225 / 255],
		"saddlebrown": [139 / 255, 69 / 255, 19 / 255],
		"salmon": [250 / 255, 128 / 255, 114 / 255],
		"sandybrown": [244 / 255, 164 / 255, 96 / 255],
		"seagreen": [46 / 255, 139 / 255, 87 / 255],
		"seashell": [1, 245 / 255, 238 / 255],
		"sienna": [160 / 255, 82 / 255, 45 / 255],
		"silver": [192 / 255, 192 / 255, 192 / 255],
		"skyblue": [135 / 255, 206 / 255, 235 / 255],
		"slateblue": [106 / 255, 90 / 255, 205 / 255],
		"slategray": [112 / 255, 128 / 255, 144 / 255],
		"slategrey": [112 / 255, 128 / 255, 144 / 255],
		"snow": [1, 250 / 255, 250 / 255],
		"springgreen": [0, 1, 127 / 255],
		"steelblue": [70 / 255, 130 / 255, 180 / 255],
		"tan": [210 / 255, 180 / 255, 140 / 255],
		"teal": [0, 128 / 255, 128 / 255],
		"thistle": [216 / 255, 191 / 255, 216 / 255],
		"tomato": [1, 99 / 255, 71 / 255],
		"turquoise": [64 / 255, 224 / 255, 208 / 255],
		"violet": [238 / 255, 130 / 255, 238 / 255],
		"wheat": [245 / 255, 222 / 255, 179 / 255],
		"white": [1, 1, 1],
		"whitesmoke": [245 / 255, 245 / 255, 245 / 255],
		"yellow": [1, 1, 0],
		"yellowgreen": [154 / 255, 205 / 255, 50 / 255]
	};

	let coordGrammar = Array(3).fill("<percentage> | <number>[0, 255]");
	let coordGrammarNumber = Array(3).fill("<number>[0, 255]");

	var sRGB = new RGBColorSpace({
		id: "srgb",
		name: "sRGB",
		base: sRGBLinear,
		fromBase: rgb => {
			// convert an array of linear-light sRGB values in the range 0.0-1.0
			// to gamma corrected form
			// https://en.wikipedia.org/wiki/SRGB
			return rgb.map(val => {
				let sign = val < 0? -1 : 1;
				let abs = val * sign;

				if (abs > 0.0031308) {
					return sign * (1.055 * (abs ** (1/2.4)) - 0.055);
				}

				return 12.92 * val;
			});
		},
		toBase: rgb => {
			// convert an array of sRGB values in the range 0.0 - 1.0
			// to linear light (un-companded) form.
			// https://en.wikipedia.org/wiki/SRGB
			return rgb.map(val => {
				let sign = val < 0? -1 : 1;
				let abs = val * sign;

				if (abs < 0.04045) {
					return val / 12.92;
				}

				return sign * (((abs + 0.055) / 1.055) ** 2.4);
			});
		},
		formats: {
			"rgb": {
				coords: coordGrammar,
			},
			"rgb_number": {
				name: "rgb",
				commas: true,
				coords: coordGrammarNumber,
				noAlpha: true,
			},
			"color": { /* use defaults */ },
			"rgba": {
				coords: coordGrammar,
				commas: true,
				lastAlpha: true,
			},
			"rgba_number": {
				name: "rgba",
				commas: true,
				coords: coordGrammarNumber
			},
			"hex": {
				type: "custom",
				toGamut: true,
				test: str => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),
				parse (str) {
					if (str.length <= 5) {
						// #rgb or #rgba, duplicate digits
						str = str.replace(/[a-f0-9]/gi, "$&$&");
					}

					let rgba = [];
					str.replace(/[a-f0-9]{2}/gi, component => {
						rgba.push(parseInt(component, 16) / 255);
					});

					return {
						spaceId: "srgb",
						coords: rgba.slice(0, 3),
						alpha: rgba.slice(3)[0]
					};
				},
				serialize: (coords, alpha, {
					collapse = true // collapse to 3-4 digit hex when possible?
				} = {}) => {
					if (alpha < 1) {
						coords.push(alpha);
					}

					coords = coords.map(c => Math.round(c * 255));

					let collapsible = collapse && coords.every(c => c % 17 === 0);

					let hex = coords.map(c => {
						if (collapsible) {
							return (c/17).toString(16);
						}

						return c.toString(16).padStart(2, "0");
					}).join("");

					return "#" + hex;
				}
			},
			"keyword": {
				type: "custom",
				test: str => /^[a-z]+$/i.test(str),
				parse (str) {
					str = str.toLowerCase();
					let ret = {spaceId: "srgb", coords: null, alpha: 1};

					if (str === "transparent") {
						ret.coords = KEYWORDS.black;
						ret.alpha = 0;
					}
					else {
						ret.coords = KEYWORDS[str];
					}

					if (ret.coords) {
						return ret;
					}
				}
			},
		}
	});

	var P3 = new RGBColorSpace({
		id: "p3",
		name: "P3",
		base: P3Linear,
		// Gamma encoding/decoding is the same as sRGB
		fromBase: sRGB.fromBase,
		toBase: sRGB.toBase,
		formats: {
			color: {
				id: "display-p3",
			}
		},
	});

	// Default space for CSS output. Code in Color.js makes this wider if there's a DOM available
	defaults.display_space = sRGB;

	if (typeof CSS !== "undefined" && CSS.supports) {
		// Find widest supported color space for CSS
		for (let space of [lab, REC2020, P3]) {
			let coords = space.getMinCoords();
			let color = {space, coords, alpha: 1};
			let str = serialize$1(color);

			if (CSS.supports("color", str)) {
				defaults.display_space = space;
				break;
			}
		}
	}

	/**
	 * Returns a serialization of the color that can actually be displayed in the browser.
	 * If the default serialization can be displayed, it is returned.
	 * Otherwise, the color is converted to Lab, REC2020, or P3, whichever is the widest supported.
	 * In Node.js, this is basically equivalent to `serialize()` but returns a `String` object instead.
	 *
	 * @export
	 * @param {{space, coords} | Color | string} color
	 * @param {*} [options={}] Options to be passed to serialize()
	 * @param {ColorSpace | string} [options.space = defaults.display_space] Color space to use for serialization if default is not supported
	 * @returns {String} String object containing the serialized color with a color property containing the converted color (or the original, if no conversion was necessary)
	 */
	function display (color, {space = defaults.display_space, ...options} = {}) {
		let ret = serialize$1(color, options);

		if (typeof CSS === "undefined" || CSS.supports("color", ret) || !defaults.display_space) {
			ret = new String(ret);
			ret.color = color;
		}
		else {
			// If we're here, what we were about to output is not supported
			// Fall back to fallback space
			let fallbackColor = to(color, space);
			ret = new String(serialize$1(fallbackColor, options));
			ret.color = fallbackColor;
		}

		return ret;
	}

	/**
	 * Euclidean distance of colors in an arbitrary color space
	 */
	function distance (color1, color2, space = "lab") {
		space = ColorSpace.get(space);

		let coords1 = space.from(color1);
		let coords2 = space.from(color2);

		return Math.sqrt(coords1.reduce((acc, c1, i) => {
			let c2 = coords2[i];
			if (isNaN(c1) || isNaN(c2)) {
				return acc;
			}

			return acc + (c2 - c1) ** 2;
		}, 0));
	}

	function equals (color1, color2) {
		color1 = getColor(color1);
		color2 = getColor(color2);

		return color1.space === color2.space
			   && color1.alpha === color2.alpha
			   && color1.coords.every((c, i) => c === color2.coords[i]);
	}

	/**
	 * Relative luminance
	 */

	function getLuminance (color) {
		return get(color, [XYZ_D65, "y"]);
	}

	function setLuminance (color, value) {
		set(color, [XYZ_D65, "y"], value);
	}

	function register$2 (Color) {
		Object.defineProperty(Color.prototype, "luminance", {
			get () {
				return getLuminance(this);
			},
			set (value) {
				setLuminance(this, value);
			}
		});
	}

	var luminance = /*#__PURE__*/Object.freeze({
		__proto__: null,
		getLuminance: getLuminance,
		register: register$2,
		setLuminance: setLuminance
	});

	// WCAG 2.0 contrast https://www.w3.org/TR/WCAG20-TECHS/G18.html
	// Simple contrast, with fixed 5% viewing flare contribution
	// Symmetric, does not matter which is foreground and which is background


	function contrastWCAG21 (color1, color2) {
		color1 = getColor(color1);
		color2 = getColor(color2);

		let Y1 = Math.max(getLuminance(color1), 0);
		let Y2 = Math.max(getLuminance(color2), 0);

		if (Y2 > Y1) {
			[Y1, Y2] = [Y2, Y1];
		}

		return (Y1 + .05) / (Y2 + .05);
	}

	// APCA 0.0.98G
	// https://github.com/Myndex/apca-w3
	// see also https://github.com/w3c/silver/issues/643


	// exponents
	const normBG = 0.56;
	const normTXT = 0.57;
	const revTXT = 0.62;
	const revBG = 0.65;

	// clamps
	const blkThrs = 0.022;
	const blkClmp = 1.414;
	const loClip = 0.1;
	const deltaYmin = 0.0005;

	// scalers
	// see https://github.com/w3c/silver/issues/645
	const scaleBoW = 1.14;
	const loBoWoffset = 0.027;
	const scaleWoB= 1.14;

	function fclamp (Y) {
		if (Y >= blkThrs) {
			return Y;
		}
		return Y + (blkThrs - Y) ** blkClmp;
	}

	function linearize (val) {
		let sign = val < 0? -1 : 1;
		let abs = Math.abs(val);
		return sign * Math.pow(abs, 2.4);
	}

	// Not symmetric, requires a foreground (text) color, and a background color
	function contrastAPCA (background, foreground) {
		foreground = getColor(foreground);
		background = getColor(background);

		let S;
		let C;
		let Sapc;

		// Myndex as-published, assumes sRGB inputs
		let R, G, B;

		foreground = to(foreground, "srgb");
		// Should these be clamped to in-gamut values?

		// Calculates "screen luminance" with non-standard simple gamma EOTF
		// weights should be from CSS Color 4, not the ones here which are via Myndex and copied from Lindbloom
		[R, G, B] = foreground.coords;
		let lumTxt = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.0721750;

		background = to(background, "srgb");
		[R, G, B] = background.coords;
		let lumBg = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.0721750;

		// toe clamping of very dark values to account for flare
		let Ytxt = fclamp(lumTxt);
		let Ybg = fclamp(lumBg);

		// are we "Black on White" (dark on light), or light on dark?
		let BoW = Ybg > Ytxt;

		// why is this a delta, when Y is not perceptually uniform?
		// Answer: it is a noise gate, see
		// https://github.com/LeaVerou/color.js/issues/208
		if (Math.abs(Ybg - Ytxt) < deltaYmin) {
			C = 0;
		}
		else {
			if (BoW) {
				// dark text on light background
				S = Ybg ** normBG - Ytxt ** normTXT;
				C = S * scaleBoW;
			}
			else {
				// light text on dark background
				S = Ybg ** revBG - Ytxt ** revTXT;
				C = S * scaleWoB;
			}
		}
		if (Math.abs(C) < loClip) {
			Sapc = 0;
		}
		else if (C > 0) {
			// not clear whether Woffset is loBoWoffset or loWoBoffset
			// but they have the same value
			Sapc = C - loBoWoffset;
		}
		else {
			Sapc = C + loBoWoffset;
		}

		return Sapc * 100;
	}

	// Michelson  luminance contrast
	// the relation between the spread and the sum of the two luminances
	// Symmetric, does not matter which is foreground and which is background
	// No black level compensation for flare.


	function contrastMichelson (color1, color2) {
		color1 = getColor(color1);
		color2 = getColor(color2);

		let Y1 = Math.max(getLuminance(color1), 0);
		let Y2 = Math.max(getLuminance(color2), 0);

		if (Y2 > Y1) {
			[Y1, Y2] = [Y2, Y1];
		}

		let denom = (Y1 + Y2);
		return denom === 0 ? 0 : (Y1 - Y2) / denom;
	}

	// Weber luminance contrast
	// The difference between the two luminances divided by the lower luminance
	// Symmetric, does not matter which is foreground and which is background
	// No black level compensation for flare.


	// the darkest sRGB color above black is #000001 and this produces
	// a plain Weber contrast of ~45647.
	// So, setting the divide-by-zero result at 50000 is a reasonable
	// max clamp for the plain Weber
	const max = 50000;

	function contrastWeber (color1, color2) {
		color1 = getColor(color1);
		color2 = getColor(color2);

		let Y1 = Math.max(getLuminance(color1), 0);
		let Y2 = Math.max(getLuminance(color2), 0);

		if (Y2 > Y1) {
			[Y1, Y2] = [Y2, Y1];
		}

		return Y2 === 0 ? max : (Y1 - Y2) / Y2;
	}

	// CIE Lightness difference, as used by Google Material Design
	// Google HCT Tone is the same as CIE Lightness
	// https://material.io/blog/science-of-color-design


	function contrastLstar (color1, color2) {
		color1 = getColor(color1);
		color2 = getColor(color2);

		let L1 = get(color1, [lab, "l"]);
		let L2 = get(color2, [lab, "l"]);

		return Math.abs(L1 - L2);
	}

	// κ * ε  = 2^3 = 8
	const ε$1 = 216/24389;  // 6^3/29^3 == (24/116)^3
	const ε3 = 24/116;
	const κ = 24389/27;   // 29^3/3^3

	let white = WHITES.D65;

	var lab_d65 = new ColorSpace({
		id: "lab-d65",
		name: "Lab D65",
		coords: {
			l: {
				refRange: [0, 100],
				name: "L"
			},
			a: {
				refRange: [-125, 125]
			},
			b: {
				refRange: [-125, 125]
			}
		},

		// Assuming XYZ is relative to D65, convert to CIE Lab
		// from CIE standard, which now defines these as a rational fraction
		white,

		base: XYZ_D65,
		// Convert D65-adapted XYZ to Lab
		//  CIE 15.3:2004 section 8.2.1.1
		fromBase (XYZ) {
			// compute xyz, which is XYZ scaled relative to reference white
			let xyz = XYZ.map((value, i) => value / white[i]);

			// now compute f
			let f = xyz.map(value => value > ε$1 ? Math.cbrt(value) : (κ * value + 16)/116);

			return [
				(116 * f[1]) - 16, 	 // L
				500 * (f[0] - f[1]), // a
				200 * (f[1] - f[2])  // b
			];
		},
		// Convert Lab to D65-adapted XYZ
		// Same result as CIE 15.3:2004 Appendix D although the derivation is different
		// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
		toBase (Lab) {
			// compute f, starting with the luminance-related term
			let f = [];
			f[1] = (Lab[0] + 16)/116;
			f[0] = Lab[1]/500 + f[1];
			f[2] = f[1] - Lab[2]/200;

			// compute xyz
			let xyz = [
				f[0]   > ε3  ?  Math.pow(f[0], 3)            : (116*f[0]-16)/κ,
				Lab[0] > 8   ?  Math.pow((Lab[0]+16)/116, 3) : Lab[0]/κ,
				f[2]   > ε3  ?  Math.pow(f[2], 3)            : (116*f[2]-16)/κ
			];

			// Compute XYZ by scaling xyz by reference white
			return xyz.map((value, i) => value * white[i]);
		},

		formats: {
			"lab-d65": {
				coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"],
			}
		}
	});

	// Delta Phi Star perceptual lightness contrast
	// See https://github.com/Myndex/deltaphistar
	// The (difference between two Lstars each raised to phi) raised to (1/phi)
	// Symmetric, does not matter which is foreground and which is background


	const phi = Math.pow(5, 0.5) * 0.5 + 0.5; // Math.phi can be used if Math.js

	function contrastDeltaPhi (color1, color2) {
		color1 = getColor(color1);
		color2 = getColor(color2);

		let Lstr1 = get(color1, [lab_d65, "l"]);
		let Lstr2 = get(color2, [lab_d65, "l"]);

		let deltaPhiStar = Math.abs(Math.pow(Lstr1, phi) - Math.pow(Lstr2, phi));

		let contrast = Math.pow(deltaPhiStar, (1 / phi)) * Math.SQRT2 - 40;

		return (contrast < 7.5) ? 0.0 : contrast ;
	}

	var contrastMethods = /*#__PURE__*/Object.freeze({
		__proto__: null,
		contrastAPCA: contrastAPCA,
		contrastDeltaPhi: contrastDeltaPhi,
		contrastLstar: contrastLstar,
		contrastMichelson: contrastMichelson,
		contrastWCAG21: contrastWCAG21,
		contrastWeber: contrastWeber
	});

	function contrast (background, foreground, o = {}) {
		if (isString(o)) {
			o = {algorithm: o};
		}

		let {algorithm, ...rest} = o;

		if (!algorithm) {
			let algorithms = Object.keys(contrastMethods).map(a => a.replace(/^contrast/, "")).join(", ");
			throw new TypeError(`contrast() function needs a contrast algorithm. Please specify one of: ${algorithms}`);
		}

		background = getColor(background);
		foreground = getColor(foreground);

		for (let a in contrastMethods) {
			if ("contrast" + algorithm.toLowerCase() === a.toLowerCase()) {
				return contrastMethods[a](background, foreground, rest);
			}
		}

		throw new TypeError(`Unknown contrast algorithm: ${algorithm}`);
	}

	// Chromaticity coordinates
	function uv (color) {
		let [X, Y, Z] = getAll(color, XYZ_D65);
		let denom = X + 15 * Y + 3 * Z;
		return [4 * X / denom, 9 * Y / denom];
	}

	function xy (color) {
		let [X, Y, Z] = getAll(color, XYZ_D65);
		let  sum = X + Y + Z;
		return [X / sum, Y / sum];
	}

	function register$1 (Color) {
		// no setters, as lightness information is lost
		// when converting color to chromaticity
		Object.defineProperty(Color.prototype, "uv", {
			get () {
				return uv(this);
			}
		});

		Object.defineProperty(Color.prototype, "xy", {
			get () {
				return xy(this);
			}
		});
	}

	var chromaticity = /*#__PURE__*/Object.freeze({
		__proto__: null,
		register: register$1,
		uv: uv,
		xy: xy
	});

	function deltaE76 (color, sample) {
		return distance(color, sample, "lab");
	}

	// More accurate color-difference formulae
	// than the simple 1976 Euclidean distance in Lab

	// CMC by the Color Measurement Committee of the
	// Bradford Society of Dyeists and Colorsts, 1994.
	// Uses LCH rather than Lab,
	// with different weights for L, C and H differences
	// A nice increase in accuracy for modest increase in complexity
	const π = Math.PI;
	const d2r = π / 180;

	function deltaECMC (color, sample, {l = 2, c = 1} = {}) {
		// Given this color as the reference
		// and a sample,
		// calculate deltaE CMC.

		// This implementation assumes the parametric
		// weighting factors l:c are 2:1
		// which is typical for non-textile uses.

		let [L1, a1, b1] = lab.from(color);
		let [, C1, H1] = lch.from(lab, [L1, a1, b1]);
		let [L2, a2, b2] = lab.from(sample);
		let C2 = lch.from(lab, [L2, a2, b2])[1];

		// let [L1, a1, b1] = color.getAll(lab);
		// let C1 = color.get("lch.c");
		// let H1 = color.get("lch.h");
		// let [L2, a2, b2] = sample.getAll(lab);
		// let C2 = sample.get("lch.c");

		// Check for negative Chroma,
		// which might happen through
		// direct user input of LCH values

		if (C1 < 0) {
			C1 = 0;
		}
		if (C2 < 0) {
			C2 = 0;
		}

		// we don't need H2 as ΔH is calculated from Δa, Δb and ΔC

		// Lightness and Chroma differences
		// These are (color - sample), unlike deltaE2000
		let ΔL = L1 - L2;
		let ΔC = C1 - C2;

		let Δa = a1 - a2;
		let Δb = b1 - b2;

		// weighted Hue difference, less for larger Chroma difference

		let H2 = (Δa ** 2) + (Δb ** 2) - (ΔC ** 2);
		// due to roundoff error it is possible that, for zero a and b,
		// ΔC > Δa + Δb is 0, resulting in attempting
		// to take the square root of a negative number

		// trying instead the equation from Industrial Color Physics
		// By Georg A. Klein

		// let ΔH = ((a1 * b2) - (a2 * b1)) / Math.sqrt(0.5 * ((C2 * C1) + (a2 * a1) + (b2 * b1)));
		// console.log({ΔH});
		// This gives the same result to 12 decimal places
		// except it sometimes NaNs when trying to root a negative number

		// let ΔH = Math.sqrt(H2); we never actually use the root, it gets squared again!!

		// positional corrections to the lack of uniformity of CIELAB
		// These are all trying to make JND ellipsoids more like spheres

		// SL Lightness crispening factor, depends entirely on L1 not L2
		let SL = 0.511;	// linear portion of the Y to L transfer function
		if (L1 >= 16) {	// cubic portion
			SL = (0.040975 * L1) / (1 + 0.01765 * L1);
		}

		// SC Chroma factor
		let SC = ((0.0638 * C1) / (1 + 0.0131 * C1)) + 0.638;

		// Cross term T for blue non-linearity
		let T;
		if ( Number.isNaN(H1)) {
			H1 = 0;
		}

		if (H1 >= 164 && H1 <= 345) {
			T = 0.56 + Math.abs(0.2 * Math.cos((H1 + 168) * d2r));
		}
		else {
			T = 0.36 + Math.abs(0.4 * Math.cos((H1 + 35) * d2r));
		}
		// console.log({T});

		// SH Hue factor also depends on C1,
		let C4 = Math.pow(C1, 4);
		let F = Math.sqrt(C4 / (C4 + 1900));
		let SH = SC * ((F * T) + 1 - F);

		// Finally calculate the deltaE, term by term as root sume of squares
		let dE = (ΔL / (l * SL)) ** 2;
		dE += (ΔC / (c * SC)) ** 2;
		dE += (H2 / (SH ** 2));
		// dE += (ΔH / SH)  ** 2;
		return Math.sqrt(dE);
		// Yay!!!
	}

	const Yw$1 = 203;	// absolute luminance of media white

	var XYZ_Abs_D65 = new ColorSpace({
	// Absolute CIE XYZ, with a D65 whitepoint,
	// as used in most HDR colorspaces as a starting point.
	// SDR spaces are converted per BT.2048
	// so that diffuse, media white is 203 cd/m²
		id: "xyz-abs-d65",
		name: "Absolute XYZ D65",
		coords: {
			x: {
				refRange: [0, 9504.7],
				name: "Xa",
			},
			y: {
				refRange: [0, 10000],
				name: "Ya",
			},
			z: {
				refRange: [0, 10888.3],
				name: "Za",
			}
		},

		base: XYZ_D65,
		fromBase (XYZ) {
			// Make XYZ absolute, not relative to media white
			// Maximum luminance in PQ is 10,000 cd/m²
			// Relative XYZ has Y=1 for media white
			return XYZ.map (v => Math.max(v * Yw$1, 0));
		},
		toBase (AbsXYZ) {
			// Convert to media-white relative XYZ
			return AbsXYZ.map(v => Math.max(v / Yw$1, 0));
		}
	});

	const b$1 = 1.15;
	const g = 0.66;
	const n$1 = 2610 / (2 ** 14);
	const ninv$1 = (2 ** 14) / 2610;
	const c1$2 = 3424 / (2 ** 12);
	const c2$2 = 2413 / (2 ** 7);
	const c3$2 = 2392 / (2 ** 7);
	const p = 1.7 * 2523 / (2 ** 5);
	const pinv = (2 ** 5) / (1.7 * 2523);
	const d = -0.56;
	const d0 = 1.6295499532821566E-11;

	const XYZtoCone_M = [
		[  0.41478972, 0.579999,  0.0146480 ],
		[ -0.2015100,  1.120649,  0.0531008 ],
		[ -0.0166008,  0.264800,  0.6684799 ]
	];
	// XYZtoCone_M inverted
	const ConetoXYZ_M = [
		[  1.9242264357876067,  -1.0047923125953657,  0.037651404030618   ],
		[  0.35031676209499907,  0.7264811939316552, -0.06538442294808501 ],
		[ -0.09098281098284752, -0.3127282905230739,  1.5227665613052603  ]
	];
	const ConetoIab_M = [
		[  0.5,       0.5,       0        ],
		[  3.524000, -4.066708,  0.542708 ],
		[  0.199076,  1.096799, -1.295875 ]
	];
	// ConetoIab_M inverted
	const IabtoCone_M = [
		[ 1,                   0.1386050432715393,   0.05804731615611886 ],
		[ 0.9999999999999999, -0.1386050432715393,  -0.05804731615611886 ],
		[ 0.9999999999999998, -0.09601924202631895, -0.8118918960560388  ]
	];

	var Jzazbz = new ColorSpace({
		id: "jzazbz",
		name: "Jzazbz",
		coords: {
			jz: {
				refRange: [0, 1],
				name: "Jz",
			},
			az: {
				refRange: [-0.5, 0.5],
			},
			bz: {
				refRange: [-0.5, 0.5],
			}
		},

		base: XYZ_Abs_D65,
		fromBase (XYZ) {
			// First make XYZ absolute, not relative to media white
			// Maximum luminance in PQ is 10,000 cd/m²
			// Relative XYZ has Y=1 for media white
			// BT.2048 says media white Y=203 at PQ 58

			let [ Xa, Ya, Za ] = XYZ;

			// modify X and Y
			let Xm = (b$1 * Xa) - ((b$1 - 1) * Za);
			let Ym = (g * Ya) - ((g - 1) * Xa);

			// move to LMS cone domain
			let LMS = multiplyMatrices(XYZtoCone_M, [ Xm, Ym, Za ]);

			// PQ-encode LMS
			let PQLMS = LMS.map (function (val) {
				let num = c1$2 + (c2$2 * ((val / 10000) ** n$1));
				let denom = 1 + (c3$2 * ((val / 10000) ** n$1));

				return (num / denom)  ** p;
			});

			// almost there, calculate Iz az bz
			let [ Iz, az, bz] = multiplyMatrices(ConetoIab_M, PQLMS);
			// console.log({Iz, az, bz});

			let Jz = ((1 + d) * Iz) / (1 + (d * Iz)) - d0;
			return [Jz, az, bz];
		},
		toBase (Jzazbz) {
			let [Jz, az, bz] = Jzazbz;
			let Iz = (Jz + d0) / (1 + d - d * (Jz + d0));

			// bring into LMS cone domain
			let PQLMS = multiplyMatrices(IabtoCone_M, [ Iz, az, bz ]);

			// convert from PQ-coded to linear-light
			let LMS = PQLMS.map(function (val) {
				let num = (c1$2 - (val ** pinv));
				let denom = (c3$2 * (val ** pinv)) - c2$2;
				let x = 10000 * ((num / denom) ** ninv$1);

				return (x); 	// luminance relative to diffuse white, [0, 70 or so].
			});

			// modified abs XYZ
			let [ Xm, Ym, Za ] = multiplyMatrices(ConetoXYZ_M, LMS);

			// restore standard D50 relative XYZ, relative to media white
			let Xa = (Xm + ((b$1 -1) * Za)) / b$1;
			let Ya = (Ym + ((g -1) * Xa)) / g;
			return [ Xa, Ya, Za ];
		},

		formats: {
			// https://drafts.csswg.org/css-color-hdr/#Jzazbz
			"color": {}
		}
	});

	var jzczhz = new ColorSpace({
		id: "jzczhz",
		name: "JzCzHz",
		coords: {
			jz: {
				refRange: [0, 1],
				name: "Jz",
			},
			cz: {
				refRange: [0, 1],
				name: "Chroma",
			},
			hz: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue",
			}
		},

		base: Jzazbz,
		fromBase (jzazbz) {
			// Convert to polar form
			let [Jz, az, bz] = jzazbz;
			let hue;
			const ε = 0.0002; // chromatic components much smaller than a,b

			if (Math.abs(az) < ε && Math.abs(bz) < ε) {
				hue = NaN;
			}
			else {
				hue = Math.atan2(bz, az) * 180 / Math.PI;
			}

			return [
				Jz, // Jz is still Jz
				Math.sqrt(az ** 2 + bz ** 2), // Chroma
				constrain(hue) // Hue, in degrees [0 to 360)
			];
		},
		toBase (jzczhz) {
			// Convert from polar form
			// debugger;
			return [
				jzczhz[0], // Jz is still Jz
				jzczhz[1] * Math.cos(jzczhz[2] * Math.PI / 180), // az
				jzczhz[1] * Math.sin(jzczhz[2] * Math.PI / 180)  // bz
			];
		},
		formats: {
			color: {}
		},
	});

	// More accurate color-difference formulae
	// than the simple 1976 Euclidean distance in Lab

	// Uses JzCzHz, which has improved perceptual uniformity
	// and thus a simple Euclidean root-sum of ΔL² ΔC² ΔH²
	// gives good results.

	function deltaEJz (color, sample) {
		// Given this color as the reference
		// and a sample,
		// calculate deltaE in JzCzHz.
		let [Jz1, Cz1, Hz1] = jzczhz.from(color);
		let [Jz2, Cz2, Hz2] = jzczhz.from(sample);

		// Lightness and Chroma differences
		// sign does not matter as they are squared.
		let ΔJ = Jz1 - Jz2;
		let ΔC = Cz1 - Cz2;

		// length of chord for ΔH
		if ((Number.isNaN(Hz1)) && (Number.isNaN(Hz2))) {
			// both undefined hues
			Hz1 = 0;
			Hz2 = 0;
		}
		else if (Number.isNaN(Hz1)) {
			// one undefined, set to the defined hue
			Hz1 = Hz2;
		}
		else if (Number.isNaN(Hz2)) {
			Hz2 = Hz1;
		}

		let Δh = Hz1 - Hz2;
		let ΔH = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin((Δh / 2) * (Math.PI / 180));

		return Math.sqrt(ΔJ ** 2 + ΔC ** 2 + ΔH ** 2);
	}

	const c1$1 = 3424 / 4096;
	const c2$1 = 2413 / 128;
	const c3$1 = 2392 / 128;
	const m1 = 2610 / 16384;
	const m2 = 2523 / 32;
	const im1 = 16384 / 2610;
	const im2 = 32 / 2523;

	// The matrix below includes the 4% crosstalk components
	// and is from the Dolby "What is ICtCp" paper"
	const XYZtoLMS_M$1 = [
		[ 0.3592,  0.6976, -0.0358],
		[-0.1922,  1.1004,  0.0755],
		[ 0.0070,  0.0749,  0.8434]
	];
	// linear-light Rec.2020 to LMS, again with crosstalk
	// rational terms from Jan Fröhlich,
	// Encoding High Dynamic Range andWide Color Gamut Imagery, p.97
	// and ITU-R BT.2124-0 p.2
	/*
	const Rec2020toLMS_M = [
		[ 1688 / 4096,  2146 / 4096,   262 / 4096 ],
		[  683 / 4096,  2951 / 4096,   462 / 4096 ],
		[   99 / 4096,   309 / 4096,  3688 / 4096 ]
	];
	*/
	// this includes the Ebner LMS coefficients,
	// the rotation, and the scaling to [-0.5,0.5] range
	// rational terms from Fröhlich p.97
	// and ITU-R BT.2124-0 pp.2-3
	const LMStoIPT_M = [
		[  2048 / 4096,   2048 / 4096,       0      ],
		[  6610 / 4096, -13613 / 4096,  7003 / 4096 ],
		[ 17933 / 4096, -17390 / 4096,  -543 / 4096 ]
	];

	// inverted matrices, calculated from the above
	const IPTtoLMS_M = [
		[0.99998889656284013833, 0.00860505014728705821,  0.1110343715986164786 ],
		[1.0000111034371598616, -0.00860505014728705821, -0.1110343715986164786 ],
		[1.000032063391005412,   0.56004913547279000113, -0.32063391005412026469],
	];
	/*
	const LMStoRec2020_M = [
		[ 3.4375568932814012112,   -2.5072112125095058195,   0.069654319228104608382],
		[-0.79142868665644156125,   1.9838372198740089874,  -0.19240853321756742626 ],
		[-0.025646662911506476363, -0.099240248643945566751, 1.1248869115554520431  ]
	];
	*/
	const LMStoXYZ_M$1 = [
		[ 2.0701800566956135096,   -1.3264568761030210255,    0.20661600684785517081 ],
		[ 0.36498825003265747974,   0.68046736285223514102,  -0.045421753075853231409],
		[-0.049595542238932107896, -0.049421161186757487412,  1.1879959417328034394  ]
	];

	// Only the PQ form of ICtCp is implemented here. There is also an HLG form.
	// from Dolby, "WHAT IS ICTCP?"
	// https://professional.dolby.com/siteassets/pdfs/ictcp_dolbywhitepaper_v071.pdf
	// and
	// Dolby, "Perceptual Color Volume
	// Measuring the Distinguishable Colors of HDR and WCG Displays"
	// https://professional.dolby.com/siteassets/pdfs/dolby-vision-measuring-perceptual-color-volume-v7.1.pdf
	var ictcp = new ColorSpace({
		id: "ictcp",
		name: "ICTCP",
		// From BT.2100-2 page 7:
		// During production, signal values are expected to exceed the
		// range E′ = [0.0 : 1.0]. This provides processing headroom and avoids
		// signal degradation during cascaded processing. Such values of E′,
		// below 0.0 or exceeding 1.0, should not be clipped during production
		// and exchange.
		// Values below 0.0 should not be clipped in reference displays (even
		// though they represent “negative” light) to allow the black level of
		// the signal (LB) to be properly set using test signals known as “PLUGE”
		coords: {
			i: {
				refRange: [0, 1],	// Constant luminance,
				name: "I"
			},
			ct: {
				refRange: [-0.5, 0.5],	// Full BT.2020 gamut in range [-0.5, 0.5]
				name: "CT"
			},
			cp: {
				refRange: [-0.5, 0.5],
				name: "CP"
			}
		},

		base: XYZ_Abs_D65,
		fromBase (XYZ) {
			// move to LMS cone domain
			let LMS = multiplyMatrices(XYZtoLMS_M$1, XYZ);

			return LMStoICtCp(LMS);
		},
		toBase (ICtCp) {
			let LMS = ICtCptoLMS(ICtCp);

			return multiplyMatrices(LMStoXYZ_M$1, LMS);
		},
		formats: {
			color: {}
		},
	});

	function LMStoICtCp (LMS) {
		// apply the PQ EOTF
		// we can't ever be dividing by zero because of the "1 +" in the denominator
		let PQLMS = LMS.map (function (val) {
			let num = c1$1 + (c2$1 * ((val / 10000) ** m1));
			let denom = 1 + (c3$1 * ((val / 10000) ** m1));

			return (num / denom)  ** m2;
		});

		// LMS to IPT, with rotation for Y'C'bC'r compatibility
		return multiplyMatrices(LMStoIPT_M, PQLMS);
	}

	function ICtCptoLMS (ICtCp) {
		let PQLMS = multiplyMatrices(IPTtoLMS_M, ICtCp);

		// From BT.2124-0 Annex 2 Conversion 3
		let LMS = PQLMS.map (function (val) {
			let num  = Math.max((val ** im2) - c1$1, 0);
			let denom = (c2$1 - (c3$1 * (val ** im2)));
			return 10000 * ((num / denom) ** im1);
		});

		return LMS;
	}

	// Delta E in ICtCp space,
	// which the ITU calls Delta E ITP, which is shorter
	// formulae from ITU Rec. ITU-R BT.2124-0

	function deltaEITP (color, sample) {
		// Given this color as the reference
		// and a sample,
		// calculate deltaE in ICtCp
		// which is simply the Euclidean distance

		let [ I1, T1, P1 ] = ictcp.from(color);
		let [ I2, T2, P2 ] = ictcp.from(sample);

		// the 0.25 factor is to undo the encoding scaling in Ct
		// the 720 is so that 1 deltaE = 1 JND
		// per  ITU-R BT.2124-0 p.3

		return 720 * Math.sqrt((I1 - I2) ** 2 + (0.25 * (T1 -T2) ** 2) + (P1 - P2) ** 2);
	}

	// Recalculated for consistent reference white
	// see https://github.com/w3c/csswg-drafts/issues/6642#issuecomment-943521484
	const XYZtoLMS_M = [
		[ 0.8190224432164319,    0.3619062562801221,   -0.12887378261216414 ],
		[ 0.0329836671980271,    0.9292868468965546,     0.03614466816999844 ],
		[ 0.048177199566046255,  0.26423952494422764,    0.6335478258136937  ]
	];
	// inverse of XYZtoLMS_M
	const LMStoXYZ_M = [
		[  1.2268798733741557,  -0.5578149965554813,   0.28139105017721583],
		[ -0.04057576262431372,  1.1122868293970594,  -0.07171106666151701],
		[ -0.07637294974672142, -0.4214933239627914,   1.5869240244272418 ]
	];
	const LMStoLab_M = [
		[  0.2104542553,   0.7936177850,  -0.0040720468 ],
		[  1.9779984951,  -2.4285922050,   0.4505937099 ],
		[  0.0259040371,   0.7827717662,  -0.8086757660 ]
	];
	// LMStoIab_M inverted
	const LabtoLMS_M = [
		[ 0.99999999845051981432,  0.39633779217376785678,   0.21580375806075880339  ],
		[ 1.0000000088817607767,  -0.1055613423236563494,   -0.063854174771705903402 ],
		[ 1.0000000546724109177,  -0.089484182094965759684, -1.2914855378640917399   ]
	];

	var OKLab = new ColorSpace({
		id: "oklab",
	    name: "Oklab",
	    coords: {
			l: {
				refRange: [0, 1],
				name: "L"
			},
			a: {
				refRange: [-0.4, 0.4]
			},
			b: {
				refRange: [-0.4, 0.4]
			}
	    },

		// Note that XYZ is relative to D65
	  white: "D65",
		base: XYZ_D65,
		fromBase (XYZ) {
			// move to LMS cone domain
			let LMS = multiplyMatrices(XYZtoLMS_M, XYZ);

			// non-linearity
			let LMSg = LMS.map(val => Math.cbrt(val));

			return multiplyMatrices(LMStoLab_M, LMSg);

		},
		toBase (OKLab) {
			// move to LMS cone domain
			let LMSg = multiplyMatrices(LabtoLMS_M, OKLab);

			// restore linearity
			let LMS = LMSg.map(val => val ** 3);

			return multiplyMatrices(LMStoXYZ_M, LMS);
		},

		formats: {
			"oklab": {
				coords: ["<percentage> | <number>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"],
			}
		}
	});

	// More accurate color-difference formulae
	// than the simple 1976 Euclidean distance in CIE Lab


	function deltaEOK (color, sample) {
		// Given this color as the reference
		// and a sample,
		// calculate deltaEOK, term by term as root sum of squares
		let [L1, a1, b1] = OKLab.from(color);
		let [L2, a2, b2] = OKLab.from(sample);
		let ΔL = L1 - L2;
		let Δa = a1 - a2;
		let Δb = b1 - b2;
		return Math.sqrt(ΔL ** 2 + Δa ** 2 + Δb ** 2);
	}

	var deltaEMethods = {
		deltaE76,
		deltaECMC,
		deltaE2000,
		deltaEJz,
		deltaEITP,
		deltaEOK,
	};

	function deltaE (c1, c2, o = {}) {
		if (isString(o)) {
			o = {method: o};
		}

		let {method = defaults.deltaE, ...rest} = o;

		c1 = getColor(c1);
		c2 = getColor(c2);

		for (let m in deltaEMethods) {
			if ("deltae" + method.toLowerCase() === m.toLowerCase()) {
				return deltaEMethods[m](c1, c2, rest);
			}
		}

		throw new TypeError(`Unknown deltaE method: ${method}`);
	}

	function lighten (color, amount = .25) {
		let space = ColorSpace.get("oklch", "lch");
		let lightness = [space, "l"];
		return set(color, lightness, l => l * (1 + amount));
	}

	function darken (color, amount = .25) {
		let space = ColorSpace.get("oklch", "lch");
		let lightness = [space, "l"];
		return set(color, lightness, l => l * (1 - amount));
	}

	var variations = /*#__PURE__*/Object.freeze({
		__proto__: null,
		darken: darken,
		lighten: lighten
	});

	/**
	 * Functions related to color interpolation
	 */

	/**
	 * Return an intermediate color between two colors
	 * Signatures: mix(c1, c2, p, options)
	 *             mix(c1, c2, options)
	 *             mix(color)
	 * @param {Color | string} c1 The first color
	 * @param {Color | string} [c2] The second color
	 * @param {number} [p=.5] A 0-1 percentage where 0 is c1 and 1 is c2
	 * @param {Object} [o={}]
	 * @return {Color}
	 */
	function mix (c1, c2, p = .5, o = {}) {
		[c1, c2] = [getColor(c1), getColor(c2)];

		if (type(p) === "object") {
			[p, o] = [.5, p];
		}

		let {space, outputSpace, premultiplied} = o;

		let r = range(c1, c2, {space, outputSpace, premultiplied});
		return r(p);
	}

	/**
	 *
	 * @param {Color | string | Function} c1 The first color or a range
	 * @param {Color | string} [c2] The second color if c1 is not a range
	 * @param {Object} [options={}]
	 * @return {Color[]}
	 */
	function steps (c1, c2, options = {}) {
		let colorRange;

		if (isRange(c1)) {
			// Tweaking existing range
			[colorRange, options] = [c1, c2];
			[c1, c2] = colorRange.rangeArgs.colors;
		}

		let {
			maxDeltaE, deltaEMethod,
			steps = 2, maxSteps = 1000,
			...rangeOptions
		} = options;

		if (!colorRange) {
			[c1, c2] = [getColor(c1), getColor(c2)];
			colorRange = range(c1, c2, rangeOptions);
		}

		let totalDelta = deltaE(c1, c2);
		let actualSteps = maxDeltaE > 0? Math.max(steps, Math.ceil(totalDelta / maxDeltaE) + 1) : steps;
		let ret = [];

		if (maxSteps !== undefined) {
			actualSteps = Math.min(actualSteps, maxSteps);
		}

		if (actualSteps === 1) {
			ret = [{p: .5, color: colorRange(.5)}];
		}
		else {
			let step = 1 / (actualSteps - 1);
			ret = Array.from({length: actualSteps}, (_, i) => {
				let p = i * step;
				return {p, color: colorRange(p)};
			});
		}

		if (maxDeltaE > 0) {
			// Iterate over all stops and find max deltaE
			let maxDelta = ret.reduce((acc, cur, i) => {
				if (i === 0) {
					return 0;
				}

				let ΔΕ = deltaE(cur.color, ret[i - 1].color, deltaEMethod);
				return Math.max(acc, ΔΕ);
			}, 0);

			while (maxDelta > maxDeltaE) {
				// Insert intermediate stops and measure maxDelta again
				// We need to do this for all pairs, otherwise the midpoint shifts
				maxDelta = 0;

				for (let i = 1; (i < ret.length) && (ret.length < maxSteps); i++) {
					let prev = ret[i - 1];
					let cur = ret[i];

					let p = (cur.p + prev.p) / 2;
					let color = colorRange(p);
					maxDelta = Math.max(maxDelta, deltaE(color, prev.color), deltaE(color, cur.color));
					ret.splice(i, 0, {p, color: colorRange(p)});
					i++;
				}
			}
		}

		ret = ret.map(a => a.color);

		return ret;
	}
	/**
	 * Interpolate to color2 and return a function that takes a 0-1 percentage
	 * @param {Color | string | Function} color1 The first color or an existing range
	 * @param {Color | string} [color2] If color1 is a color, this is the second color
	 * @param {Object} [options={}]
	 * @returns {Function} A function that takes a 0-1 percentage and returns a color
	 */
	function range (color1, color2, options = {}) {
		if (isRange(color1)) {
			// Tweaking existing range
			let [r, options] = [color1, color2];

			return range(...r.rangeArgs.colors, {...r.rangeArgs.options, ...options});
		}

		let {space, outputSpace, progression, premultiplied} = options;

		color1 = getColor(color1);
		color2 = getColor(color2);

		// Make sure we're working on copies of these colors
		color1 = clone(color1);
		color2 = clone(color2);

		let rangeArgs = {colors: [color1, color2], options};

		if (space) {
			space = ColorSpace.get(space);
		}
		else {
			space = ColorSpace.registry[defaults.interpolationSpace] || color1.space;
		}

		outputSpace = outputSpace? ColorSpace.get(outputSpace) : space;

		color1 = to(color1, space);
		color2 = to(color2, space);

		// Gamut map to avoid areas of flat color
		color1 = toGamut(color1);
		color2 = toGamut(color2);

		// Handle hue interpolation
		// See https://github.com/w3c/csswg-drafts/issues/4735#issuecomment-635741840
		if (space.coords.h && space.coords.h.type === "angle") {
			let arc = options.hue = options.hue || "shorter";

			let hue = [space, "h"];
			let [θ1, θ2] = [get(color1, hue), get(color2, hue)];
			[θ1, θ2] = adjust(arc, [θ1, θ2]);
			set(color1, hue, θ1);
			set(color2, hue, θ2);
		}

		if (premultiplied) {
			// not coping with polar spaces yet
			color1.coords = color1.coords.map(c => c * color1.alpha);
			color2.coords = color2.coords.map(c => c * color2.alpha);
		}

		return Object.assign(p => {
			p = progression? progression(p) : p;
			let coords = color1.coords.map((start, i) => {
				let end = color2.coords[i];
				return interpolate(start, end, p);
			});

			let alpha = interpolate(color1.alpha, color2.alpha, p);
			let ret = {space, coords, alpha};

			if (premultiplied) {
				// undo premultiplication
				ret.coords = ret.coords.map(c => c / alpha);
			}

			if (outputSpace !== space) {
				ret = to(ret, outputSpace);
			}

			return ret;
		}, {
			rangeArgs
		});
	}
	function isRange (val) {
		return type(val) === "function" && !!val.rangeArgs;
	}
	defaults.interpolationSpace = "lab";

	function register (Color) {
		Color.defineFunction("mix", mix, {returns: "color"});
		Color.defineFunction("range", range, {returns: "function<color>"});
		Color.defineFunction("steps", steps, {returns: "array<color>"});
	}

	var interpolation = /*#__PURE__*/Object.freeze({
		__proto__: null,
		isRange: isRange,
		mix: mix,
		range: range,
		register: register,
		steps: steps
	});

	var HSL = new ColorSpace({
		id: "hsl",
		name: "HSL",
		coords: {
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			},
			s: {
				range: [0, 100],
				name: "Saturation"
			},
			l: {
				range: [0, 100],
				name: "Lightness"
			}
		},

		base: sRGB,

		// Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB
		fromBase: rgb => {
			let max = Math.max(...rgb);
			let min = Math.min(...rgb);
			let [r, g, b] = rgb;
			let [h, s, l] = [NaN, 0, (min + max)/2];
			let d = max - min;

			if (d !== 0) {
				s = (l === 0 || l === 1) ? 0 : (max - l) / Math.min(l, 1 - l);

				switch (max) {
					case r: h = (g - b) / d + (g < b ? 6 : 0); break;
					case g: h = (b - r) / d + 2; break;
					case b: h = (r - g) / d + 4;
				}

				h = h * 60;
			}

			return [h, s * 100, l * 100];
		},

		// Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative
		toBase: hsl => {
			let [h, s, l] = hsl;
			h = h % 360;

			if (h < 0) {
				h += 360;
			}

			s /= 100;
			l /= 100;

			function f (n) {
				let k = (n + h/30) % 12;
				let a = s * Math.min(l, 1 - l);
				return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));
			}

			return [f(0), f(8), f(4)];
		},

		formats: {
			"hsl": {
				toGamut: true,
				coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
			},
			"hsla": {
				coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
				commas: true,
				lastAlpha: true,
			}
		},
	});

	// The Hue, Whiteness Blackness (HWB) colorspace
	// See https://drafts.csswg.org/css-color-4/#the-hwb-notation
	// Note that, like HSL, calculations are done directly on
	// gamma-corrected sRGB values rather than linearising them first.

	var HSV = new ColorSpace({
		id: "hsv",
		name: "HSV",
		coords: {
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			},
			s: {
				range: [0, 100],
				name: "Saturation"
			},
			v: {
				range: [0, 100],
				name: "Value"
			}
		},

		base: HSL,
		// https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion
		fromBase (hsl) {
			let [h, s, l] = hsl;
			s /= 100;
			l /= 100;

			let v = l + s * Math.min(l, 1 - l);

			return [
				h, // h is the same
				v === 0? 0 : 200 * (1 - l / v), // s
				100 * v
			];
		},
		// https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion
		toBase (hsv) {
			let [h, s, v] = hsv;

			s /= 100;
			v /= 100;

			let l = v * (1 - s/2);

			return [
				h, // h is the same
				(l === 0 || l === 1)? 0 : ((v - l) / Math.min(l, 1 - l)) * 100,
				l * 100
			];
		},
		formats: {
			color: {
				toGamut: true,
			}
		}
	});

	// The Hue, Whiteness Blackness (HWB) colorspace
	// See https://drafts.csswg.org/css-color-4/#the-hwb-notation
	// Note that, like HSL, calculations are done directly on
	// gamma-corrected sRGB values rather than linearising them first.

	var hwb = new ColorSpace({
		id: "hwb",
		name: "HWB",
		coords: {
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			},
			w: {
				range: [0, 100],
				name: "Whiteness"
			},
			b: {
				range: [0, 100],
				name: "Blackness"
			}
		},

		base: HSV,
		fromBase (hsv) {
			let [h, s, v] = hsv;

			return [h, v * (100 - s) / 100, 100 - v];
		},
		toBase (hwb) {
			let [h, w, b] = hwb;

			// Now convert percentages to [0..1]
			w /= 100;
			b /= 100;

			// Achromatic check (white plus black >= 1)
			let sum = w + b;
			if (sum >= 1) {
				 let gray = w / sum;
				 return [h, 0, gray * 100];
			}

			let v = (1 - b);
			let s = (v === 0) ? 0 : 1 - w / v;
			return [h, s * 100, v * 100];
		},

		formats: {
			"hwb": {
				toGamut: true,
				coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
			}
		}
	});

	// convert an array of linear-light a98-rgb values to CIE XYZ
	// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
	// has greater numerical precision than section 4.3.5.3 of
	// https://www.adobe.com/digitalimag/pdfs/AdobeRGB1998.pdf
	// but the values below were calculated from first principles
	// from the chromaticity coordinates of R G B W
	const toXYZ_M$2 = [
		[ 0.5766690429101305,   0.1855582379065463,   0.1882286462349947  ],
		[ 0.29734497525053605,  0.6273635662554661,   0.07529145849399788 ],
		[ 0.02703136138641234,  0.07068885253582723,  0.9913375368376388  ]
	];

	const fromXYZ_M$2 = [
		[  2.0415879038107465,    -0.5650069742788596,   -0.34473135077832956 ],
		[ -0.9692436362808795,     1.8759675015077202,    0.04155505740717557 ],
		[  0.013444280632031142,  -0.11836239223101838,   1.0151749943912054  ]
	];

	var A98Linear = new RGBColorSpace({
		id: "a98rgb-linear",
		name: "Linear Adobe® 98 RGB compatible",
		white: "D65",
		toXYZ_M: toXYZ_M$2,
		fromXYZ_M: fromXYZ_M$2
	});

	var a98rgb = new RGBColorSpace({
		id: "a98rgb",
		name: "Adobe® 98 RGB compatible",
		base: A98Linear,
		toBase: RGB => RGB.map(val => Math.pow(Math.abs(val), 563 / 256) * Math.sign(val)),
		fromBase: RGB => RGB.map(val => Math.pow(Math.abs(val), 256 / 563) * Math.sign(val)),
		formats: {
			color: {
				id: "a98-rgb"
			}
		},
	});

	// convert an array of  prophoto-rgb values to CIE XYZ
	// using  D50 (so no chromatic adaptation needed afterwards)
	// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
	const toXYZ_M$1 = [
		[ 0.7977604896723027,  0.13518583717574031,  0.0313493495815248     ],
		[ 0.2880711282292934,  0.7118432178101014,   0.00008565396060525902 ],
		[ 0.0,                 0.0,                  0.8251046025104601     ]
	];

	const fromXYZ_M$1 = [
		[  1.3457989731028281,  -0.25558010007997534,  -0.05110628506753401 ],
		[ -0.5446224939028347,   1.5082327413132781,    0.02053603239147973 ],
		[  0.0,                  0.0,                   1.2119675456389454  ]
	];

	var ProPhotoLinear = new RGBColorSpace({
		id: "prophoto-linear",
		name: "Linear ProPhoto",
		white: "D50",
		base: XYZ_D50,
		toXYZ_M: toXYZ_M$1,
		fromXYZ_M: fromXYZ_M$1
	});

	const Et = 1/512;
	const Et2 = 16/512;

	var prophoto = new RGBColorSpace({
		id: "prophoto",
		name: "ProPhoto",
		base: ProPhotoLinear,
		toBase (RGB) {
			// Transfer curve is gamma 1.8 with a small linear portion
			return RGB.map(v => v < Et2? v / 16 : v ** 1.8);
		},
		fromBase (RGB) {
			return RGB.map(v => v >= Et? v ** (1/1.8) : 16 * v);
		},
		formats: {
			color: {
				id: "prophoto-rgb"
			}
		},
	});

	var oklch = new ColorSpace({
		id: "oklch",
		name: "Oklch",
		coords: {
			l: {
				refRange: [0, 1],
				name: "Lightness"
			},
			c: {
				refRange: [0, 0.4],
				name: "Chroma"
			},
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			}
		},
		white: "D65",

		base: OKLab,
		fromBase (oklab) {
			// Convert to polar form
			let [L, a, b] = oklab;
			let h;
			const ε = 0.0002; // chromatic components much smaller than a,b

			if (Math.abs(a) < ε && Math.abs(b) < ε) {
				h = NaN;
			}
			else {
				h = Math.atan2(b, a) * 180 / Math.PI;
			}

			return [
				L, // OKLab L is still L
				Math.sqrt(a ** 2 + b ** 2), // Chroma
				constrain(h) // Hue, in degrees [0 to 360)
			];
		},
		// Convert from polar form
		toBase (oklch) {
			let [L, C, h] = oklch;
			let a, b;

			// check for NaN hue
			if (isNaN(h)) {
				a = 0;
				b = 0;
			}
			else {
				a = C * Math.cos(h * Math.PI / 180);
				b = C * Math.sin(h * Math.PI / 180);
			}

			return [ L, a, b ];
		},

		formats: {
			"oklch": {
				coords: ["<number> | <percentage>", "<number> | <percentage>[0,1]", "<number> | <angle>"],
			}
		}
	});

	const Yw = 203;	// absolute luminance of media white, cd/m²
	const n = 2610 / (2 ** 14);
	const ninv = (2 ** 14) / 2610;
	const m = 2523 / (2 ** 5);
	const minv = (2 ** 5) / 2523;
	const c1 = 3424 / (2 ** 12);
	const c2 = 2413 / (2 ** 7);
	const c3 = 2392 / (2 ** 7);

	var rec2100Pq = new RGBColorSpace({
		id: "rec2100pq",
		name: "REC.2100-PQ",
		base: REC2020Linear,
		toBase (RGB) {
			// given PQ encoded component in range [0, 1]
			// return media-white relative linear-light
			return RGB.map(function (val) {
				let x = ((Math.max(((val ** minv) - c1), 0) / (c2 - (c3 * (val ** minv)))) ** ninv);
				return (x * 10000 / Yw); 	// luminance relative to diffuse white, [0, 70 or so].
			});
		},
		fromBase (RGB) {
			// given media-white relative linear-light
			// returnPQ encoded component in range [0, 1]
			return RGB.map(function (val) {
				let x = Math.max(val * Yw / 10000, 0); 	// absolute luminance of peak white is 10,000 cd/m².
				let num = (c1 + (c2 * (x ** n)));
				let denom = (1 + (c3 * (x ** n)));

				return ((num / denom)  ** m);
			});
		},
		formats: {
			color: {
				id: "rec2100-pq"
			},
		},
	});

	// FIXME see https://github.com/LeaVerou/color.js/issues/190

	const a = 0.17883277;
	const b = 0.28466892; // 1 - (4 * a)
	const c = 0.55991073; // 0.5 - a * Math.log(4 *a)

	const scale = 3.7743;	// Place 18% grey at HLG 0.38, so media white at 0.75

	var rec2100Hlg = new RGBColorSpace({
		id: "rec2100hlg",
		cssid: "rec2100-hlg",
		name: "REC.2100-HLG",
		referred: "scene",

		base: REC2020Linear,
		toBase (RGB) {
			// given HLG encoded component in range [0, 1]
			// return media-white relative linear-light
			return RGB.map(function (val) {
				// first the HLG EOTF
				// ITU-R BT.2390-10 p.30 section
				// 6.3 The hybrid log-gamma electro-optical transfer function (EOTF)
				// Then scale by 3 so media white is 1.0
				if (val <= 0.5) {
					return (val ** 2) / 3 * scale;
				}
				return ((Math.exp((val - c) / a) + b) / 12) * scale;
			});
		},
		fromBase (RGB) {
			// given media-white relative linear-light
			// where diffuse white is 1.0,
			// return HLG encoded component in range [0, 1]
			return RGB.map(function (val) {
				// first scale to put linear-light media white at 1/3
				val /= scale;
				// now the HLG OETF
				// ITU-R BT.2390-10 p.23
				// 6.1 The hybrid log-gamma opto-electronic transfer function (OETF)
				if (val <= 1/12) {
					return Math.sqrt( 3 * val);
				}
				return a * Math.log(12 * val - b) + c;
			});
		},
		formats: {
			color: {
				id: "rec2100-hlg"
			},
		},
	});

	const CATs = {};

	hooks.add("chromatic-adaptation-start", env => {
		if (env.options.method) {
			env.M = adapt(env.W1, env.W2, env.options.method);
		}
	});

	hooks.add("chromatic-adaptation-end", env => {
		if (!env.M) {
			env.M = adapt(env.W1, env.W2, env.options.method);
		}
	});

	function defineCAT ({id, toCone_M, fromCone_M}) {
		// Use id, toCone_M, fromCone_M like variables
		CATs[id] = arguments[0];
	}
	function adapt (W1, W2, id = "Bradford") {
		// adapt from a source whitepoint or illuminant W1
		// to a destination whitepoint or illuminant W2,
		// using the given chromatic adaptation transform (CAT)
		// debugger;
		let method = CATs[id];

		let [ρs, γs, βs] = multiplyMatrices(method.toCone_M, W1);
		let [ρd, γd, βd] = multiplyMatrices(method.toCone_M, W2);

		// all practical illuminants have non-zero XYZ so no division by zero can occur below
		let scale = [
			[ρd/ρs,    0,      0      ],
			[0,        γd/γs,  0      ],
			[0,        0,      βd/βs  ]
		];
		// console.log({scale});

		let scaled_cone_M = multiplyMatrices(scale, method.toCone_M);
		let adapt_M	= multiplyMatrices(method.fromCone_M, scaled_cone_M);
		// console.log({scaled_cone_M, adapt_M});
		return adapt_M;
	}
	defineCAT({
		id: "von Kries",
		toCone_M: [
			[  0.4002400,  0.7076000, -0.0808100 ],
			[ -0.2263000,  1.1653200,  0.0457000 ],
			[  0.0000000,  0.0000000,  0.9182200 ]
		],
		fromCone_M: [
			[  1.8599364, -1.1293816,  0.2198974 ],
			[  0.3611914,  0.6388125, -0.0000064 ],
			[  0.0000000,  0.0000000,  1.0890636 ]
		]
	});

	defineCAT({
		id: "Bradford",
		// Convert an array of XYZ values in the range 0.0 - 1.0
		// to cone fundamentals
		toCone_M: [
			[  0.8951000,  0.2664000, -0.1614000 ],
			[ -0.7502000,  1.7135000,  0.0367000 ],
			[  0.0389000, -0.0685000,  1.0296000 ]
		],
		// and back
		fromCone_M: [
			[  0.9869929, -0.1470543,  0.1599627 ],
			[  0.4323053,  0.5183603,  0.0492912 ],
			[ -0.0085287,  0.0400428,  0.9684867 ]
		]
	});

	defineCAT({
		id: "CAT02",
		// with complete chromatic adaptation to W2, so D = 1.0
		toCone_M: [
			[  0.7328000,  0.4296000, -0.1624000 ],
			[ -0.7036000,  1.6975000,  0.0061000 ],
			[  0.0030000,  0.0136000,  0.9834000 ]
		],
		fromCone_M: [
			[  1.0961238, -0.2788690,  0.1827452 ],
			[  0.4543690,  0.4735332,  0.0720978 ],
			[ -0.0096276, -0.0056980,  1.0153256 ]
		]
	});

	defineCAT({
		id: "CAT16",
		toCone_M: [
			[  0.401288,  0.650173, -0.051461 ],
			[ -0.250268,  1.204414,  0.045854 ],
			[ -0.002079,  0.048952,  0.953127 ]
		],
		// the extra precision is needed to avoid roundtripping errors
		fromCone_M: [
			[  1.862067855087233e+0, -1.011254630531685e+0,   1.491867754444518e-1 ],
			[  3.875265432361372e-1,  6.214474419314753e-1,  -8.973985167612518e-3 ],
			[ -1.584149884933386e-2, -3.412293802851557e-2,   1.049964436877850e+0 ]
		]
	});

	Object.assign(WHITES, {
		// whitepoint values from ASTM E308-01 with 10nm spacing, 1931 2 degree observer
		// all normalized to Y (luminance) = 1.00000
		// Illuminant A is a tungsten electric light, giving a very warm, orange light.
		A:  [1.09850, 1.00000, 0.35585],

		// Illuminant C was an early approximation to daylight: illuminant A with a blue filter.
		C:   [0.98074, 1.000000, 1.18232],

		// The daylight series of illuminants simulate natural daylight.
		// The color temperature (in degrees Kelvin/100) ranges from
		// cool, overcast daylight (D50) to bright, direct sunlight (D65).
		D55: [0.95682, 1.00000, 0.92149],
		D75: [0.94972, 1.00000, 1.22638],

		// Equal-energy illuminant, used in two-stage CAT16
		E:   [1.00000, 1.00000, 1.00000],

		// The F series of illuminants represent fluorescent lights
		F2:  [0.99186, 1.00000, 0.67393],
		F7:  [0.95041, 1.00000, 1.08747],
		F11: [1.00962, 1.00000, 0.64350],
	});

	// The ACES whitepoint
	// see TB-2018-001 Derivation of the ACES White Point CIE Chromaticity Coordinates
	// also https://github.com/ampas/aces-dev/blob/master/documents/python/TB-2018-001/aces_wp.py
	// Similar to D60
	WHITES.ACES = [0.32168/0.33767, 1.00000, (1.00000 - 0.32168 - 0.33767)/0.33767];

	// convert an array of linear-light ACEScc values to CIE XYZ
	const toXYZ_M = [
		[  0.6624541811085053,   0.13400420645643313,  0.1561876870049078  ],
		[  0.27222871678091454,  0.6740817658111484,   0.05368951740793705 ],
		[ -0.005574649490394108, 0.004060733528982826, 1.0103391003129971  ]
	];
	const fromXYZ_M = [
		[  1.6410233796943257,   -0.32480329418479,    -0.23642469523761225  ],
		[ -0.6636628587229829,    1.6153315916573379,   0.016756347685530137 ],
		[  0.011721894328375376, -0.008284441996237409, 0.9883948585390215   ]
	];

	var ACEScg = new RGBColorSpace({
		id: "acescg",
		name: "ACEScg",

		// ACEScg – A scene-referred, linear-light encoding of ACES Data
		// https://docs.acescentral.com/specifications/acescg/
		// uses the AP1 primaries, see section 4.3.1 Color primaries
		coords: {
			r: {
				range: [0, 65504],
				name: "Red"
			},
			g: {
				range: [0, 65504],
				name: "Green"
			},
			b: {
				range: [0, 65504],
				name: "Blue"
			}
		},

		referred: "scene",

		white: WHITES.ACES,

		toXYZ_M,
		fromXYZ_M,

		formats: {
			color: {}
		},
	});

	// export default Color;

	const ε = 2 ** -16;

	// the smallest value which, in the 32bit IEEE 754 float encoding,
	// decodes as a non-negative value
	const ACES_min_nonzero = -0.35828683;

	// brightest encoded value, decodes to 65504
	const ACES_cc_max = (Math.log2(65504) + 9.72) / 17.52; // 1.468

	var acescc = new RGBColorSpace({
		id: "acescc",
		name: "ACEScc",
		// see S-2014-003 ACEScc – A Logarithmic Encoding of ACES Data
		// https://docs.acescentral.com/specifications/acescc/
		// uses the AP1 primaries, see section 4.3.1 Color primaries

		// Appendix A: "Very small ACES scene referred values below 7 1/4 stops
		// below 18% middle gray are encoded as negative ACEScc values.
		// These values should be preserved per the encoding in Section 4.4
		// so that all positive ACES values are maintained."
		coords: {
			r: {
				range: [ACES_min_nonzero, ACES_cc_max],
				name: "Red"
			},
			g: {
				range: [ACES_min_nonzero, ACES_cc_max],
				name: "Green"
			},
			b: {
				range: [ACES_min_nonzero, ACES_cc_max],
				name: "Blue"
			}
		},
		referred: "scene",

		base: ACEScg,
		// from section 4.4.2 Decoding Function
		toBase (RGB) {
			const low = (9.72 - 15) / 17.52; // -0.3014

			return RGB.map(function (val) {
				if (val <= low) {
					return (2 ** ((val * 17.52) - 9.72) - ε) * 2; // very low values, below -0.3014
				}
				else if (val < ACES_cc_max) {
					return 2 ** ((val * 17.52) - 9.72);
				}
				else { // val >= ACES_cc_max
					return 65504;
				}
			});
		},

		// Non-linear encoding function from S-2014-003, section 4.4.1 Encoding Function
		fromBase (RGB) {
			return RGB.map(function (val) {
				if (val <= 0) {
					return (Math.log2(ε) + 9.72) / 17.52; // -0.3584
				}
				else if (val < ε) {
					return  (Math.log2(ε + val * 0.5) + 9.72) / 17.52;
				}
				else { // val >= ε
					return  (Math.log2(val) + 9.72) / 17.52;
				}
			});
		},
		// encoded media white (rgb 1,1,1) => linear  [ 222.861, 222.861, 222.861 ]
		// encoded media black (rgb 0,0,0) => linear [ 0.0011857, 0.0011857, 0.0011857]
		formats: {
			color: {}
		}
	});

	var spaces = /*#__PURE__*/Object.freeze({
		__proto__: null,
		A98RGB: a98rgb,
		A98RGB_Linear: A98Linear,
		ACEScc: acescc,
		ACEScg: ACEScg,
		HSL: HSL,
		HSV: HSV,
		HWB: hwb,
		ICTCP: ictcp,
		JzCzHz: jzczhz,
		Jzazbz: Jzazbz,
		LCH: lch,
		Lab: lab,
		Lab_D65: lab_d65,
		OKLCH: oklch,
		OKLab: OKLab,
		P3: P3,
		P3_Linear: P3Linear,
		ProPhoto: prophoto,
		ProPhoto_Linear: ProPhotoLinear,
		REC_2020: REC2020,
		REC_2020_Linear: REC2020Linear,
		REC_2100_HLG: rec2100Hlg,
		REC_2100_PQ: rec2100Pq,
		XYZ_ABS_D65: XYZ_Abs_D65,
		XYZ_D50: XYZ_D50,
		XYZ_D65: XYZ_D65,
		sRGB: sRGB,
		sRGB_Linear: sRGBLinear
	});

	/**
	 * Class that represents a color
	 */
	class Color {
		/**
		 * Creates an instance of Color.
		 * Signatures:
		 * - `new Color(stringToParse)`
		 * - `new Color(otherColor)`
		 * - `new Color({space, coords, alpha})`
		 * - `new Color(space, coords, alpha)`
		 * - `new Color(spaceId, coords, alpha)`
		 */
		constructor (...args) {
			let color;

			if (args.length === 1) {
				color = getColor(args[0]);
			}

			let space, coords, alpha;

			if (color) {
				space = color.space || color.spaceId;
				coords = color.coords;
				alpha = color.alpha;
			}
			else {
				// default signature new Color(ColorSpace, array [, alpha])
				[space, coords, alpha] = args;
			}

			Object.defineProperty(this, "space", {
				value: ColorSpace.get(space),
				writable: false,
				enumerable: true,
				configurable: true, // see note in https://262.ecma-international.org/8.0/#sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver
			});
			this.coords = coords? coords.slice() : [0, 0, 0];
			this.alpha = alpha < 1? alpha : 1; // this also deals with NaN etc

			// Convert "NaN" to NaN
			for (let i = 0; i < this.coords.length; i++) {
				if (this.coords[i] === "NaN") {
					this.coords[i] = NaN;
				}
			}

			// Define getters and setters for each coordinate
			for (let id in this.space.coords) {
				Object.defineProperty(this, id, {
					get: () => this.get(id),
					set: value => this.set(id, value)
				});
			}
		}

		get spaceId () {
			return this.space.id;
		}

		clone () {
			return new Color(this.space, this.coords, this.alpha);
		}

		toJSON () {
			return {
				spaceId: this.spaceId,
				coords: this.coords,
				alpha: this.alpha
			};
		}

		display (...args) {
			let ret = display(this, ...args);

			// Convert color object to Color instance
			ret.color = new Color(ret.color);

			return ret;
		}

		/**
		 * Get a color from the argument passed
		 * Basically gets us the same result as new Color(color) but doesn't clone an existing color object
		 */
		static get (color, ...args) {
			if (color instanceof Color) {
				return color;
			}

			return new Color(color, ...args);
		}

		static defineFunction (name, code, o = code) {
			let {instance = true, returns} = o;

			let func = function (...args) {
				let ret = code(...args);

				if (returns === "color") {
					ret = Color.get(ret);
				}
				else if (returns === "function<color>") {
					let f = ret;
					ret = function (...args) {
						let ret = f(...args);
						return Color.get(ret);
					};
					// Copy any function metadata
					Object.assign(ret, f);
				}
				else if (returns === "array<color>") {
					ret = ret.map(c => Color.get(c));
				}

				return ret;
			};

			if (!(name in Color)) {
				Color[name] = func;
			}

			if (instance) {
				Color.prototype[name] = function (...args) {
					return func(this, ...args);
				};
			}
		}

		static defineFunctions (o) {
			for (let name in o) {
				Color.defineFunction(name, o[name], o[name]);
			}
		}

		static extend (exports) {
			if (exports.register) {
				exports.register(Color);
			}
			else {
				// No register method, just add the module's functions
				for (let name in exports) {
					Color.defineFunction(name, exports[name]);
				}
			}
		}
	}
	Color.defineFunctions({
		get,
		getAll,
		set,
		setAll,
		to,
		equals,
		inGamut,
		toGamut,
		distance,
		toString: serialize$1,
	});

	Object.assign(Color, {
		util,
		hooks,
		WHITES,
		Space: ColorSpace,
		spaces: ColorSpace.registry,
		parse: parse$1,

		// Global defaults one may want to configure
		defaults
	});

	for (let key of Object.keys(spaces)) {
		ColorSpace.register(spaces[key]);
	}

	/**
	 * This plugin defines getters and setters for color[spaceId]
	 * e.g. color.lch on *any* color gives us the lch coords
	 */

	// Add space accessors to existing color spaces
	for (let id in ColorSpace.registry) {
		addSpaceAccessors(id, ColorSpace.registry[id]);
	}

	// Add space accessors to color spaces not yet created
	hooks.add("colorspace-init-end", space => {
		addSpaceAccessors(space.id, space);
		space.aliases?.forEach(alias => {
			addSpaceAccessors(alias, space);
		});
	});

	function addSpaceAccessors (id, space) {
		// Coordinates can be looked up by both id and name
		Object.keys(space.coords);
		Object.values(space.coords).map(c => c.name);


		let propId = id.replace(/-/g, "_");

		Object.defineProperty(Color.prototype, propId, {
			// Convert coords to coords in another colorspace and return them
			// Source colorspace: this.spaceId
			// Target colorspace: id
			get () {
				let ret = this.getAll(id);

				if (typeof Proxy === "undefined") {
					// If proxies are not supported, just return a static array
					return ret;
				}

				// Enable color.spaceId.coordName syntax
				return new Proxy(ret, {
					has: (obj, property) => {
						try {
							ColorSpace.resolveCoord([space, property]);
							return true;
						}
						catch (e) {}

						return Reflect.has(obj, property);
					},
					get: (obj, property, receiver) => {
						if (property && typeof property !== "symbol" && !(property in obj)) {
							let {index} = ColorSpace.resolveCoord([space, property]);

							if (index >= 0) {
								return obj[index];
							}
						}

						return Reflect.get(obj, property, receiver);
					},
					set: (obj, property, value, receiver) => {
						if (property && typeof property !== "symbol" && !(property in obj) || property >= 0) {
							let {index} = ColorSpace.resolveCoord([space, property]);

							if (index >= 0) {
								obj[index] = value;

								// Update color.coords
								this.setAll(id, obj);

								return true;
							}
						}

						return Reflect.set(obj, property, value, receiver);
					},
				});
			},
			// Convert coords in another colorspace to internal coords and set them
			// Target colorspace: this.spaceId
			// Source colorspace: id
			set (coords) {
				this.setAll(id, coords);
			},
			configurable: true,
			enumerable: true
		});
	}

	// Import all modules of Color.js

	Color.extend(deltaEMethods);
	Color.extend({deltaE});
	Object.assign(Color, {deltaEMethods});
	Color.extend(variations);
	Color.extend({contrast});
	Color.extend(chromaticity);
	Color.extend(luminance);
	Color.extend(interpolation);
	Color.extend(contrastMethods);

	/* src/lib/components/editor/inputs/ColorInput.svelte generated by Svelte v4.2.10 */
	const file$8 = "src/lib/components/editor/inputs/ColorInput.svelte";

	function create_fragment$9(ctx) {
		let div1;
		let div0;
		let input0;
		let t;
		let input1;
		let mounted;
		let dispose;

		const block = {
			c: function create() {
				div1 = element("div");
				div0 = element("div");
				input0 = element("input");
				t = space();
				input1 = element("input");
				attr_dev(input0, "type", "color");
				attr_dev(input0, "class", "absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 rounded-full h-10 w-10 cursor-pointer");
				input0.value = /*inputString*/ ctx[2];
				add_location(input0, file$8, 25, 4, 555);
				attr_dev(div0, "class", "overflow-hidden rounded-full w-5 h-5 border border-border relative");
				add_location(div0, file$8, 22, 2, 463);
				attr_dev(input1, "class", "w-[3.5rem] text-xs border-none text-text bg-background text-end focus:outline-none focus:ring-0");
				attr_dev(input1, "type", "text");
				input1.value = /*inputString*/ ctx[2];
				add_location(input1, file$8, 35, 2, 852);
				attr_dev(div1, "class", "flex flex-row gap-1 justify-end items-center rounded-lg cursor-pointer");
				add_location(div1, file$8, 19, 0, 373);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, div0);
				append_dev(div0, input0);
				append_dev(div1, t);
				append_dev(div1, input1);

				if (!mounted) {
					dispose = [
						listen_dev(input0, "input", /*input_handler*/ ctx[3], false, false, false, false),
						listen_dev(input1, "input", /*input_handler_1*/ ctx[4], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*inputString*/ 4) {
					prop_dev(input0, "value", /*inputString*/ ctx[2]);
				}

				if (dirty & /*inputString*/ 4 && input1.value !== /*inputString*/ ctx[2]) {
					prop_dev(input1, "value", /*inputString*/ ctx[2]);
				}
			},
			i: noop$3,
			o: noop$3,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}

				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$9.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function expandShorthandHex(hex) {
		if (hex.length <= 5) {
			return `#${hex[1]}${hex[1]}${hex[2]}${hex[2]}${hex[3]}${hex[3]}`;
		}

		return hex;
	}

	function instance$9($$self, $$props, $$invalidate) {
		let inputString;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ColorInput', slots, []);
		let { elementStyle } = $$props;
		let { updateElementStyle } = $$props;

		$$self.$$.on_mount.push(function () {
			if (elementStyle === undefined && !('elementStyle' in $$props || $$self.$$.bound[$$self.$$.props['elementStyle']])) {
				console.warn("<ColorInput> was created without expected prop 'elementStyle'");
			}

			if (updateElementStyle === undefined && !('updateElementStyle' in $$props || $$self.$$.bound[$$self.$$.props['updateElementStyle']])) {
				console.warn("<ColorInput> was created without expected prop 'updateElementStyle'");
			}
		});

		const writable_props = ['elementStyle', 'updateElementStyle'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ColorInput> was created with unknown prop '${key}'`);
		});

		const input_handler = event => {
			updateElementStyle(elementStyle.key, event.target.value);
		};

		const input_handler_1 = event => {
			updateElementStyle(elementStyle.key, event.target.value);
		};

		$$self.$$set = $$props => {
			if ('elementStyle' in $$props) $$invalidate(0, elementStyle = $$props.elementStyle);
			if ('updateElementStyle' in $$props) $$invalidate(1, updateElementStyle = $$props.updateElementStyle);
		};

		$$self.$capture_state = () => ({
			Color,
			elementStyle,
			updateElementStyle,
			expandShorthandHex,
			inputString
		});

		$$self.$inject_state = $$props => {
			if ('elementStyle' in $$props) $$invalidate(0, elementStyle = $$props.elementStyle);
			if ('updateElementStyle' in $$props) $$invalidate(1, updateElementStyle = $$props.updateElementStyle);
			if ('inputString' in $$props) $$invalidate(2, inputString = $$props.inputString);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*elementStyle*/ 1) {
				$$invalidate(2, inputString = expandShorthandHex(new Color(elementStyle.value).toString({ format: "hex" })));
			}
		};

		return [elementStyle, updateElementStyle, inputString, input_handler, input_handler_1];
	}

	class ColorInput extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$9, create_fragment$9, safe_not_equal, { elementStyle: 0, updateElementStyle: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ColorInput",
				options,
				id: create_fragment$9.name
			});
		}

		get elementStyle() {
			throw new Error("<ColorInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set elementStyle(value) {
			throw new Error("<ColorInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get updateElementStyle() {
			throw new Error("<ColorInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set updateElementStyle(value) {
			throw new Error("<ColorInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/editor/inputs/NumberUnitInput.svelte generated by Svelte v4.2.10 */
	const file$7 = "src/lib/components/editor/inputs/NumberUnitInput.svelte";

	function get_each_context$2(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[12] = list[i];
		return child_ctx;
	}

	// (31:0) {#if elementStyle}
	function create_if_block$4(ctx) {
		let div;
		let input;
		let input_class_value;
		let input_value_value;
		let t0;
		let select;
		let option_1;
		let t1;
		let show_if = /*parsedUnit*/ ctx[6] !== "" && !/*elementStyle*/ ctx[0].units.includes(/*parsedUnit*/ ctx[6]);
		let if_block_anchor;
		let select_name_value;
		let select_class_value;
		let select_value_value;
		let mounted;
		let dispose;
		let if_block = show_if && create_if_block_1$3(ctx);
		let each_value = ensure_array_like_dev(/*elementStyle*/ ctx[0].units ?? []);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
		}

		const block = {
			c: function create() {
				div = element("div");
				input = element("input");
				t0 = space();
				select = element("select");
				option_1 = element("option");
				t1 = text(auto);
				if (if_block) if_block.c();
				if_block_anchor = empty();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(input, "type", "number");
				attr_dev(input, "class", input_class_value = "" + (/*inputWidth*/ ctx[3] + " text-xs border-none text-text bg-background text-end focus:outline-none focus:ring-0 [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"));
				attr_dev(input, "placeholder", "--");
				input.value = input_value_value = /*isEmpty*/ ctx[8]() ? "" : /*parsedNumber*/ ctx[5];
				add_location(input, file$7, 42, 4, 1080);
				option_1.__value = auto;
				set_input_value(option_1, option_1.__value);
				add_location(option_1, file$7, 74, 6, 2310);
				attr_dev(select, "name", select_name_value = /*elementStyle*/ ctx[0].displayName);
				attr_dev(select, "placeholder", "auto");
				attr_dev(select, "class", select_class_value = "text-xs " + /*unitWidth*/ ctx[4] + " border-none text-text bg-background appearance-none " + (/*unitEnd*/ ctx[2] ? 'text-end' : 'text-start') + " focus:outline-none focus:ring-0");
				add_location(select, file$7, 55, 4, 1648);
				attr_dev(div, "class", "flex flex-row gap-1 justify-end");
				add_location(div, file$7, 41, 2, 1030);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, input);
				append_dev(div, t0);
				append_dev(div, select);
				append_dev(select, option_1);
				append_dev(option_1, t1);
				if (if_block) if_block.m(select, null);
				append_dev(select, if_block_anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(select, null);
					}
				}

				select_option(select, /*isEmpty*/ ctx[8]() ? auto : /*parsedUnit*/ ctx[6]);

				if (!mounted) {
					dispose = [
						listen_dev(input, "input", /*input_handler*/ ctx[9], false, false, false, false),
						listen_dev(select, "input", /*input_handler_1*/ ctx[10], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (dirty & /*inputWidth*/ 8 && input_class_value !== (input_class_value = "" + (/*inputWidth*/ ctx[3] + " text-xs border-none text-text bg-background text-end focus:outline-none focus:ring-0 [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"))) {
					attr_dev(input, "class", input_class_value);
				}

				if (dirty & /*parsedNumber*/ 32 && input_value_value !== (input_value_value = /*isEmpty*/ ctx[8]() ? "" : /*parsedNumber*/ ctx[5]) && input.value !== input_value_value) {
					prop_dev(input, "value", input_value_value);
				}

				if (dirty & /*parsedUnit, elementStyle*/ 65) show_if = /*parsedUnit*/ ctx[6] !== "" && !/*elementStyle*/ ctx[0].units.includes(/*parsedUnit*/ ctx[6]);

				if (show_if) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_1$3(ctx);
						if_block.c();
						if_block.m(select, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (dirty & /*elementStyle*/ 1) {
					each_value = ensure_array_like_dev(/*elementStyle*/ ctx[0].units ?? []);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$2(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$2(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(select, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}

				if (dirty & /*elementStyle*/ 1 && select_name_value !== (select_name_value = /*elementStyle*/ ctx[0].displayName)) {
					attr_dev(select, "name", select_name_value);
				}

				if (dirty & /*unitWidth, unitEnd*/ 20 && select_class_value !== (select_class_value = "text-xs " + /*unitWidth*/ ctx[4] + " border-none text-text bg-background appearance-none " + (/*unitEnd*/ ctx[2] ? 'text-end' : 'text-start') + " focus:outline-none focus:ring-0")) {
					attr_dev(select, "class", select_class_value);
				}

				if (dirty & /*parsedUnit, elementStyle, auto*/ 65 && select_value_value !== (select_value_value = /*isEmpty*/ ctx[8]() ? auto : /*parsedUnit*/ ctx[6])) {
					select_option(select, /*isEmpty*/ ctx[8]() ? auto : /*parsedUnit*/ ctx[6]);
				}
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (if_block) if_block.d();
				destroy_each(each_blocks, detaching);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$4.name,
			type: "if",
			source: "(31:0) {#if elementStyle}",
			ctx
		});

		return block;
	}

	// (66:6) {#if parsedUnit !== "" && !elementStyle.units.includes(parsedUnit)}
	function create_if_block_1$3(ctx) {
		let option_1;
		let t;

		const block = {
			c: function create() {
				option_1 = element("option");
				t = text(/*parsedUnit*/ ctx[6]);
				option_1.__value = /*parsedUnit*/ ctx[6];
				set_input_value(option_1, option_1.__value);
				add_location(option_1, file$7, 76, 8, 2429);
			},
			m: function mount(target, anchor) {
				insert_dev(target, option_1, anchor);
				append_dev(option_1, t);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*parsedUnit*/ 64) set_data_dev(t, /*parsedUnit*/ ctx[6]);

				if (dirty & /*parsedUnit, elementStyle, auto*/ 65) {
					prop_dev(option_1, "__value", /*parsedUnit*/ ctx[6]);
					set_input_value(option_1, option_1.__value);
				}
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(option_1);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$3.name,
			type: "if",
			source: "(66:6) {#if parsedUnit !== \\\"\\\" && !elementStyle.units.includes(parsedUnit)}",
			ctx
		});

		return block;
	}

	// (69:6) {#each elementStyle.units ?? [] as option}
	function create_each_block$2(ctx) {
		let option_1;
		let t_value = /*option*/ ctx[12] + "";
		let t;
		let option_1_value_value;

		const block = {
			c: function create() {
				option_1 = element("option");
				t = text(t_value);
				option_1.__value = option_1_value_value = /*option*/ ctx[12];
				set_input_value(option_1, option_1.__value);
				add_location(option_1, file$7, 79, 8, 2547);
			},
			m: function mount(target, anchor) {
				insert_dev(target, option_1, anchor);
				append_dev(option_1, t);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*elementStyle*/ 1 && t_value !== (t_value = /*option*/ ctx[12] + "")) set_data_dev(t, t_value);

				if (dirty & /*elementStyle*/ 1 && option_1_value_value !== (option_1_value_value = /*option*/ ctx[12])) {
					prop_dev(option_1, "__value", option_1_value_value);
					set_input_value(option_1, option_1.__value);
				}
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(option_1);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$2.name,
			type: "each",
			source: "(69:6) {#each elementStyle.units ?? [] as option}",
			ctx
		});

		return block;
	}

	function create_fragment$8(ctx) {
		let if_block_anchor;
		let if_block = /*elementStyle*/ ctx[0] && create_if_block$4(ctx);

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
			},
			p: function update(ctx, [dirty]) {
				if (/*elementStyle*/ ctx[0]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$4(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop$3,
			o: noop$3,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$8.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	const auto = "auto";

	function instance$8($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('NumberUnitInput', slots, []);
		let { elementStyle } = $$props;
		let { updateElementStyle } = $$props;
		let { unitEnd = false } = $$props;
		let { inputWidth = "w-8" } = $$props;
		let { unitWidth = "w-8" } = $$props;
		let parsedNumber = 0;
		let parsedUnit = "";

		const stringToParsedValue = val => {
			const matches = val.match(/([-+]?[0-9]*\.?[0-9]+)([a-zA-Z%]*)/);
			let num = matches ? parseFloat(matches[1]) : 0;
			let unit = matches && matches[2] ? matches[2] : "";

			// Handle opacity, if no parsed unit, convert to percentage
			if (elementStyle.key === "opacity" && unit === "") {
				unit = "%";
				num = num <= 1 ? num * 100 : num;
			}

			return [num, unit];
		};

		const parsedValueToString = (floatValue, unit) => {
			return `${floatValue}${unit}`;
		};

		function isEmpty() {
			const numberIsEmpty = isNaN(parsedNumber) || parsedNumber === 0;
			const unitIsEmpty = parsedUnit === "";
			return numberIsEmpty && unitIsEmpty;
		}

		$$self.$$.on_mount.push(function () {
			if (elementStyle === undefined && !('elementStyle' in $$props || $$self.$$.bound[$$self.$$.props['elementStyle']])) {
				console.warn("<NumberUnitInput> was created without expected prop 'elementStyle'");
			}

			if (updateElementStyle === undefined && !('updateElementStyle' in $$props || $$self.$$.bound[$$self.$$.props['updateElementStyle']])) {
				console.warn("<NumberUnitInput> was created without expected prop 'updateElementStyle'");
			}
		});

		const writable_props = ['elementStyle', 'updateElementStyle', 'unitEnd', 'inputWidth', 'unitWidth'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NumberUnitInput> was created with unknown prop '${key}'`);
		});

		const input_handler = e => {
			const stringValue = parsedValueToString(e.target?.value, parsedUnit);

			if (stringValue !== elementStyle.value) {
				updateElementStyle(elementStyle.key, stringValue);
			}
		};

		const input_handler_1 = e => {
			if (e.target?.value === auto) {
				updateElementStyle(elementStyle.key, "inherit");
				return;
			}

			const stringValue = parsedValueToString(parsedNumber, e.target?.value);

			if (stringValue !== elementStyle.value) {
				updateElementStyle(elementStyle.key, stringValue);
			}
		};

		$$self.$$set = $$props => {
			if ('elementStyle' in $$props) $$invalidate(0, elementStyle = $$props.elementStyle);
			if ('updateElementStyle' in $$props) $$invalidate(1, updateElementStyle = $$props.updateElementStyle);
			if ('unitEnd' in $$props) $$invalidate(2, unitEnd = $$props.unitEnd);
			if ('inputWidth' in $$props) $$invalidate(3, inputWidth = $$props.inputWidth);
			if ('unitWidth' in $$props) $$invalidate(4, unitWidth = $$props.unitWidth);
		};

		$$self.$capture_state = () => ({
			elementStyle,
			updateElementStyle,
			unitEnd,
			inputWidth,
			unitWidth,
			parsedNumber,
			parsedUnit,
			auto,
			stringToParsedValue,
			parsedValueToString,
			isEmpty
		});

		$$self.$inject_state = $$props => {
			if ('elementStyle' in $$props) $$invalidate(0, elementStyle = $$props.elementStyle);
			if ('updateElementStyle' in $$props) $$invalidate(1, updateElementStyle = $$props.updateElementStyle);
			if ('unitEnd' in $$props) $$invalidate(2, unitEnd = $$props.unitEnd);
			if ('inputWidth' in $$props) $$invalidate(3, inputWidth = $$props.inputWidth);
			if ('unitWidth' in $$props) $$invalidate(4, unitWidth = $$props.unitWidth);
			if ('parsedNumber' in $$props) $$invalidate(5, parsedNumber = $$props.parsedNumber);
			if ('parsedUnit' in $$props) $$invalidate(6, parsedUnit = $$props.parsedUnit);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*elementStyle*/ 1) {
				$$invalidate(5, [parsedNumber, parsedUnit] = stringToParsedValue(elementStyle.value), parsedNumber, ($$invalidate(6, parsedUnit), $$invalidate(0, elementStyle)));
			}
		};

		return [
			elementStyle,
			updateElementStyle,
			unitEnd,
			inputWidth,
			unitWidth,
			parsedNumber,
			parsedUnit,
			parsedValueToString,
			isEmpty,
			input_handler,
			input_handler_1
		];
	}

	class NumberUnitInput extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$8, create_fragment$8, safe_not_equal, {
				elementStyle: 0,
				updateElementStyle: 1,
				unitEnd: 2,
				inputWidth: 3,
				unitWidth: 4
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "NumberUnitInput",
				options,
				id: create_fragment$8.name
			});
		}

		get elementStyle() {
			throw new Error("<NumberUnitInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set elementStyle(value) {
			throw new Error("<NumberUnitInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get updateElementStyle() {
			throw new Error("<NumberUnitInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set updateElementStyle(value) {
			throw new Error("<NumberUnitInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get unitEnd() {
			throw new Error("<NumberUnitInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set unitEnd(value) {
			throw new Error("<NumberUnitInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get inputWidth() {
			throw new Error("<NumberUnitInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set inputWidth(value) {
			throw new Error("<NumberUnitInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get unitWidth() {
			throw new Error("<NumberUnitInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set unitWidth(value) {
			throw new Error("<NumberUnitInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	const TagMap = {
	    html: { title: "Root Element", description: "Represents the root (top-level element) of an HTML document, so it is also referred to as the root element. All other elements must be descendants of this element." },
	    head: { title: "Head Element", description: "Contains machine-readable information (metadata) about the document, like its title, scripts, and style sheets." },
	    body: { title: "Body", description: "Represents the content of an HTML document. There can be only one such element in a document." },
	    h1: { title: "Heading 1", description: "Represent six levels of section headings. <h1> is the highest section level and <h6> is the lowest." },
	    h2: { title: "Heading 2", description: "Represent six levels of section headings. <h1> is the highest section level and <h6> is the lowest." },
	    h3: { title: "Heading 3", description: "Represent six levels of section headings. <h1> is the highest section level and <h6> is the lowest." },
	    h4: { title: "Heading 4", description: "Represent six levels of section headings. <h1> is the highest section level and <h6> is the lowest." },
	    h5: { title: "Heading 5", description: "Represent six levels of section headings. <h1> is the highest section level and <h6> is the lowest." },
	    h6: { title: "Heading 6", description: "Represent six levels of section headings. <h1> is the highest section level and <h6> is the lowest." },
	    div: { title: "Division", description: "The generic container for flow content. It has no effect on the content or layout until styled in some way using CSS (e.g., styling is directly applied to it, or some kind of layout model like flexbox is applied to its parent element)." },
	    p: {
	        title: "Paragraph", description: "Represents a paragraph. Paragraphs are usually represented in visual media as blocks of text separated from adjacent blocks by blank lines and/or first-line indentation, but HTML paragraphs can be any structural grouping of related content, such as images or form fields."
	    },
	    a: {
	        title: "Anchor", description: "<a>	Together with its href attribute, creates a hyperlink to web pages, files, email addresses, locations within the current page, or anything else a URL can address."
	    },
	    link: {
	        title: "Link", description: "Specifies relationships between the current document and an external resource. This element is most commonly used to link to CSS but is also used to establish site icons (both 'favicon' style icons and icons for the home screen and apps on mobile devices) among other things."
	    },
	    nav: {
	        title: "Navigation", description: "Represents a section of a page whose purpose is to provide navigation links, either within the current document or to other documents. Common examples of navigation sections are menus, tables of contents, and indexes."
	    },
	    ul: {
	        title: "Unordered List", description: "Represents an unordered list of items, typically rendered as a bulleted list."
	    },
	    ol: {
	        title: "Ordered List", description: "Represents an ordered list of items, typically rendered as a numbered list."
	    },
	    li: {
	        title: "List Item", description: "Represents an item in a list. It can only appear inside a list element, like <ul> or <ol>."
	    },
	    img: {
	        title: "Image", description: "Embeds an image into the document."
	    },
	    video: {
	        title: "Video", description: "Embeds a media player which supports video playback into the document."
	    },
	    audio: {
	        title: "Audio", description: "Embeds a media player which supports audio playback into the document."
	    },
	    iframe: {
	        title: "Inline Frame", description: "Represents a nested browsing context, effectively embedding another HTML page into the current page."
	    },
	    form: {
	        title: "Form", description: "Represents a document section that contains interactive controls to submit information to a web server."
	    },
	    input: {
	        title: "Input", description: "An element is used to create interactive controls for web-based forms in order to accept data from the user."
	    },
	    label: {
	        title: "Label", description: "Represents a caption for an item in a user interface."
	    },
	    select: {
	        title: "Select", description: "Represents a control that provides a menu of options."
	    },
	    option: {
	        title: "Option", description: "Represents an option in a <select> element, or a suggestion of a <datalist> element."
	    },
	    textarea: {
	        title: "Text Area", description: "Represents a multi-line plain-text editing control."
	    },
	    button: {
	        title: "Button", description: "The <button> HTML element is an interactive element activated by a user with a mouse, keyboard, finger, voice command, or other assistive technology. Once activated, it then performs an action, such as submitting a form or opening a dialog. \n\nBy default, HTML buttons are presented in a style resembling the platform the user agent runs on, but you can change buttons' appearance with CSS."
	    },
	    svg: {
	        title: "Scalable Vector Graphics", description: "A language for describing two-dimensional vector graphics in XML."
	    },
	    canvas: {
	        title: "Canvas", description: "Provides a resolution-dependent bitmap area, which can be used for rendering graphs, game graphics, or other visual images on the fly."
	    },
	    footer: {
	        title: "Footer", description: "Represents a footer for its nearest sectioning content or sectioning root element. A footer typically contains information about its section such as who wrote it, links to related documents, copyright data, and the like."
	    },
	    header: {
	        title: "Header", description: "Represents introductory content, typically a group of introductory or navigational aids."
	    },
	    main: {
	        title: "Main", description: "Represents the main content of the <body> of a document or application. The main content area consists of content that is directly related to or expands upon the central topic of a document or central functionality of an application."
	    },
	    section: {
	        title: "Section", description: "Represents a standalone section — which doesn't have a more specific semantic element to represent it — contained within an HTML document."
	    },
	    article: {
	        title: "Article", description: "Represents a self-contained composition in a document, page, application, or site, which is intended to be independently distributable or reusable (e.g., in syndication)."
	    },
	    aside: {
	        title: "Aside", description: "Represents a portion of a document whose content is only indirectly related to the document's main content."
	    },
	    details: {
	        title: "Details", description: "Represents additional information or controls which the user can obtain on demand."
	    },
	    summary: {
	        title: "Summary", description: "Represents a summary, caption, or legend for the rest of the contents of the <details> element, if any."
	    },
	    dialog: {
	        title: "Dialog", description: "Represents a dialog box or other interactive component, such as an inspector or window."
	    },
	    figure: {
	        title: "Figure", description: "Represents self-contained content, potentially with an optional caption, which is specified using the (figcaption) element."
	    },
	    figcaption: {
	        title: "Figure Caption", description: "Represents a caption or legend for the rest of the contents of the <figure> element, if any."
	    },
	    hr: {
	        title: "Horizontal Rule", description: "Represents a thematic break between paragraph-level elements: for example, a change of scene in a story, or a shift of topic within a section."
	    },
	    br: {
	        title: "Line Break", description: "Produces a line break in text (carriage-return). It is useful for writing a poem or an address, where the division of lines is significant."
	    },
	    small: {
	        title: "Small", description: "Represents side-comments such as small print."
	    },
	    strong: {
	        title: "Strong", description: "Indicates that its contents have strong importance, seriousness, or urgency."
	    },
	    em: {
	        title: "Emphasis", description: "Represents stress emphasis of its contents."
	    },
	    mark: {
	        title: "Mark", description: "Represents highlighted text, i.e., a run of text marked for reference purpose, due to its relevance in a particular context."
	    },
	    cite: {
	        title: "Citation", description: "Represents the title of a work (e.g. a book, a paper, an essay, a poem, a score, a song, a script, a film, a TV show, a game, a sculpture, a painting, a theater production, a play, an opera, a musical, an exhibition, a legal case report, or a legal code)."
	    },
	};

	/* src/lib/components/editor/inputs/TagInfo.svelte generated by Svelte v4.2.10 */
	const file$6 = "src/lib/components/editor/inputs/TagInfo.svelte";

	// (20:2) {#if showMore}
	function create_if_block$3(ctx) {
		let div;
		let p0;
		let t0_value = TagMap[/*el*/ ctx[0].tagName.toLowerCase()].description + "";
		let t0;
		let t1;
		let p1;
		let a;
		let div_transition;
		let current;

		const block = {
			c: function create() {
				div = element("div");
				p0 = element("p");
				t0 = text(t0_value);
				t1 = space();
				p1 = element("p");
				a = element("a");
				a.textContent = "Learn more";
				attr_dev(p0, "class", "pt-2 whitespace-pre-line");
				add_location(p0, file$6, 22, 6, 622);
				attr_dev(a, "href", "https://developer.mozilla.org/en-US/docs/Web/HTML/Element");
				attr_dev(a, "target", "_blank");
				add_location(a, file$6, 26, 8, 774);
				attr_dev(p1, "class", "pt-2 text-xs underline");
				add_location(p1, file$6, 25, 6, 731);
				add_location(div, file$6, 21, 4, 593);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, p0);
				append_dev(p0, t0);
				append_dev(div, t1);
				append_dev(div, p1);
				append_dev(p1, a);
				current = true;
			},
			p: function update(ctx, dirty) {
				if ((!current || dirty & /*el*/ 1) && t0_value !== (t0_value = TagMap[/*el*/ ctx[0].tagName.toLowerCase()].description + "")) set_data_dev(t0, t0_value);
			},
			i: function intro(local) {
				if (current) return;

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, true);
						div_transition.run(1);
					});
				}

				current = true;
			},
			o: function outro(local) {
				if (local) {
					if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, false);
					div_transition.run(0);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (detaching && div_transition) div_transition.end();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$3.name,
			type: "if",
			source: "(20:2) {#if showMore}",
			ctx
		});

		return block;
	}

	function create_fragment$7(ctx) {
		let button;
		let p;
		let span0;
		let t0_value = /*el*/ ctx[0].tagName.toLowerCase() + "";
		let t0;
		let t1;
		let span1;

		let t2_value = (TagMap[/*el*/ ctx[0].tagName.toLowerCase()].title.toLowerCase() == /*el*/ ctx[0].tagName.toLowerCase()
		? ""
		: `${TagMap[/*el*/ ctx[0].tagName.toLowerCase()].title}`) + "";

		let t2;
		let t3;
		let mounted;
		let dispose;
		let if_block = /*showMore*/ ctx[1] && create_if_block$3(ctx);

		const block = {
			c: function create() {
				button = element("button");
				p = element("p");
				span0 = element("span");
				t0 = text(t0_value);
				t1 = space();
				span1 = element("span");
				t2 = text(t2_value);
				t3 = space();
				if (if_block) if_block.c();
				attr_dev(span0, "class", "capitalize");
				add_location(span0, file$6, 12, 4, 321);
				add_location(span1, file$6, 13, 4, 384);
				attr_dev(p, "class", "space-x-1");
				add_location(p, file$6, 11, 2, 295);
				attr_dev(button, "class", "text-start w-full p-2 mb-3 bg-stone-800 rounded text-xs cursor-pointer");
				add_location(button, file$6, 7, 0, 160);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				append_dev(button, p);
				append_dev(p, span0);
				append_dev(span0, t0);
				append_dev(p, t1);
				append_dev(p, span1);
				append_dev(span1, t2);
				append_dev(button, t3);
				if (if_block) if_block.m(button, null);

				if (!mounted) {
					dispose = listen_dev(button, "click", /*click_handler*/ ctx[2], false, false, false, false);
					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*el*/ 1 && t0_value !== (t0_value = /*el*/ ctx[0].tagName.toLowerCase() + "")) set_data_dev(t0, t0_value);

				if (dirty & /*el*/ 1 && t2_value !== (t2_value = (TagMap[/*el*/ ctx[0].tagName.toLowerCase()].title.toLowerCase() == /*el*/ ctx[0].tagName.toLowerCase()
				? ""
				: `${TagMap[/*el*/ ctx[0].tagName.toLowerCase()].title}`) + "")) set_data_dev(t2, t2_value);

				if (/*showMore*/ ctx[1]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*showMore*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$3(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(button, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				transition_in(if_block);
			},
			o: function outro(local) {
				transition_out(if_block);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				if (if_block) if_block.d();
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$7.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$7($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('TagInfo', slots, []);
		let { el } = $$props;
		let showMore = false;

		$$self.$$.on_mount.push(function () {
			if (el === undefined && !('el' in $$props || $$self.$$.bound[$$self.$$.props['el']])) {
				console.warn("<TagInfo> was created without expected prop 'el'");
			}
		});

		const writable_props = ['el'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TagInfo> was created with unknown prop '${key}'`);
		});

		const click_handler = () => $$invalidate(1, showMore = !showMore);

		$$self.$$set = $$props => {
			if ('el' in $$props) $$invalidate(0, el = $$props.el);
		};

		$$self.$capture_state = () => ({ TagMap, slide, el, showMore });

		$$self.$inject_state = $$props => {
			if ('el' in $$props) $$invalidate(0, el = $$props.el);
			if ('showMore' in $$props) $$invalidate(1, showMore = $$props.showMore);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [el, showMore, click_handler];
	}

	class TagInfo extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$7, create_fragment$7, safe_not_equal, { el: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "TagInfo",
				options,
				id: create_fragment$7.name
			});
		}

		get el() {
			throw new Error("<TagInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set el(value) {
			throw new Error("<TagInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/editor/inputs/SizeSection.svelte generated by Svelte v4.2.10 */
	const file$5 = "src/lib/components/editor/inputs/SizeSection.svelte";

	function get_each_context$1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[2] = list[i];
		return child_ctx;
	}

	// (53:8) {:else}
	function create_else_block$2(ctx) {
		let p;
		let t_value = /*elementStyle*/ ctx[2].displayName + "";
		let t;

		const block = {
			c: function create() {
				p = element("p");
				t = text(t_value);
				attr_dev(p, "class", "text-xs text-left opacity-60");
				add_location(p, file$5, 56, 10, 2200);
			},
			m: function mount(target, anchor) {
				insert_dev(target, p, anchor);
				append_dev(p, t);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*elementStyles*/ 1 && t_value !== (t_value = /*elementStyle*/ ctx[2].displayName + "")) set_data_dev(t, t_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(p);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$2.name,
			type: "else",
			source: "(53:8) {:else}",
			ctx
		});

		return block;
	}

	// (27:54) 
	function create_if_block_1$2(ctx) {
		let svg;
		let g;
		let path;
		let defs;
		let clipPath;
		let rect;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				g = svg_element("g");
				path = svg_element("path");
				defs = svg_element("defs");
				clipPath = svg_element("clipPath");
				rect = svg_element("rect");
				attr_dev(path, "d", "M15.25 15.25H16.75V16.75H15.25V15.25ZM15.25 13.75H16.75V12.25H15.25V13.75ZM3.25 10.75H4.75V9.25H3.25V10.75ZM3.25 13.75H4.75V12.25H3.25V13.75ZM3.25 7.75H4.75V6.25H3.25V7.75ZM3.25 4.75H4.75V3.25H3.25V4.75ZM6.25 4.75H7.75V3.25H6.25V4.75ZM12.25 16.75H13.75V15.25H12.25V16.75ZM9.25 16.75H10.75V15.25H9.25V16.75ZM12.25 16.75H13.75V15.25H12.25V16.75ZM6.25 16.75H7.75V15.25H6.25V16.75ZM3.25 16.75H4.75V15.25H3.25V16.75ZM16.75 7C16.75 4.93 15.07 3.25 13 3.25H9.25V4.75H13C14.2375 4.75 15.25 5.7625 15.25 7V10.75H16.75V7Z");
				attr_dev(path, "fill", "white");
				attr_dev(path, "fill-opacity", "0.6");
				add_location(path, file$5, 38, 14, 1234);
				attr_dev(g, "clip-path", "url(#clip0_138_14625)");
				add_location(g, file$5, 37, 12, 1182);
				attr_dev(rect, "width", "18");
				attr_dev(rect, "height", "18");
				attr_dev(rect, "fill", "white");
				attr_dev(rect, "transform", "translate(1 1)");
				add_location(rect, file$5, 46, 16, 1951);
				attr_dev(clipPath, "id", "clip0_138_14625");
				add_location(clipPath, file$5, 45, 14, 1903);
				add_location(defs, file$5, 44, 12, 1882);
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 20 20");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$5, 30, 10, 1003);
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, g);
				append_dev(g, path);
				append_dev(svg, defs);
				append_dev(defs, clipPath);
				append_dev(clipPath, rect);
			},
			p: noop$3,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$2.name,
			type: "if",
			source: "(27:54) ",
			ctx
		});

		return block;
	}

	// (12:8) {#if elementStyle.key === "rotate"}
	function create_if_block$2(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "d", "M3 3L3 9.46154M17 17L10.2692 17M10.2692 17L3 17L3 9.46154M10.2692 17L10.2692 16.7308C10.2692 12.7161 7.01468 9.46154 3 9.46154V9.46154");
				attr_dev(path, "stroke", "white");
				attr_dev(path, "stroke-opacity", "0.6");
				attr_dev(path, "stroke-width", "1.2");
				add_location(path, file$5, 22, 12, 650);
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 20 20");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$5, 15, 10, 471);
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: noop$3,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$2.name,
			type: "if",
			source: "(12:8) {#if elementStyle.key === \\\"rotate\\\"}",
			ctx
		});

		return block;
	}

	// (9:2) {#each elementStyles as elementStyle}
	function create_each_block$1(ctx) {
		let div1;
		let div0;
		let t0;
		let numberunitinput;
		let t1;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*elementStyle*/ ctx[2].key === "rotate") return create_if_block$2;
			if (/*elementStyle*/ ctx[2].key === "borderRadius") return create_if_block_1$2;
			return create_else_block$2;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		numberunitinput = new NumberUnitInput({
				props: {
					elementStyle: /*elementStyle*/ ctx[2],
					updateElementStyle: /*updateElementStyle*/ ctx[1]
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				div1 = element("div");
				div0 = element("div");
				if_block.c();
				t0 = space();
				create_component(numberunitinput.$$.fragment);
				t1 = space();
				attr_dev(div0, "class", "w-24");
				add_location(div0, file$5, 13, 6, 398);
				attr_dev(div1, "class", "flex flex-row items-center pb-2");
				add_location(div1, file$5, 12, 4, 346);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, div0);
				if_block.m(div0, null);
				append_dev(div1, t0);
				mount_component(numberunitinput, div1, null);
				append_dev(div1, t1);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div0, null);
					}
				}

				const numberunitinput_changes = {};
				if (dirty & /*elementStyles*/ 1) numberunitinput_changes.elementStyle = /*elementStyle*/ ctx[2];
				if (dirty & /*updateElementStyle*/ 2) numberunitinput_changes.updateElementStyle = /*updateElementStyle*/ ctx[1];
				numberunitinput.$set(numberunitinput_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(numberunitinput.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(numberunitinput.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}

				if_block.d();
				destroy_component(numberunitinput);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$1.name,
			type: "each",
			source: "(9:2) {#each elementStyles as elementStyle}",
			ctx
		});

		return block;
	}

	function create_fragment$6(ctx) {
		let div;
		let h20;
		let t1;
		let h21;
		let t3;
		let current;
		let each_value = ensure_array_like_dev(/*elementStyles*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				div = element("div");
				h20 = element("h2");
				h20.textContent = "Fixed Width";
				t1 = space();
				h21 = element("h2");
				h21.textContent = "Fixed Height";
				t3 = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(h20, "class", "pb-2 text-xs");
				add_location(h20, file$5, 9, 2, 215);
				attr_dev(h21, "class", "pb-2 text-xs");
				add_location(h21, file$5, 10, 2, 259);
				attr_dev(div, "class", "mt-4 grid grid-cols-2 gap-x-4");
				add_location(div, file$5, 8, 0, 169);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, h20);
				append_dev(div, t1);
				append_dev(div, h21);
				append_dev(div, t3);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*elementStyles, updateElementStyle*/ 3) {
					each_value = ensure_array_like_dev(/*elementStyles*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$1(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$1(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$6.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$6($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('SizeSection', slots, []);
		let { elementStyles = [] } = $$props;

		let { updateElementStyle = (key, value) => {
			
		} } = $$props;

		const writable_props = ['elementStyles', 'updateElementStyle'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SizeSection> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('elementStyles' in $$props) $$invalidate(0, elementStyles = $$props.elementStyles);
			if ('updateElementStyle' in $$props) $$invalidate(1, updateElementStyle = $$props.updateElementStyle);
		};

		$$self.$capture_state = () => ({
			NumberUnitInput,
			elementStyles,
			updateElementStyle
		});

		$$self.$inject_state = $$props => {
			if ('elementStyles' in $$props) $$invalidate(0, elementStyles = $$props.elementStyles);
			if ('updateElementStyle' in $$props) $$invalidate(1, updateElementStyle = $$props.updateElementStyle);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [elementStyles, updateElementStyle];
	}

	class SizeSection extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$6, create_fragment$6, safe_not_equal, { elementStyles: 0, updateElementStyle: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "SizeSection",
				options,
				id: create_fragment$6.name
			});
		}

		get elementStyles() {
			throw new Error("<SizeSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set elementStyles(value) {
			throw new Error("<SizeSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get updateElementStyle() {
			throw new Error("<SizeSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set updateElementStyle(value) {
			throw new Error("<SizeSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/editor/inputs/SpacingInput.svelte generated by Svelte v4.2.10 */
	const file$4 = "src/lib/components/editor/inputs/SpacingInput.svelte";

	function create_fragment$5(ctx) {
		let div7;
		let div0;
		let t0;
		let div6;
		let div1;
		let numberunitinput0;
		let t1;
		let div2;
		let numberunitinput1;
		let t2;
		let div3;
		let numberunitinput2;
		let t3;
		let numberunitinput3;
		let t4;
		let numberunitinput4;
		let t5;
		let numberunitinput5;
		let t6;
		let div4;
		let numberunitinput6;
		let t7;
		let div5;
		let numberunitinput7;
		let current;

		numberunitinput0 = new NumberUnitInput({
				props: {
					updateElementStyle: /*updateElementStyle*/ ctx[0],
					elementStyle: /*elementStyleMap*/ ctx[1]["marginTop"]
				},
				$$inline: true
			});

		numberunitinput1 = new NumberUnitInput({
				props: {
					updateElementStyle: /*updateElementStyle*/ ctx[0],
					elementStyle: /*elementStyleMap*/ ctx[1]["paddingTop"]
				},
				$$inline: true
			});

		numberunitinput2 = new NumberUnitInput({
				props: {
					inputWidth: "w-6",
					unitWidth: "w-6",
					updateElementStyle: /*updateElementStyle*/ ctx[0],
					elementStyle: /*elementStyleMap*/ ctx[1]["marginLeft"]
				},
				$$inline: true
			});

		numberunitinput3 = new NumberUnitInput({
				props: {
					inputWidth: "w-6",
					unitWidth: "w-6",
					updateElementStyle: /*updateElementStyle*/ ctx[0],
					elementStyle: /*elementStyleMap*/ ctx[1]["paddingLeft"]
				},
				$$inline: true
			});

		numberunitinput4 = new NumberUnitInput({
				props: {
					inputWidth: "w-6",
					unitWidth: "w-6",
					updateElementStyle: /*updateElementStyle*/ ctx[0],
					elementStyle: /*elementStyleMap*/ ctx[1]["paddingRight"]
				},
				$$inline: true
			});

		numberunitinput5 = new NumberUnitInput({
				props: {
					inputWidth: "w-6",
					unitWidth: "w-6",
					updateElementStyle: /*updateElementStyle*/ ctx[0],
					elementStyle: /*elementStyleMap*/ ctx[1]["marginRight"]
				},
				$$inline: true
			});

		numberunitinput6 = new NumberUnitInput({
				props: {
					updateElementStyle: /*updateElementStyle*/ ctx[0],
					elementStyle: /*elementStyleMap*/ ctx[1]["paddingBottom"]
				},
				$$inline: true
			});

		numberunitinput7 = new NumberUnitInput({
				props: {
					updateElementStyle: /*updateElementStyle*/ ctx[0],
					elementStyle: /*elementStyleMap*/ ctx[1]["marginBottom"]
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				div7 = element("div");
				div0 = element("div");
				t0 = space();
				div6 = element("div");
				div1 = element("div");
				create_component(numberunitinput0.$$.fragment);
				t1 = space();
				div2 = element("div");
				create_component(numberunitinput1.$$.fragment);
				t2 = space();
				div3 = element("div");
				create_component(numberunitinput2.$$.fragment);
				t3 = space();
				create_component(numberunitinput3.$$.fragment);
				t4 = space();
				create_component(numberunitinput4.$$.fragment);
				t5 = space();
				create_component(numberunitinput5.$$.fragment);
				t6 = space();
				div4 = element("div");
				create_component(numberunitinput6.$$.fragment);
				t7 = space();
				div5 = element("div");
				create_component(numberunitinput7.$$.fragment);
				attr_dev(div0, "class", "absolute rounded bg-stone-300 opacity-10 w-[100px] h-[90px] top-1/2 left-1/2 -translate-x-1/2 -translate-y-[40px] pointer-events-none");
				add_location(div0, file$4, 15, 2, 305);
				attr_dev(div1, "class", "col-start-1 col-end-6 flex justify-center");
				add_location(div1, file$4, 22, 4, 605);
				attr_dev(div2, "class", "col-start-1 col-end-6 flex justify-center");
				add_location(div2, file$4, 28, 4, 789);
				attr_dev(div3, "class", "col-start-1 col-end-6 flex justify-center");
				add_location(div3, file$4, 34, 4, 974);
				attr_dev(div4, "class", "col-start-1 col-end-6 flex justify-center");
				add_location(div4, file$4, 60, 4, 1701);
				attr_dev(div5, "class", "col-start-1 col-end-6 flex justify-center");
				add_location(div5, file$4, 66, 4, 1889);
				attr_dev(div6, "class", "w-[198px] h-fit grid grid-cols-5 grid-rows-5 space-y-3 py-2 text-xs bg-background border border-border rounded");
				add_location(div6, file$4, 19, 2, 469);
				attr_dev(div7, "class", "relative");
				add_location(div7, file$4, 14, 0, 280);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div7, anchor);
				append_dev(div7, div0);
				append_dev(div7, t0);
				append_dev(div7, div6);
				append_dev(div6, div1);
				mount_component(numberunitinput0, div1, null);
				append_dev(div6, t1);
				append_dev(div6, div2);
				mount_component(numberunitinput1, div2, null);
				append_dev(div6, t2);
				append_dev(div6, div3);
				mount_component(numberunitinput2, div3, null);
				append_dev(div3, t3);
				mount_component(numberunitinput3, div3, null);
				append_dev(div3, t4);
				mount_component(numberunitinput4, div3, null);
				append_dev(div3, t5);
				mount_component(numberunitinput5, div3, null);
				append_dev(div6, t6);
				append_dev(div6, div4);
				mount_component(numberunitinput6, div4, null);
				append_dev(div6, t7);
				append_dev(div6, div5);
				mount_component(numberunitinput7, div5, null);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const numberunitinput0_changes = {};
				if (dirty & /*updateElementStyle*/ 1) numberunitinput0_changes.updateElementStyle = /*updateElementStyle*/ ctx[0];
				if (dirty & /*elementStyleMap*/ 2) numberunitinput0_changes.elementStyle = /*elementStyleMap*/ ctx[1]["marginTop"];
				numberunitinput0.$set(numberunitinput0_changes);
				const numberunitinput1_changes = {};
				if (dirty & /*updateElementStyle*/ 1) numberunitinput1_changes.updateElementStyle = /*updateElementStyle*/ ctx[0];
				if (dirty & /*elementStyleMap*/ 2) numberunitinput1_changes.elementStyle = /*elementStyleMap*/ ctx[1]["paddingTop"];
				numberunitinput1.$set(numberunitinput1_changes);
				const numberunitinput2_changes = {};
				if (dirty & /*updateElementStyle*/ 1) numberunitinput2_changes.updateElementStyle = /*updateElementStyle*/ ctx[0];
				if (dirty & /*elementStyleMap*/ 2) numberunitinput2_changes.elementStyle = /*elementStyleMap*/ ctx[1]["marginLeft"];
				numberunitinput2.$set(numberunitinput2_changes);
				const numberunitinput3_changes = {};
				if (dirty & /*updateElementStyle*/ 1) numberunitinput3_changes.updateElementStyle = /*updateElementStyle*/ ctx[0];
				if (dirty & /*elementStyleMap*/ 2) numberunitinput3_changes.elementStyle = /*elementStyleMap*/ ctx[1]["paddingLeft"];
				numberunitinput3.$set(numberunitinput3_changes);
				const numberunitinput4_changes = {};
				if (dirty & /*updateElementStyle*/ 1) numberunitinput4_changes.updateElementStyle = /*updateElementStyle*/ ctx[0];
				if (dirty & /*elementStyleMap*/ 2) numberunitinput4_changes.elementStyle = /*elementStyleMap*/ ctx[1]["paddingRight"];
				numberunitinput4.$set(numberunitinput4_changes);
				const numberunitinput5_changes = {};
				if (dirty & /*updateElementStyle*/ 1) numberunitinput5_changes.updateElementStyle = /*updateElementStyle*/ ctx[0];
				if (dirty & /*elementStyleMap*/ 2) numberunitinput5_changes.elementStyle = /*elementStyleMap*/ ctx[1]["marginRight"];
				numberunitinput5.$set(numberunitinput5_changes);
				const numberunitinput6_changes = {};
				if (dirty & /*updateElementStyle*/ 1) numberunitinput6_changes.updateElementStyle = /*updateElementStyle*/ ctx[0];
				if (dirty & /*elementStyleMap*/ 2) numberunitinput6_changes.elementStyle = /*elementStyleMap*/ ctx[1]["paddingBottom"];
				numberunitinput6.$set(numberunitinput6_changes);
				const numberunitinput7_changes = {};
				if (dirty & /*updateElementStyle*/ 1) numberunitinput7_changes.updateElementStyle = /*updateElementStyle*/ ctx[0];
				if (dirty & /*elementStyleMap*/ 2) numberunitinput7_changes.elementStyle = /*elementStyleMap*/ ctx[1]["marginBottom"];
				numberunitinput7.$set(numberunitinput7_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(numberunitinput0.$$.fragment, local);
				transition_in(numberunitinput1.$$.fragment, local);
				transition_in(numberunitinput2.$$.fragment, local);
				transition_in(numberunitinput3.$$.fragment, local);
				transition_in(numberunitinput4.$$.fragment, local);
				transition_in(numberunitinput5.$$.fragment, local);
				transition_in(numberunitinput6.$$.fragment, local);
				transition_in(numberunitinput7.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(numberunitinput0.$$.fragment, local);
				transition_out(numberunitinput1.$$.fragment, local);
				transition_out(numberunitinput2.$$.fragment, local);
				transition_out(numberunitinput3.$$.fragment, local);
				transition_out(numberunitinput4.$$.fragment, local);
				transition_out(numberunitinput5.$$.fragment, local);
				transition_out(numberunitinput6.$$.fragment, local);
				transition_out(numberunitinput7.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div7);
				}

				destroy_component(numberunitinput0);
				destroy_component(numberunitinput1);
				destroy_component(numberunitinput2);
				destroy_component(numberunitinput3);
				destroy_component(numberunitinput4);
				destroy_component(numberunitinput5);
				destroy_component(numberunitinput6);
				destroy_component(numberunitinput7);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$5.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$5($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('SpacingInput', slots, []);
		let { elementStyles = [] } = $$props;
		let { updateElementStyle } = $$props;
		let elementStyleMap;

		$$self.$$.on_mount.push(function () {
			if (updateElementStyle === undefined && !('updateElementStyle' in $$props || $$self.$$.bound[$$self.$$.props['updateElementStyle']])) {
				console.warn("<SpacingInput> was created without expected prop 'updateElementStyle'");
			}
		});

		const writable_props = ['elementStyles', 'updateElementStyle'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SpacingInput> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('elementStyles' in $$props) $$invalidate(2, elementStyles = $$props.elementStyles);
			if ('updateElementStyle' in $$props) $$invalidate(0, updateElementStyle = $$props.updateElementStyle);
		};

		$$self.$capture_state = () => ({
			NumberUnitInput,
			elementStyles,
			updateElementStyle,
			elementStyleMap
		});

		$$self.$inject_state = $$props => {
			if ('elementStyles' in $$props) $$invalidate(2, elementStyles = $$props.elementStyles);
			if ('updateElementStyle' in $$props) $$invalidate(0, updateElementStyle = $$props.updateElementStyle);
			if ('elementStyleMap' in $$props) $$invalidate(1, elementStyleMap = $$props.elementStyleMap);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*elementStyles*/ 4) {
				$$invalidate(1, elementStyleMap = elementStyles.reduce(
					(acc, style) => {
						acc[style.key] = style;
						return acc;
					},
					{}
				));
			}
		};

		return [updateElementStyle, elementStyleMap, elementStyles];
	}

	class SpacingInput extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$5, create_fragment$5, safe_not_equal, { elementStyles: 2, updateElementStyle: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "SpacingInput",
				options,
				id: create_fragment$5.name
			});
		}

		get elementStyles() {
			throw new Error("<SpacingInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set elementStyles(value) {
			throw new Error("<SpacingInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get updateElementStyle() {
			throw new Error("<SpacingInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set updateElementStyle(value) {
			throw new Error("<SpacingInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/editor/CssEditor.svelte generated by Svelte v4.2.10 */

	const { Object: Object_1 } = globals;
	const file$3 = "src/lib/components/editor/CssEditor.svelte";

	function get_each_context(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[4] = list[i][0];
		child_ctx[5] = list[i][1];
		return child_ctx;
	}

	function get_each_context_1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[8] = list[i];
		child_ctx[10] = i;
		return child_ctx;
	}

	// (42:4) {:else}
	function create_else_block$1(ctx) {
		let accordion_item;
		let current;

		accordion_item = new Accordion_item({
				props: {
					"data-state": "open",
					value: /*groupKey*/ ctx[4],
					$$slots: { default: [create_default_slot_4$1] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(accordion_item.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(accordion_item, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const accordion_item_changes = {};
				if (dirty & /*groupedStyles*/ 2) accordion_item_changes.value = /*groupKey*/ ctx[4];

				if (dirty & /*$$scope, groupedStyles, el*/ 2051) {
					accordion_item_changes.$$scope = { dirty, ctx };
				}

				accordion_item.$set(accordion_item_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(accordion_item.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(accordion_item.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(accordion_item, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$1.name,
			type: "else",
			source: "(42:4) {:else}",
			ctx
		});

		return block;
	}

	// (31:52) 
	function create_if_block_1$1(ctx) {
		let accordion_item;
		let current;

		accordion_item = new Accordion_item({
				props: {
					"data-state": "open",
					value: /*groupKey*/ ctx[4],
					$$slots: { default: [create_default_slot_1$2] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(accordion_item.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(accordion_item, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const accordion_item_changes = {};
				if (dirty & /*groupedStyles*/ 2) accordion_item_changes.value = /*groupKey*/ ctx[4];

				if (dirty & /*$$scope, groupedStyles*/ 2050) {
					accordion_item_changes.$$scope = { dirty, ctx };
				}

				accordion_item.$set(accordion_item_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(accordion_item.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(accordion_item.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(accordion_item, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$1.name,
			type: "if",
			source: "(31:52) ",
			ctx
		});

		return block;
	}

	// (28:4) {#if groupKey == ElementStyleGroup.Size}
	function create_if_block$1(ctx) {
		let sizesection;
		let t;
		let separator;
		let current;

		sizesection = new SizeSection({
				props: {
					elementStyles: /*elementStyles*/ ctx[5],
					updateElementStyle: /*updateElementStyle*/ ctx[2]
				},
				$$inline: true
			});

		separator = new Separator({ props: { class: "mt-4" }, $$inline: true });

		const block = {
			c: function create() {
				create_component(sizesection.$$.fragment);
				t = space();
				create_component(separator.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(sizesection, target, anchor);
				insert_dev(target, t, anchor);
				mount_component(separator, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const sizesection_changes = {};
				if (dirty & /*groupedStyles*/ 2) sizesection_changes.elementStyles = /*elementStyles*/ ctx[5];
				sizesection.$set(sizesection_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(sizesection.$$.fragment, local);
				transition_in(separator.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(sizesection.$$.fragment, local);
				transition_out(separator.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
				}

				destroy_component(sizesection, detaching);
				destroy_component(separator, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$1.name,
			type: "if",
			source: "(28:4) {#if groupKey == ElementStyleGroup.Size}",
			ctx
		});

		return block;
	}

	// (44:8) <Accordion.Trigger           >
	function create_default_slot_6$1(ctx) {
		let h2;
		let t_value = /*groupKey*/ ctx[4] + "";
		let t;

		const block = {
			c: function create() {
				h2 = element("h2");
				t = text(t_value);
				attr_dev(h2, "class", "text-xs font-semibold");
				add_location(h2, file$3, 54, 11, 1890);
			},
			m: function mount(target, anchor) {
				insert_dev(target, h2, anchor);
				append_dev(h2, t);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*groupedStyles*/ 2 && t_value !== (t_value = /*groupKey*/ ctx[4] + "")) set_data_dev(t, t_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(h2);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_6$1.name,
			type: "slot",
			source: "(44:8) <Accordion.Trigger           >",
			ctx
		});

		return block;
	}

	// (50:10) {#if groupKey == ElementStyleGroup.Text}
	function create_if_block_5(ctx) {
		let taginfo;
		let current;

		taginfo = new TagInfo({
				props: { el: /*el*/ ctx[0] },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(taginfo.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(taginfo, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const taginfo_changes = {};
				if (dirty & /*el*/ 1) taginfo_changes.el = /*el*/ ctx[0];
				taginfo.$set(taginfo_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(taginfo.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(taginfo.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(taginfo, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_5.name,
			type: "if",
			source: "(50:10) {#if groupKey == ElementStyleGroup.Text}",
			ctx
		});

		return block;
	}

	// (70:16) {:else}
	function create_else_block_1(ctx) {
		let input;
		let current;

		function input_handler(...args) {
			return /*input_handler*/ ctx[3](/*elementStyle*/ ctx[8], ...args);
		}

		input = new Input({
				props: {
					type: "text",
					placeholder: /*elementStyle*/ ctx[8].type,
					class: "w-24 text-xs",
					value: /*elementStyle*/ ctx[8].value
				},
				$$inline: true
			});

		input.$on("input", input_handler);

		const block = {
			c: function create() {
				create_component(input.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(input, target, anchor);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const input_changes = {};
				if (dirty & /*groupedStyles*/ 2) input_changes.placeholder = /*elementStyle*/ ctx[8].type;
				if (dirty & /*groupedStyles*/ 2) input_changes.value = /*elementStyle*/ ctx[8].value;
				input.$set(input_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(input.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(input.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(input, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_1.name,
			type: "else",
			source: "(70:16) {:else}",
			ctx
		});

		return block;
	}

	// (63:72) 
	function create_if_block_4(ctx) {
		let numberunitinput;
		let current;

		numberunitinput = new NumberUnitInput({
				props: {
					unitWidth: "w-6",
					unitEnd: true,
					elementStyle: /*elementStyle*/ ctx[8],
					updateElementStyle: /*updateElementStyle*/ ctx[2]
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(numberunitinput.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(numberunitinput, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const numberunitinput_changes = {};
				if (dirty & /*groupedStyles*/ 2) numberunitinput_changes.elementStyle = /*elementStyle*/ ctx[8];
				numberunitinput.$set(numberunitinput_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(numberunitinput.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(numberunitinput.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(numberunitinput, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_4.name,
			type: "if",
			source: "(63:72) ",
			ctx
		});

		return block;
	}

	// (61:71) 
	function create_if_block_3(ctx) {
		let colorinput;
		let current;

		colorinput = new ColorInput({
				props: {
					elementStyle: /*elementStyle*/ ctx[8],
					updateElementStyle: /*updateElementStyle*/ ctx[2]
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(colorinput.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(colorinput, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const colorinput_changes = {};
				if (dirty & /*groupedStyles*/ 2) colorinput_changes.elementStyle = /*elementStyle*/ ctx[8];
				colorinput.$set(colorinput_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(colorinput.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(colorinput.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(colorinput, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3.name,
			type: "if",
			source: "(61:71) ",
			ctx
		});

		return block;
	}

	// (59:16) {#if elementStyle.type === ElementStyleType.Select}
	function create_if_block_2(ctx) {
		let selectinput;
		let current;

		selectinput = new SelectInput({
				props: {
					elementStyle: /*elementStyle*/ ctx[8],
					updateElementStyle: /*updateElementStyle*/ ctx[2]
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(selectinput.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(selectinput, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const selectinput_changes = {};
				if (dirty & /*groupedStyles*/ 2) selectinput_changes.elementStyle = /*elementStyle*/ ctx[8];
				selectinput.$set(selectinput_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(selectinput.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(selectinput.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(selectinput, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2.name,
			type: "if",
			source: "(59:16) {#if elementStyle.type === ElementStyleType.Select}",
			ctx
		});

		return block;
	}

	// (53:10) {#each elementStyles as elementStyle, i}
	function create_each_block_1(ctx) {
		let div1;
		let p;
		let t0_value = /*elementStyle*/ ctx[8].displayName + "";
		let t0;
		let t1;
		let div0;
		let current_block_type_index;
		let if_block;
		let t2;
		let current;
		const if_block_creators = [create_if_block_2, create_if_block_3, create_if_block_4, create_else_block_1];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (/*elementStyle*/ ctx[8].type === ElementStyleType.Select) return 0;
			if (/*elementStyle*/ ctx[8].type === ElementStyleType.Color) return 1;
			if (/*elementStyle*/ ctx[8].type === ElementStyleType.Number) return 2;
			return 3;
		}

		current_block_type_index = select_block_type_1(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				div1 = element("div");
				p = element("p");
				t0 = text(t0_value);
				t1 = space();
				div0 = element("div");
				if_block.c();
				t2 = space();
				attr_dev(p, "class", "text-xs w-24 mr-2 text-start opacity-60");
				add_location(p, file$3, 64, 14, 2259);
				attr_dev(div0, "class", "text-end ml-auto");
				add_location(div0, file$3, 67, 14, 2387);
				attr_dev(div1, "class", "flex flex-row items-center " + (/*i*/ ctx[10] === 0 ? '' : 'mt-4'));
				add_location(div1, file$3, 63, 12, 2180);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, p);
				append_dev(p, t0);
				append_dev(div1, t1);
				append_dev(div1, div0);
				if_blocks[current_block_type_index].m(div0, null);
				append_dev(div1, t2);
				current = true;
			},
			p: function update(ctx, dirty) {
				if ((!current || dirty & /*groupedStyles*/ 2) && t0_value !== (t0_value = /*elementStyle*/ ctx[8].displayName + "")) set_data_dev(t0, t0_value);
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div0, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}

				if_blocks[current_block_type_index].d();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block_1.name,
			type: "each",
			source: "(53:10) {#each elementStyles as elementStyle, i}",
			ctx
		});

		return block;
	}

	// (49:8) <Accordion.Content>
	function create_default_slot_5$1(ctx) {
		let t;
		let each_1_anchor;
		let current;
		let if_block = /*groupKey*/ ctx[4] == ElementStyleGroup.Text && create_if_block_5(ctx);
		let each_value_1 = ensure_array_like_dev(/*elementStyles*/ ctx[5]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				t = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, t, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert_dev(target, each_1_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (/*groupKey*/ ctx[4] == ElementStyleGroup.Text) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*groupedStyles*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_5(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(t.parentNode, t);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}

				if (dirty & /*Object, groupedStyles, updateElementStyle*/ 6) {
					each_value_1 = ensure_array_like_dev(/*elementStyles*/ ctx[5]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_1(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
					detach_dev(each_1_anchor);
				}

				if (if_block) if_block.d(detaching);
				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_5$1.name,
			type: "slot",
			source: "(49:8) <Accordion.Content>",
			ctx
		});

		return block;
	}

	// (43:6) <Accordion.Item data-state="open" value={groupKey}>
	function create_default_slot_4$1(ctx) {
		let accordion_trigger;
		let t0;
		let accordion_content;
		let t1;
		let current;

		accordion_trigger = new Accordion_trigger({
				props: {
					$$slots: { default: [create_default_slot_6$1] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		accordion_content = new Accordion_content({
				props: {
					$$slots: { default: [create_default_slot_5$1] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(accordion_trigger.$$.fragment);
				t0 = space();
				create_component(accordion_content.$$.fragment);
				t1 = space();
			},
			m: function mount(target, anchor) {
				mount_component(accordion_trigger, target, anchor);
				insert_dev(target, t0, anchor);
				mount_component(accordion_content, target, anchor);
				insert_dev(target, t1, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const accordion_trigger_changes = {};

				if (dirty & /*$$scope, groupedStyles*/ 2050) {
					accordion_trigger_changes.$$scope = { dirty, ctx };
				}

				accordion_trigger.$set(accordion_trigger_changes);
				const accordion_content_changes = {};

				if (dirty & /*$$scope, groupedStyles, el*/ 2051) {
					accordion_content_changes.$$scope = { dirty, ctx };
				}

				accordion_content.$set(accordion_content_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(accordion_trigger.$$.fragment, local);
				transition_in(accordion_content.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(accordion_trigger.$$.fragment, local);
				transition_out(accordion_content.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t0);
					detach_dev(t1);
				}

				destroy_component(accordion_trigger, detaching);
				destroy_component(accordion_content, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_4$1.name,
			type: "slot",
			source: "(43:6) <Accordion.Item data-state=\\\"open\\\" value={groupKey}>",
			ctx
		});

		return block;
	}

	// (33:8) <Accordion.Trigger           >
	function create_default_slot_3$2(ctx) {
		let h2;
		let t_value = /*groupKey*/ ctx[4] + "";
		let t;

		const block = {
			c: function create() {
				h2 = element("h2");
				t = text(t_value);
				attr_dev(h2, "class", "text-xs");
				add_location(h2, file$3, 43, 11, 1548);
			},
			m: function mount(target, anchor) {
				insert_dev(target, h2, anchor);
				append_dev(h2, t);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*groupedStyles*/ 2 && t_value !== (t_value = /*groupKey*/ ctx[4] + "")) set_data_dev(t, t_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(h2);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_3$2.name,
			type: "slot",
			source: "(33:8) <Accordion.Trigger           >",
			ctx
		});

		return block;
	}

	// (38:8) <Accordion.Content>
	function create_default_slot_2$2(ctx) {
		let spacinginput;
		let current;

		spacinginput = new SpacingInput({
				props: {
					elementStyles: /*elementStyles*/ ctx[5],
					updateElementStyle: /*updateElementStyle*/ ctx[2]
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(spacinginput.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(spacinginput, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const spacinginput_changes = {};
				if (dirty & /*groupedStyles*/ 2) spacinginput_changes.elementStyles = /*elementStyles*/ ctx[5];
				spacinginput.$set(spacinginput_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(spacinginput.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(spacinginput.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(spacinginput, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_2$2.name,
			type: "slot",
			source: "(38:8) <Accordion.Content>",
			ctx
		});

		return block;
	}

	// (32:6) <Accordion.Item data-state="open" value={groupKey}>
	function create_default_slot_1$2(ctx) {
		let accordion_trigger;
		let t0;
		let accordion_content;
		let t1;
		let current;

		accordion_trigger = new Accordion_trigger({
				props: {
					$$slots: { default: [create_default_slot_3$2] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		accordion_content = new Accordion_content({
				props: {
					$$slots: { default: [create_default_slot_2$2] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(accordion_trigger.$$.fragment);
				t0 = space();
				create_component(accordion_content.$$.fragment);
				t1 = space();
			},
			m: function mount(target, anchor) {
				mount_component(accordion_trigger, target, anchor);
				insert_dev(target, t0, anchor);
				mount_component(accordion_content, target, anchor);
				insert_dev(target, t1, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const accordion_trigger_changes = {};

				if (dirty & /*$$scope, groupedStyles*/ 2050) {
					accordion_trigger_changes.$$scope = { dirty, ctx };
				}

				accordion_trigger.$set(accordion_trigger_changes);
				const accordion_content_changes = {};

				if (dirty & /*$$scope, groupedStyles*/ 2050) {
					accordion_content_changes.$$scope = { dirty, ctx };
				}

				accordion_content.$set(accordion_content_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(accordion_trigger.$$.fragment, local);
				transition_in(accordion_content.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(accordion_trigger.$$.fragment, local);
				transition_out(accordion_content.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t0);
					detach_dev(t1);
				}

				destroy_component(accordion_trigger, detaching);
				destroy_component(accordion_content, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_1$2.name,
			type: "slot",
			source: "(32:6) <Accordion.Item data-state=\\\"open\\\" value={groupKey}>",
			ctx
		});

		return block;
	}

	// (27:2) {#each Object.entries(groupedStyles) as [groupKey, elementStyles]}
	function create_each_block(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$1, create_if_block_1$1, create_else_block$1];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*groupKey*/ ctx[4] == ElementStyleGroup.Size) return 0;
			if (/*groupKey*/ ctx[4] == ElementStyleGroup.Spacing) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block.name,
			type: "each",
			source: "(27:2) {#each Object.entries(groupedStyles) as [groupKey, elementStyles]}",
			ctx
		});

		return block;
	}

	// (26:0) <Accordion.Root class="w-full" multiple value={Object.keys(groupedStyles)}>
	function create_default_slot$3(ctx) {
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like_dev(Object.entries(/*groupedStyles*/ ctx[1]));
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m: function mount(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert_dev(target, each_1_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty & /*Object, groupedStyles, updateElementStyle, el*/ 7) {
					each_value = ensure_array_like_dev(Object.entries(/*groupedStyles*/ ctx[1]));
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$3.name,
			type: "slot",
			source: "(26:0) <Accordion.Root class=\\\"w-full\\\" multiple value={Object.keys(groupedStyles)}>",
			ctx
		});

		return block;
	}

	function create_fragment$4(ctx) {
		let accordion_root;
		let current;

		accordion_root = new Root({
				props: {
					class: "w-full",
					multiple: true,
					value: Object.keys(/*groupedStyles*/ ctx[1]),
					$$slots: { default: [create_default_slot$3] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(accordion_root.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(accordion_root, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const accordion_root_changes = {};
				if (dirty & /*groupedStyles*/ 2) accordion_root_changes.value = Object.keys(/*groupedStyles*/ ctx[1]);

				if (dirty & /*$$scope, groupedStyles, el*/ 2051) {
					accordion_root_changes.$$scope = { dirty, ctx };
				}

				accordion_root.$set(accordion_root_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(accordion_root.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(accordion_root.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(accordion_root, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$4.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$4($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('CssEditor', slots, []);
		let { el } = $$props;
		let groupedStyles = {};

		function updateElementStyle(key, value) {
			const oldStyle = el.style[key];
			$$invalidate(0, el.style[key] = value, el);

			// Emit event
			emitStyleChangeEvent(el, key, { [key]: value }, { [key]: oldStyle });
		}

		$$self.$$.on_mount.push(function () {
			if (el === undefined && !('el' in $$props || $$self.$$.bound[$$self.$$.props['el']])) {
				console.warn("<CssEditor> was created without expected prop 'el'");
			}
		});

		const writable_props = ['el'];

		Object_1.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CssEditor> was created with unknown prop '${key}'`);
		});

		const input_handler = (elementStyle, event) => {
			updateElementStyle(elementStyle.key, event.target.value);
		};

		$$self.$$set = $$props => {
			if ('el' in $$props) $$invalidate(0, el = $$props.el);
		};

		$$self.$capture_state = () => ({
			ElementStyle,
			ElementStyleGroup,
			ElementStyleType,
			getElementComputedStylesData,
			groupElementStylesByGroup,
			emitStyleChangeEvent,
			Accordion,
			Input,
			Separator,
			SelectInput,
			ColorInput,
			NumberUnitInput,
			TagInfo,
			SizeSection,
			SpacingInput,
			el,
			groupedStyles,
			updateElementStyle
		});

		$$self.$inject_state = $$props => {
			if ('el' in $$props) $$invalidate(0, el = $$props.el);
			if ('groupedStyles' in $$props) $$invalidate(1, groupedStyles = $$props.groupedStyles);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*el*/ 1) {
				if (el) {
					const elementStyles = getElementComputedStylesData(el);
					$$invalidate(1, groupedStyles = groupElementStylesByGroup(elementStyles));
				}
			}
		};

		return [el, groupedStyles, updateElementStyle, input_handler];
	}

	class CssEditor extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$4, create_fragment$4, safe_not_equal, { el: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "CssEditor",
				options,
				id: create_fragment$4.name
			});
		}

		get el() {
			throw new Error("<CssEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set el(value) {
			throw new Error("<CssEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/editor/EditorPanel.svelte generated by Svelte v4.2.10 */
	const file$2 = "src/lib/components/editor/EditorPanel.svelte";

	// (31:10) <Tabs.Trigger class="bg-transparent p-0 text-xs" value={TabValue.CSS}             >
	function create_default_slot_6(ctx) {
		let t;

		const block = {
			c: function create() {
				t = text("Element Appearance");
			},
			m: function mount(target, anchor) {
				insert_dev(target, t, anchor);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_6.name,
			type: "slot",
			source: "(31:10) <Tabs.Trigger class=\\\"bg-transparent p-0 text-xs\\\" value={TabValue.CSS}             >",
			ctx
		});

		return block;
	}

	// (30:8) <Tabs.List class="bg-transparent p-0 gap-4">
	function create_default_slot_5(ctx) {
		let tabs_trigger;
		let current;

		tabs_trigger = new Tabs_trigger({
				props: {
					class: "bg-transparent p-0 text-xs",
					value: /*TabValue*/ ctx[2].CSS,
					$$slots: { default: [create_default_slot_6] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(tabs_trigger.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(tabs_trigger, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const tabs_trigger_changes = {};
				if (dirty & /*TabValue*/ 4) tabs_trigger_changes.value = /*TabValue*/ ctx[2].CSS;

				if (dirty & /*$$scope*/ 32) {
					tabs_trigger_changes.$$scope = { dirty, ctx };
				}

				tabs_trigger.$set(tabs_trigger_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(tabs_trigger.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(tabs_trigger.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(tabs_trigger, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_5.name,
			type: "slot",
			source: "(30:8) <Tabs.List class=\\\"bg-transparent p-0 gap-4\\\">",
			ctx
		});

		return block;
	}

	// (36:8) <Tabs.Content value={TabValue.CSS}>
	function create_default_slot_4(ctx) {
		let csseditor;
		let current;

		csseditor = new CssEditor({
				props: { el: /*el*/ ctx[0] },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(csseditor.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(csseditor, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const csseditor_changes = {};
				if (dirty & /*el*/ 1) csseditor_changes.el = /*el*/ ctx[0];
				csseditor.$set(csseditor_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(csseditor.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(csseditor.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(csseditor, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_4.name,
			type: "slot",
			source: "(36:8) <Tabs.Content value={TabValue.CSS}>",
			ctx
		});

		return block;
	}

	// (37:8) <Tabs.Content value={TabValue.OTHER}>
	function create_default_slot_3$1(ctx) {
		let t;

		const block = {
			c: function create() {
				t = text("Others");
			},
			m: function mount(target, anchor) {
				insert_dev(target, t, anchor);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_3$1.name,
			type: "slot",
			source: "(37:8) <Tabs.Content value={TabValue.OTHER}>",
			ctx
		});

		return block;
	}

	// (29:6) <Tabs.Root value={TabValue.CSS} class="w-full">
	function create_default_slot_2$1(ctx) {
		let tabs_list;
		let t0;
		let separator;
		let t1;
		let tabs_content0;
		let t2;
		let tabs_content1;
		let t3;
		let card_footer;
		let current;

		tabs_list = new Tabs_list({
				props: {
					class: "bg-transparent p-0 gap-4",
					$$slots: { default: [create_default_slot_5] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		separator = new Separator({ props: { class: "mt-1" }, $$inline: true });

		tabs_content0 = new Tabs_content({
				props: {
					value: /*TabValue*/ ctx[2].CSS,
					$$slots: { default: [create_default_slot_4] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		tabs_content1 = new Tabs_content({
				props: {
					value: /*TabValue*/ ctx[2].OTHER,
					$$slots: { default: [create_default_slot_3$1] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		card_footer = new Card_footer({
				props: { class: "flex justify-between" },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(tabs_list.$$.fragment);
				t0 = space();
				create_component(separator.$$.fragment);
				t1 = space();
				create_component(tabs_content0.$$.fragment);
				t2 = space();
				create_component(tabs_content1.$$.fragment);
				t3 = space();
				create_component(card_footer.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(tabs_list, target, anchor);
				insert_dev(target, t0, anchor);
				mount_component(separator, target, anchor);
				insert_dev(target, t1, anchor);
				mount_component(tabs_content0, target, anchor);
				insert_dev(target, t2, anchor);
				mount_component(tabs_content1, target, anchor);
				insert_dev(target, t3, anchor);
				mount_component(card_footer, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const tabs_list_changes = {};

				if (dirty & /*$$scope, TabValue*/ 36) {
					tabs_list_changes.$$scope = { dirty, ctx };
				}

				tabs_list.$set(tabs_list_changes);
				const tabs_content0_changes = {};
				if (dirty & /*TabValue*/ 4) tabs_content0_changes.value = /*TabValue*/ ctx[2].CSS;

				if (dirty & /*$$scope, el*/ 33) {
					tabs_content0_changes.$$scope = { dirty, ctx };
				}

				tabs_content0.$set(tabs_content0_changes);
				const tabs_content1_changes = {};
				if (dirty & /*TabValue*/ 4) tabs_content1_changes.value = /*TabValue*/ ctx[2].OTHER;

				if (dirty & /*$$scope*/ 32) {
					tabs_content1_changes.$$scope = { dirty, ctx };
				}

				tabs_content1.$set(tabs_content1_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(tabs_list.$$.fragment, local);
				transition_in(separator.$$.fragment, local);
				transition_in(tabs_content0.$$.fragment, local);
				transition_in(tabs_content1.$$.fragment, local);
				transition_in(card_footer.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(tabs_list.$$.fragment, local);
				transition_out(separator.$$.fragment, local);
				transition_out(tabs_content0.$$.fragment, local);
				transition_out(tabs_content1.$$.fragment, local);
				transition_out(card_footer.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t0);
					detach_dev(t1);
					detach_dev(t2);
					detach_dev(t3);
				}

				destroy_component(tabs_list, detaching);
				destroy_component(separator, detaching);
				destroy_component(tabs_content0, detaching);
				destroy_component(tabs_content1, detaching);
				destroy_component(card_footer, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_2$1.name,
			type: "slot",
			source: "(29:6) <Tabs.Root value={TabValue.CSS} class=\\\"w-full\\\">",
			ctx
		});

		return block;
	}

	// (28:4) <Card.Content>
	function create_default_slot_1$1(ctx) {
		let tabs_root;
		let current;

		tabs_root = new Root$1({
				props: {
					value: /*TabValue*/ ctx[2].CSS,
					class: "w-full",
					$$slots: { default: [create_default_slot_2$1] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(tabs_root.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(tabs_root, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const tabs_root_changes = {};
				if (dirty & /*TabValue*/ 4) tabs_root_changes.value = /*TabValue*/ ctx[2].CSS;

				if (dirty & /*$$scope, TabValue, el*/ 37) {
					tabs_root_changes.$$scope = { dirty, ctx };
				}

				tabs_root.$set(tabs_root_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(tabs_root.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(tabs_root.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(tabs_root, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_1$1.name,
			type: "slot",
			source: "(28:4) <Card.Content>",
			ctx
		});

		return block;
	}

	// (27:2) <Card.Root class="w-[232px] h-[80vh] opacity-[98%] overflow-auto pt-2">
	function create_default_slot$2(ctx) {
		let card_content;
		let current;

		card_content = new Card_content({
				props: {
					$$slots: { default: [create_default_slot_1$1] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(card_content.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(card_content, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const card_content_changes = {};

				if (dirty & /*$$scope, TabValue, el*/ 37) {
					card_content_changes.$$scope = { dirty, ctx };
				}

				card_content.$set(card_content_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(card_content.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(card_content.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(card_content, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$2.name,
			type: "slot",
			source: "(27:2) <Card.Root class=\\\"w-[232px] h-[80vh] opacity-[98%] overflow-auto pt-2\\\">",
			ctx
		});

		return block;
	}

	function create_fragment$3(ctx) {
		let div;
		let card_root;
		let div_class_value;
		let current;
		let mounted;
		let dispose;

		card_root = new Card$1({
				props: {
					class: "w-[232px] h-[80vh] opacity-[98%] overflow-auto pt-2",
					$$slots: { default: [create_default_slot$2] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				div = element("div");
				create_component(card_root.$$.fragment);
				attr_dev(div, "class", div_class_value = "fixed top-10 right-2 transform -translate-y-1/2 -translate-x-1/2 " + (/*visible*/ ctx[1] ? 'visible' : 'invisible'));
				add_location(div, file$2, 24, 0, 552);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				mount_component(card_root, div, null);
				current = true;

				if (!mounted) {
					dispose = action_destroyer(d$1.call(null, div, { bounds: "body" }));
					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				const card_root_changes = {};

				if (dirty & /*$$scope, TabValue, el*/ 37) {
					card_root_changes.$$scope = { dirty, ctx };
				}

				card_root.$set(card_root_changes);

				if (!current || dirty & /*visible*/ 2 && div_class_value !== (div_class_value = "fixed top-10 right-2 transform -translate-y-1/2 -translate-x-1/2 " + (/*visible*/ ctx[1] ? 'visible' : 'invisible'))) {
					attr_dev(div, "class", div_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(card_root.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(card_root.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(card_root);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$3.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$3($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('EditorPanel', slots, []);
		let el;
		let visible = false;
		var TabValue;

		(function (TabValue) {
			TabValue["CSS"] = "css";
			TabValue["OTHER"] = "other";
		})(TabValue || (TabValue = {}));

		function setVisible(value) {
			$$invalidate(1, visible = value);
		}

		function setElement(element) {
			$$invalidate(0, el = element);
		}

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditorPanel> was created with unknown prop '${key}'`);
		});

		$$self.$capture_state = () => ({
			draggable: d$1,
			Card,
			Tabs,
			CssEditor,
			Separator,
			el,
			visible,
			TabValue,
			setVisible,
			setElement
		});

		$$self.$inject_state = $$props => {
			if ('el' in $$props) $$invalidate(0, el = $$props.el);
			if ('visible' in $$props) $$invalidate(1, visible = $$props.visible);
			if ('TabValue' in $$props) $$invalidate(2, TabValue = $$props.TabValue);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [el, visible, TabValue, setVisible, setElement];
	}

	class EditorPanel extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$3, create_fragment$3, safe_not_equal, { setVisible: 3, setElement: 4 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "EditorPanel",
				options,
				id: create_fragment$3.name
			});
		}

		get setVisible() {
			return this.$$.ctx[3];
		}

		set setVisible(value) {
			throw new Error("<EditorPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get setElement() {
			return this.$$.ctx[4];
		}

		set setElement(value) {
			throw new Error("<EditorPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	const buttonVariants = ie({
	    base: "inline-flex items-center justify-center rounded-md text-sm font-medium whitespace-nowrap transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
	    variants: {
	        variant: {
	            default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
	            destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
	            outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
	            secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
	            ghost: "hover:bg-accent hover:text-accent-foreground",
	            link: "text-primary underline-offset-4 hover:underline",
	        },
	        size: {
	            default: "h-9 px-4 py-2",
	            sm: "h-8 rounded-md px-3 text-xs",
	            lg: "h-10 rounded-md px-8",
	            icon: "h-9 w-9",
	        },
	    },
	    defaultVariants: {
	        variant: "default",
	        size: "default",
	    },
	});

	/* src/lib/components/ui/button/button.svelte generated by Svelte v4.2.10 */

	// (11:0) <ButtonPrimitive.Root  {builders}  class={cn(buttonVariants({ variant, size, className }))}  type="button"  {...$$restProps}  on:click  on:keydown >
	function create_default_slot$1(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[5].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[8],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$1.name,
			type: "slot",
			source: "(11:0) <ButtonPrimitive.Root  {builders}  class={cn(buttonVariants({ variant, size, className }))}  type=\\\"button\\\"  {...$$restProps}  on:click  on:keydown >",
			ctx
		});

		return block;
	}

	function create_fragment$2(ctx) {
		let buttonprimitive_root;
		let current;

		const buttonprimitive_root_spread_levels = [
			{ builders: /*builders*/ ctx[3] },
			{
				class: cn(buttonVariants({
					variant: /*variant*/ ctx[1],
					size: /*size*/ ctx[2],
					className: /*className*/ ctx[0]
				}))
			},
			{ type: "button" },
			/*$$restProps*/ ctx[4]
		];

		let buttonprimitive_root_props = {
			$$slots: { default: [create_default_slot$1] },
			$$scope: { ctx }
		};

		for (let i = 0; i < buttonprimitive_root_spread_levels.length; i += 1) {
			buttonprimitive_root_props = assign(buttonprimitive_root_props, buttonprimitive_root_spread_levels[i]);
		}

		buttonprimitive_root = new Button$1({
				props: buttonprimitive_root_props,
				$$inline: true
			});

		buttonprimitive_root.$on("click", /*click_handler*/ ctx[6]);
		buttonprimitive_root.$on("keydown", /*keydown_handler*/ ctx[7]);

		const block = {
			c: function create() {
				create_component(buttonprimitive_root.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(buttonprimitive_root, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const buttonprimitive_root_changes = (dirty & /*builders, variant, size, className, $$restProps*/ 31)
				? get_spread_update(buttonprimitive_root_spread_levels, [
						dirty & /*builders*/ 8 && { builders: /*builders*/ ctx[3] },
						dirty & /*variant, size, className*/ 7 && {
							class: cn(buttonVariants({
								variant: /*variant*/ ctx[1],
								size: /*size*/ ctx[2],
								className: /*className*/ ctx[0]
							}))
						},
						buttonprimitive_root_spread_levels[2],
						dirty & /*$$restProps*/ 16 && get_spread_object(/*$$restProps*/ ctx[4])
					])
				: {};

				if (dirty & /*$$scope*/ 256) {
					buttonprimitive_root_changes.$$scope = { dirty, ctx };
				}

				buttonprimitive_root.$set(buttonprimitive_root_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(buttonprimitive_root.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(buttonprimitive_root.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(buttonprimitive_root, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$2.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$2($$self, $$props, $$invalidate) {
		const omit_props_names = ["class","variant","size","builders"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Button', slots, ['default']);
		let { class: className = undefined } = $$props;
		let { variant = "default" } = $$props;
		let { size = "default" } = $$props;
		let { builders = [] } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keydown_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
			if ('variant' in $$new_props) $$invalidate(1, variant = $$new_props.variant);
			if ('size' in $$new_props) $$invalidate(2, size = $$new_props.size);
			if ('builders' in $$new_props) $$invalidate(3, builders = $$new_props.builders);
			if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			ButtonPrimitive,
			cn,
			buttonVariants,
			className,
			variant,
			size,
			builders
		});

		$$self.$inject_state = $$new_props => {
			if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
			if ('variant' in $$props) $$invalidate(1, variant = $$new_props.variant);
			if ('size' in $$props) $$invalidate(2, size = $$new_props.size);
			if ('builders' in $$props) $$invalidate(3, builders = $$new_props.builders);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			className,
			variant,
			size,
			builders,
			$$restProps,
			slots,
			click_handler,
			keydown_handler,
			$$scope
		];
	}

	class Button extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$2, create_fragment$2, safe_not_equal, {
				class: 0,
				variant: 1,
				size: 2,
				builders: 3
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Button",
				options,
				id: create_fragment$2.name
			});
		}

		get class() {
			throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set class(value) {
			throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get variant() {
			throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set variant(value) {
			throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get size() {
			throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set size(value) {
			throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get builders() {
			throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set builders(value) {
			throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/toolbar/Toolbar.svelte generated by Svelte v4.2.10 */
	const file$1 = "src/lib/components/toolbar/Toolbar.svelte";

	// (65:8) {:else}
	function create_else_block(ctx) {
		let pencil1;
		let t;
		let current;

		pencil1 = new Pencil1$1({
				props: { class: "h-4 w-4 mr-2" },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(pencil1.$$.fragment);
				t = text("\n          Start Editing");
			},
			m: function mount(target, anchor) {
				mount_component(pencil1, target, anchor);
				insert_dev(target, t, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(pencil1.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(pencil1.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
				}

				destroy_component(pencil1, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block.name,
			type: "else",
			source: "(65:8) {:else}",
			ctx
		});

		return block;
	}

	// (35:8) {#if selected === ToolName.EDIT}
	function create_if_block_1(ctx) {
		let svg;
		let g;
		let path;
		let defs;
		let clipPath;
		let rect;
		let t;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				g = svg_element("g");
				path = svg_element("path");
				defs = svg_element("defs");
				clipPath = svg_element("clipPath");
				rect = svg_element("rect");
				t = text("\n\n          Stop Editing");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M7 13H13V7H7V13ZM10 2.5C5.86 2.5 2.5 5.86 2.5 10C2.5 14.14 5.86 17.5 10 17.5C14.14 17.5 17.5 14.14 17.5 10C17.5 5.86 14.14 2.5 10 2.5Z");
				attr_dev(path, "fill", "white");
				add_location(path, file$1, 48, 14, 1607);
				attr_dev(g, "clip-path", "url(#clip0_148_23526)");
				add_location(g, file$1, 47, 12, 1555);
				attr_dev(rect, "width", "18");
				attr_dev(rect, "height", "18");
				attr_dev(rect, "fill", "white");
				attr_dev(rect, "transform", "translate(1 1)");
				add_location(rect, file$1, 57, 16, 1984);
				attr_dev(clipPath, "id", "clip0_148_23526");
				add_location(clipPath, file$1, 56, 14, 1936);
				add_location(defs, file$1, 55, 12, 1915);
				attr_dev(svg, "class", "mr-2");
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 20 20");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1, 39, 10, 1351);
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, g);
				append_dev(g, path);
				append_dev(svg, defs);
				append_dev(defs, clipPath);
				append_dev(clipPath, rect);
				insert_dev(target, t, anchor);
			},
			i: noop$3,
			o: noop$3,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
					detach_dev(t);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1.name,
			type: "if",
			source: "(35:8) {#if selected === ToolName.EDIT}",
			ctx
		});

		return block;
	}

	// (27:6) <Button         class={selected === ToolName.EDIT           ? "rounded-full bg-red hover:bg-red border-none"           : "rounded-full border-none"}         variant={selected === ToolName.EDIT ? "destructive" : "outline"}         on:click={() =>           (selected = selected === ToolName.EDIT ? undefined : ToolName.EDIT)}       >
	function create_default_slot_3(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_1, create_else_block];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*selected*/ ctx[0] === ToolName.EDIT) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index !== previous_block_index) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_3.name,
			type: "slot",
			source: "(27:6) <Button         class={selected === ToolName.EDIT           ? \\\"rounded-full bg-red hover:bg-red border-none\\\"           : \\\"rounded-full border-none\\\"}         variant={selected === ToolName.EDIT ? \\\"destructive\\\" : \\\"outline\\\"}         on:click={() =>           (selected = selected === ToolName.EDIT ? undefined : ToolName.EDIT)}       >",
			ctx
		});

		return block;
	}

	// (71:6) {#if selected !== ToolName.EDIT}
	function create_if_block(ctx) {
		let div;
		let button;
		let div_transition;
		let current;

		button = new Button({
				props: {
					class: "rounded-full border-none",
					variant: "outline",
					$$slots: { default: [create_default_slot_2] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		button.$on("click", emitOpenProjectMessage);

		const block = {
			c: function create() {
				div = element("div");
				create_component(button.$$.fragment);
				add_location(div, file$1, 75, 8, 2392);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				mount_component(button, div, null);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(button.$$.fragment, local);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { axis: "x" }, true);
						div_transition.run(1);
					});
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(button.$$.fragment, local);

				if (local) {
					if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { axis: "x" }, false);
					div_transition.run(0);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(button);
				if (detaching && div_transition) div_transition.end();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block.name,
			type: "if",
			source: "(71:6) {#if selected !== ToolName.EDIT}",
			ctx
		});

		return block;
	}

	// (73:10) <Button             class="rounded-full border-none"             variant="outline"             on:click={emitOpenProjectMessage}             >
	function create_default_slot_2(ctx) {
		let externallink;
		let t;
		let current;

		externallink = new ExternalLink$1({
				props: { class: "h-4 w-4 mr-2" },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(externallink.$$.fragment);
				t = text("\n            Open Project");
			},
			m: function mount(target, anchor) {
				mount_component(externallink, target, anchor);
				insert_dev(target, t, anchor);
				current = true;
			},
			p: noop$3,
			i: function intro(local) {
				if (current) return;
				transition_in(externallink.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(externallink.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
				}

				destroy_component(externallink, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_2.name,
			type: "slot",
			source: "(73:10) <Button             class=\\\"rounded-full border-none\\\"             variant=\\\"outline\\\"             on:click={emitOpenProjectMessage}             >",
			ctx
		});

		return block;
	}

	// (21:4) <Card.Root       class="opacity-[98%] border p-1 space-x-2 rounded-full flex flex-row {selected ===       ToolName.EDIT         ? 'bg-red border-red'         : ''}"     >
	function create_default_slot_1(ctx) {
		let button;
		let t;
		let if_block_anchor;
		let current;

		button = new Button({
				props: {
					class: /*selected*/ ctx[0] === ToolName.EDIT
					? "rounded-full bg-red hover:bg-red border-none"
					: "rounded-full border-none",
					variant: /*selected*/ ctx[0] === ToolName.EDIT
					? "destructive"
					: "outline",
					$$slots: { default: [create_default_slot_3] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		button.$on("click", /*click_handler*/ ctx[3]);
		let if_block = /*selected*/ ctx[0] !== ToolName.EDIT && create_if_block(ctx);

		const block = {
			c: function create() {
				create_component(button.$$.fragment);
				t = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				mount_component(button, target, anchor);
				insert_dev(target, t, anchor);
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const button_changes = {};

				if (dirty & /*selected*/ 1) button_changes.class = /*selected*/ ctx[0] === ToolName.EDIT
				? "rounded-full bg-red hover:bg-red border-none"
				: "rounded-full border-none";

				if (dirty & /*selected*/ 1) button_changes.variant = /*selected*/ ctx[0] === ToolName.EDIT
				? "destructive"
				: "outline";

				if (dirty & /*$$scope, selected*/ 33) {
					button_changes.$$scope = { dirty, ctx };
				}

				button.$set(button_changes);

				if (/*selected*/ ctx[0] !== ToolName.EDIT) {
					if (if_block) {
						if (dirty & /*selected*/ 1) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(button.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(button.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
					detach_dev(if_block_anchor);
				}

				destroy_component(button, detaching);
				if (if_block) if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_1.name,
			type: "slot",
			source: "(21:4) <Card.Root       class=\\\"opacity-[98%] border p-1 space-x-2 rounded-full flex flex-row {selected ===       ToolName.EDIT         ? 'bg-red border-red'         : ''}\\\"     >",
			ctx
		});

		return block;
	}

	// (20:2) <ToolBarAnimation>
	function create_default_slot(ctx) {
		let card_root;
		let current;

		card_root = new Card$1({
				props: {
					class: "opacity-[98%] border p-1 space-x-2 rounded-full flex flex-row " + (/*selected*/ ctx[0] === ToolName.EDIT
					? 'bg-red border-red'
					: ''),
					$$slots: { default: [create_default_slot_1] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(card_root.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(card_root, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const card_root_changes = {};

				if (dirty & /*selected*/ 1) card_root_changes.class = "opacity-[98%] border p-1 space-x-2 rounded-full flex flex-row " + (/*selected*/ ctx[0] === ToolName.EDIT
				? 'bg-red border-red'
				: '');

				if (dirty & /*$$scope, selected*/ 33) {
					card_root_changes.$$scope = { dirty, ctx };
				}

				card_root.$set(card_root_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(card_root.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(card_root.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(card_root, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot.name,
			type: "slot",
			source: "(20:2) <ToolBarAnimation>",
			ctx
		});

		return block;
	}

	function create_fragment$1(ctx) {
		let div;
		let toolbaranimation;
		let t;
		let editorpanel;
		let current;

		toolbaranimation = new ToolbarAnimation({
				props: {
					$$slots: { default: [create_default_slot] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		let editorpanel_props = {};
		editorpanel = new EditorPanel({ props: editorpanel_props, $$inline: true });
		/*editorpanel_binding*/ ctx[4](editorpanel);

		const block = {
			c: function create() {
				div = element("div");
				create_component(toolbaranimation.$$.fragment);
				t = space();
				create_component(editorpanel.$$.fragment);
				attr_dev(div, "class", "fixed bottom-3 left-0 right-0 flex justify-center");
				add_location(div, file$1, 22, 0, 701);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				mount_component(toolbaranimation, div, null);
				insert_dev(target, t, anchor);
				mount_component(editorpanel, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const toolbaranimation_changes = {};

				if (dirty & /*$$scope, selected*/ 33) {
					toolbaranimation_changes.$$scope = { dirty, ctx };
				}

				toolbaranimation.$set(toolbaranimation_changes);
				const editorpanel_changes = {};
				editorpanel.$set(editorpanel_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(toolbaranimation.$$.fragment, local);
				transition_in(editorpanel.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(toolbaranimation.$$.fragment, local);
				transition_out(editorpanel.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
					detach_dev(t);
				}

				destroy_component(toolbaranimation);
				/*editorpanel_binding*/ ctx[4](null);
				destroy_component(editorpanel, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Toolbar', slots, []);
		let editorPanel;
		let editor;
		let selected = ToolName.EDIT;

		onMount(() => {
			$$invalidate(2, editor = new Editor(selected, editorPanel));
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Toolbar> was created with unknown prop '${key}'`);
		});

		const click_handler = () => $$invalidate(0, selected = selected === ToolName.EDIT ? undefined : ToolName.EDIT);

		function editorpanel_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				editorPanel = $$value;
				$$invalidate(1, editorPanel);
			});
		}

		$$self.$capture_state = () => ({
			Card,
			ExternalLink: ExternalLink$1,
			Pencil1: Pencil1$1,
			Stop: Stop$1,
			ToolBarAnimation: ToolbarAnimation,
			onMount,
			Editor,
			ToolName,
			EditorPanel,
			Button,
			slide,
			emitOpenProjectMessage,
			editorPanel,
			editor,
			selected
		});

		$$self.$inject_state = $$props => {
			if ('editorPanel' in $$props) $$invalidate(1, editorPanel = $$props.editorPanel);
			if ('editor' in $$props) $$invalidate(2, editor = $$props.editor);
			if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*editor, selected*/ 5) {
				editor === null || editor === void 0
				? void 0
				: editor.selectTool(selected);
			}
		};

		return [selected, editorPanel, editor, click_handler, editorpanel_binding];
	}

	class Toolbar extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Toolbar",
				options,
				id: create_fragment$1.name
			});
		}
	}

	const ONLOOK_TOOLBAR = "onlook-toolbar";

	/* src/App.svelte generated by Svelte v4.2.10 */
	const file = "src/App.svelte";

	function create_fragment(ctx) {
		let div;
		let toolbar;
		let current;
		toolbar = new Toolbar({ $$inline: true });

		const block = {
			c: function create() {
				div = element("div");
				create_component(toolbar.$$.fragment);
				attr_dev(div, "id", ONLOOK_TOOLBAR);
				add_location(div, file, 6, 0, 163);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				mount_component(toolbar, div, null);
				current = true;
			},
			p: noop$3,
			i: function intro(local) {
				if (current) return;
				transition_in(toolbar.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(toolbar.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(toolbar);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('App', slots, []);
		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
		});

		$$self.$capture_state = () => ({ Toolbar, ONLOOK_TOOLBAR });
		return [];
	}

	class App extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance, create_fragment, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "App",
				options,
				id: create_fragment.name
			});
		}
	}

	let active;
	function toClassName(rule) {
	    return [
	        ...rule.v,
	        (rule.i ? '!' : '') + rule.n
	    ].join(':');
	}
	function format(rules, seperator = ',') {
	    return rules.map(toClassName).join(seperator);
	}
	/**
	 * @internal
	 */ let escape = 'undefined' != typeof CSS && CSS.escape || // Simplified: escaping only special characters
	// Needed for NodeJS and Edge <79 (https://caniuse.com/mdn-api_css_escape)
	((className)=>className.// Simplifed escape testing only for chars that we know happen to be in tailwind directives
	    replace(/[!"'`*+.,;:\\/<=>?@#$%&^|~()[\]{}]/g, '\\$&').// If the character is the first character and is in the range [0-9] (2xl, ...)
	    // https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
	    replace(/^\d/, '\\3$& '));
	// Based on https://stackoverflow.com/a/52171480
	/**
	 * @group Configuration
	 * @param value
	 * @returns
	 */ function hash(value) {
	    // eslint-disable-next-line no-var
	    for(var h = 9, index = value.length; index--;)h = Math.imul(h ^ value.charCodeAt(index), 0x5f356495);
	    return '#' + ((h ^ h >>> 9) >>> 0).toString(36);
	}
	/**
	 * @internal
	 * @param screen
	 * @param prefix
	 * @returns
	 */ function mql(screen, prefix = '@media ') {
	    return prefix + asArray(screen).map((screen)=>{
	        return 'string' == typeof screen && (screen = {
	            min: screen
	        }), screen.raw || Object.keys(screen).map((feature)=>`(${feature}-width:${screen[feature]})`).join(' and ');
	    }).join(',');
	}
	/**
	 * @internal
	 * @param value
	 * @returns
	 */ function asArray(value = []) {
	    return Array.isArray(value) ? value : null == value ? [] : [
	        value
	    ];
	}
	/**
	 * @internal
	 * @param value
	 * @returns
	 */ function identity(value) {
	    return value;
	}
	/**
	 * @internal
	 */ function noop() {}
	// no-op
	// Based on https://github.com/kripod/otion
	// License MIT
	// export const enum Shifts {
	//   darkMode = 30,
	//   layer = 27,
	//   screens = 26,
	//   responsive = 22,
	//   atRules = 18,
	//   variants = 0,
	// }
	let Layer = {
	    /**
	   * 1. `default` (public)
	   */ d: /* efaults */ 0,
	    /* Shifts.layer */ /**
	   * 2. `base` (public) — for things like reset rules or default styles applied to plain HTML elements.
	   */ b: /* ase */ 134217728,
	    /* Shifts.layer */ /**
	   * 3. `components` (public, used by `style()`) — is for class-based styles that you want to be able to override with utilities.
	   */ c: /* omponents */ 268435456,
	    /* Shifts.layer */ // reserved for style():
	    // - props: 0b011
	    // - when: 0b100
	    /**
	   * 6. `aliases` (public, used by `apply()`) — `~(...)`
	   */ a: /* liases */ 671088640,
	    /* Shifts.layer */ /**
	   * 6. `utilities` (public) — for small, single-purpose classes
	   */ u: /* tilities */ 805306368,
	    /* Shifts.layer */ /**
	   * 7. `overrides` (public, used by `css()`)
	   */ o: /* verrides */ 939524096
	};
	/*
	To set a bit: n |= mask;
	To clear a bit: n &= ~mask;
	To test if a bit is set: (n & mask)

	Bit shifts for the primary bits:

	| bits | trait                                                   | shift |
	| ---- | ------------------------------------------------------- | ----- |
	| 1    | dark mode                                               | 30    |
	| 3    | layer: preflight, global, components, utilities, css    | 27    |
	| 1    | screens: is this a responsive variation of a rule       | 26    |
	| 4    | responsive based on min-width, max-width or width       | 22    |
	| 4    | at-rules                                                | 18    |
	| 18   | pseudo and group variants                               | 0     |

	Layer: 0 - 7: 3 bits
	  - defaults: 0 << 27
	  - base: 1 << 27
	  - components: 2 << 27
	  - variants: 3 << 27
	  - joints: 4 << 27
	  - aliases: 5 << 27
	  - utilities: 6 << 27
	  - overrides: 7 << 27

	These are calculated by serialize and added afterwards:

	| bits | trait                               |
	| ---- | ----------------------------------- |
	| 4    | number of selectors (descending)    |
	| 4    | number of declarations (descending) |
	| 4    | greatest precedence of properties   |

	These are added by shifting the primary bits using multiplication as js only
	supports bit shift up to 32 bits.
	*/ // Colon and dash count of string (ascending)
	function seperatorPrecedence(string) {
	    return string.match(/[-=:;]/g)?.length || 0;
	}
	function atRulePrecedence(css) {
	    // 0 - 15: 4 bits (max 144rem or 2304px)
	    // rem -> bit
	    // <20 ->  0 (<320px)
	    //  20 ->  1 (320px)
	    //  24 ->  2 (384px)
	    //  28 ->  3 (448px)
	    //  32 ->  4 (512px)
	    //  36 ->  5 (576px)
	    //  42 ->  6 (672px)
	    //  48 ->  7 (768px)
	    //  56 ->  8 (896px)
	    //  64 ->  9 (1024px)
	    //  72 -> 10 (1152px)
	    //  80 -> 11 (1280px)
	    //  96 -> 12 (1536px)
	    // 112 -> 13 (1792px)
	    // 128 -> 14 (2048px)
	    // 144 -> 15 (2304px)
	    // https://www.dcode.fr/function-equation-finder
	    return Math.min(/(?:^|width[^\d]+)(\d+(?:.\d+)?)(p)?/.test(css) ? Math.max(0, 29.63 * (+RegExp.$1 / (RegExp.$2 ? 15 : 1)) ** 0.137 - 43) : 0, 15) << 22 | /* Shifts.responsive */ Math.min(seperatorPrecedence(css), 15) << 18;
	}
	/* Shifts.atRules */ // Pesudo variant presedence
	// Chars 3 - 8: Uniquely identifies a pseudo selector
	// represented as a bit set for each relevant value
	// 18 bits: one for each variant plus one for unknown variants
	//
	// ':group-*' variants are normalized to their native pseudo class (':group-hover' -> ':hover')
	// as they already have a higher selector presedence due to the add '.group' ('.group:hover .group-hover:...')
	// Sources:
	// - https://bitsofco.de/when-do-the-hover-focus-and-active-pseudo-classes-apply/#orderofstyleshoverthenfocusthenactive
	// - https://developer.mozilla.org/docs/Web/CSS/:active#Active_links
	// - https://github.com/tailwindlabs/tailwindcss/blob/master/stubs/defaultConfig.stub.js#L931
	let PRECEDENCES_BY_PSEUDO_CLASS = [
	    /* fi */ 'rst-c',
	    /* hild: 0 */ /* la */ 'st-ch',
	    /* ild: 1 */ // even and odd use: nth-child
	    /* nt */ 'h-chi',
	    /* ld: 2 */ /* an */ 'y-lin',
	    /* k: 3 */ /* li */ 'nk',
	    /* : 4 */ /* vi */ 'sited',
	    /* : 5 */ /* ch */ 'ecked',
	    /* : 6 */ /* em */ 'pty',
	    /* : 7 */ /* re */ 'ad-on',
	    /* ly: 8 */ /* fo */ 'cus-w',
	    /* ithin : 9 */ /* ho */ 'ver',
	    /* : 10 */ /* fo */ 'cus',
	    /* : 11 */ /* fo */ 'cus-v',
	    /* isible : 12 */ /* ac */ 'tive',
	    /* : 13 */ /* di */ 'sable',
	    /* d : 14 */ /* op */ 'tiona',
	    /* l: 15 */ /* re */ 'quire'
	];
	/** The name to use for `&` expansion in selectors. Maybe empty for at-rules like `@import`, `@font-face`, `@media`, ... */ /** The calculated precedence taking all variants into account. */ /** The rulesets (selectors and at-rules). expanded variants `@media ...`, `@supports ...`, `&:focus`, `.dark &` */ /** Is this rule `!important` eg something like `!underline` or `!bg-red-500` or `!red-500` */ function convert({ n: name , i: important , v: variants = []  }, context, precedence, conditions) {
	    name && (name = toClassName({
	        n: name,
	        i: important,
	        v: variants
	    }));
	    conditions = [
	        ...asArray(conditions)
	    ];
	    for (let variant of variants){
	        let screen = context.theme('screens', variant);
	        for (let condition of asArray(screen && mql(screen) || context.v(variant))){
	            var /* d: 16 */ selector;
	            conditions.push(condition);
	            precedence |= screen ? 67108864 | /* Shifts.screens */ atRulePrecedence(condition) : 'dark' == variant ? 1073741824 : /* Shifts.darkMode */ '@' == condition[0] ? atRulePrecedence(condition) : (selector = condition, // use first found pseudo-class
	            1 << ~(/:([a-z-]+)/.test(selector) && ~PRECEDENCES_BY_PSEUDO_CLASS.indexOf(RegExp.$1.slice(2, 7)) || -18));
	        }
	    }
	    return {
	        n: name,
	        p: precedence,
	        r: conditions,
	        i: important
	    };
	}
	let registry = new Map();
	function stringify$1(rule) {
	    if (rule.d) {
	        let groups = [], selector = replaceEach(// merge all conditions into a selector string
	        rule.r.reduce((selector, condition)=>{
	            return '@' == condition[0] ? (groups.push(condition), selector) : // Go over the selector and replace the matching multiple selectors if any
	            condition ? replaceEach(selector, (selectorPart)=>replaceEach(condition, // If the current condition has a nested selector replace it
	                (conditionPart)=>{
	                    let mergeMatch = /(:merge\(.+?\))(:[a-z-]+|\\[.+])/.exec(conditionPart);
	                    if (mergeMatch) {
	                        let selectorIndex = selectorPart.indexOf(mergeMatch[1]);
	                        return ~selectorIndex ? // [':merge(.group):hover .rule', ':merge(.group):focus &'] -> ':merge(.group):focus:hover .rule'
	                        // ':merge(.group)' + ':focus' + ':hover .rule'
	                        selectorPart.slice(0, selectorIndex) + mergeMatch[0] + selectorPart.slice(selectorIndex + mergeMatch[1].length) : // [':merge(.peer):focus~&', ':merge(.group):hover &'] -> ':merge(.peer):focus~:merge(.group):hover &'
	                        replaceReference(selectorPart, conditionPart);
	                    }
	                    // Return the current selector with the key matching multiple selectors if any
	                    return replaceReference(conditionPart, selectorPart);
	                })) : selector;
	        }, '&'), // replace '&' with rule name or an empty string
	        (selectorPart)=>replaceReference(selectorPart, rule.n ? '.' + escape(rule.n) : ''));
	        return selector && groups.push(selector.replace(/:merge\((.+?)\)/g, '$1')), groups.reduceRight((body, grouping)=>grouping + '{' + body + '}', rule.d);
	    }
	}
	function replaceEach(selector, iteratee) {
	    return selector.replace(/ *((?:\(.+?\)|\[.+?\]|[^,])+) *(,|$)/g, (_, selectorPart, comma)=>iteratee(selectorPart) + comma);
	}
	function replaceReference(selector, reference) {
	    return selector.replace(/&/g, reference);
	}
	let collator = new Intl.Collator('en', {
	    numeric: true
	});
	/** The calculated precedence taking all variants into account. */ /* The precedence of the properties within {@link d}. */ /** The name to use for `&` expansion in selectors. Maybe empty for at-rules like `@import`, `@font-face`, `@media`, ... */ /**
	 * Find the array index of where to add an element to keep it sorted.
	 *
	 * @returns The insertion index
	 */ function sortedInsertionIndex(array, element) {
	    // Find position using binary search
	    // eslint-disable-next-line no-var
	    for(var low = 0, high = array.length; low < high;){
	        let pivot = high + low >> 1;
	        0 >= compareTwindRules(array[pivot], element) ? low = pivot + 1 : high = pivot;
	    }
	    return high;
	}
	function compareTwindRules(a, b) {
	    // base and overrides (css) layers are kept in order they are declared
	    let layer = a.p & Layer.o;
	    return layer == (b.p & Layer.o) && (layer == Layer.b || layer == Layer.o) ? 0 : a.p - b.p || a.o - b.o || collator.compare(byModifier(a.n), byModifier(b.n)) || collator.compare(byName(a.n), byName(b.n));
	}
	function byModifier(s) {
	    return (s || '').split(/:/).pop().split('/').pop() || '\x00';
	}
	function byName(s) {
	    return (s || '').replace(/\W/g, (c)=>String.fromCharCode(127 + c.charCodeAt(0))) + '\x00';
	}
	function parseColorComponent(chars, factor) {
	    return Math.round(parseInt(chars, 16) * factor);
	}
	/**
	 * @internal
	 * @param color
	 * @param options
	 * @returns
	 */ function toColorValue(color, options = {}) {
	    if ('function' == typeof color) return color(options);
	    let { opacityValue ='1' , opacityVariable  } = options, opacity = opacityVariable ? `var(${opacityVariable})` : opacityValue;
	    if (color.includes('<alpha-value>')) return color.replace('<alpha-value>', opacity);
	    // rgb hex: #0123 and #001122
	    if ('#' == color[0] && (4 == color.length || 7 == color.length)) {
	        let size = (color.length - 1) / 3, factor = [
	            17,
	            1,
	            0.062272
	        ][size - 1];
	        return `rgba(${[
            parseColorComponent(color.substr(1, size), factor),
            parseColorComponent(color.substr(1 + size, size), factor),
            parseColorComponent(color.substr(1 + 2 * size, size), factor),
            opacity
        ]})`;
	    }
	    return '1' == opacity ? color : '0' == opacity ? '#0000' : // convert rgb and hsl to alpha variant
	    color.replace(/^(rgb|hsl)(\([^)]+)\)$/, `$1a$2,${opacity})`);
	}
	function serialize(style, rule, context, precedence, conditions = []) {
	    return function serialize$(style, { n: name , p: precedence , r: conditions = [] , i: important  }, context) {
	        let rules = [], // The generated declaration block eg body of the css rule
	        declarations = '', // This ensures that 'border-top-width' has a higher precedence than 'border-top'
	        maxPropertyPrecedence = 0, // More specific utilities have less declarations and a higher precedence
	        numberOfDeclarations = 0;
	        for(let key in style || {}){
	            var layer, // https://github.com/kripod/otion/blob/main/packages/otion/src/propertyMatchers.ts
	            // "+1": [
	            // 	/* ^border-.*(w|c|sty) */
	            // 	"border-.*(width,color,style)",
	            // 	/* ^[tlbr].{2,4}m?$ */
	            // 	"top",
	            // 	"left",
	            // 	"bottom",
	            // 	"right",
	            // 	/* ^c.{7}$ */
	            // 	"continue",
	            // 	/* ^c.{8}$ */
	            // 	"container",
	            // ],
	            // "-1": [
	            // 	/* ^[fl].{5}l */
	            // 	"flex-flow",
	            // 	"line-clamp",
	            // 	/* ^g.{8}$ */
	            // 	"grid-area",
	            // 	/* ^pl */
	            // 	"place-content",
	            // 	"place-items",
	            // 	"place-self",
	            // ],
	            // group: 1 => +1
	            // group: 2 => -1
	            // 0 - 15 => 4 bits
	            // Ignore vendor prefixed and custom properties
	            property;
	            let value = style[key];
	            if ('@' == key[0]) {
	                // at rules: https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
	                if (!value) continue;
	                // @apply ...;
	                if ('a' == key[1]) {
	                    rules.push(...translateWith(name, precedence, parse('' + value), context, precedence, conditions, important, true));
	                    continue;
	                }
	                // @layer <layer>
	                if ('l' == key[1]) {
	                    for (let css of asArray(value))rules.push(...serialize$(css, {
	                        n: name,
	                        p: (layer = Layer[key[7]], // Set layer (first reset, than set)
	                        precedence & ~Layer.o | layer),
	                        r: 'd' == key[7] ? [] : conditions,
	                        i: important
	                    }, context));
	                    continue;
	                }
	                // @import
	                if ('i' == key[1]) {
	                    rules.push(...asArray(value).map((value)=>({
	                            // before all layers
	                            p: -1,
	                            o: 0,
	                            r: [],
	                            d: key + ' ' + value
	                        })));
	                    continue;
	                }
	                // @keyframes
	                if ('k' == key[1]) {
	                    // Use defaults layer
	                    rules.push({
	                        p: Layer.d,
	                        o: 0,
	                        r: [
	                            key
	                        ],
	                        d: serialize$(value, {
	                            p: Layer.d
	                        }, context).map(stringify$1).join('')
	                    });
	                    continue;
	                }
	                // @font-face
	                // TODO @font-feature-values
	                if ('f' == key[1]) {
	                    // Use defaults layer
	                    rules.push(...asArray(value).map((value)=>({
	                            p: Layer.d,
	                            o: 0,
	                            r: [
	                                key
	                            ],
	                            d: serialize$(value, {
	                                p: Layer.d
	                            }, context).map(stringify$1).join('')
	                        })));
	                    continue;
	                }
	            }
	            // -> All other are handled below; same as selector
	            // @media
	            // @supports
	            // selector
	            if ('object' != typeof value || Array.isArray(value)) {
	                if ('label' == key && value) name = value + hash(JSON.stringify([
	                    precedence,
	                    important,
	                    style
	                ]));
	                else if (value || 0 === value) {
	                    // property -> hyphenate
	                    key = key.replace(/[A-Z]/g, (_)=>'-' + _.toLowerCase());
	                    // Update precedence
	                    numberOfDeclarations += 1;
	                    maxPropertyPrecedence = Math.max(maxPropertyPrecedence, '-' == (property = key)[0] ? 0 : seperatorPrecedence(property) + (/^(?:(border-(?!w|c|sty)|[tlbr].{2,4}m?$|c.{7,8}$)|([fl].{5}l|g.{8}$|pl))/.test(property) ? +!!RegExp.$1 || /* +1 */ -!!RegExp.$2 : /* -1 */ 0) + 1);
	                    declarations += (declarations ? ';' : '') + asArray(value).map((value)=>context.s(key, // support theme(...) function in values
	                        // calc(100vh - theme('spacing.12'))
	                        resolveThemeFunction('' + value, context.theme) + (important ? ' !important' : ''))).join(';');
	                }
	            } else // at-rule or non-global selector
	            if ('@' == key[0] || key.includes('&')) {
	                let rulePrecedence = precedence;
	                if ('@' == key[0]) {
	                    // Handle `@media screen(sm)` and `@media (screen(sm) or ...)`
	                    key = key.replace(/\bscreen\(([^)]+)\)/g, (_, screenKey)=>{
	                        let screen = context.theme('screens', screenKey);
	                        return screen ? (rulePrecedence |= 67108864, /* Shifts.screens */ mql(screen, '')) : _;
	                    });
	                    rulePrecedence |= atRulePrecedence(key);
	                }
	                rules.push(...serialize$(value, {
	                    n: name,
	                    p: rulePrecedence,
	                    r: [
	                        ...conditions,
	                        key
	                    ],
	                    i: important
	                }, context));
	            } else // global selector
	            rules.push(...serialize$(value, {
	                p: precedence,
	                r: [
	                    ...conditions,
	                    key
	                ]
	            }, context));
	        }
	        return(// PERF: prevent unshift using `rules = [{}]` above and then `rules[0] = {...}`
	        rules.unshift({
	            n: name,
	            p: precedence,
	            o: // number of declarations (descending)
	            Math.max(0, 15 - numberOfDeclarations) + // greatest precedence of properties
	            // if there is no property precedence this is most likely a custom property only declaration
	            // these have the highest precedence
	            1.5 * Math.min(maxPropertyPrecedence || 15, 15),
	            r: conditions,
	            // stringified declarations
	            d: declarations
	        }), rules.sort(compareTwindRules));
	    }(style, convert(rule, context, precedence, conditions), context);
	}
	function resolveThemeFunction(value, theme) {
	    // support theme(...) function in values
	    // calc(100vh - theme('spacing.12'))
	    // theme('borderColor.DEFAULT', 'currentColor')
	    // PERF: check for theme before running the regexp
	    // if (value.includes('theme')) {
	    return value.replace(/theme\((["'`])?(.+?)\1(?:\s*,\s*(["'`])?(.+?)\3)?\)/g, (_, __, key, ___, defaultValue = '')=>{
	        let value = theme(key, defaultValue);
	        return 'function' == typeof value && /color|fill|stroke/i.test(key) ? toColorValue(value) : '' + asArray(value).filter((v)=>Object(v) !== v);
	    });
	}
	// }
	// return value
	function merge(rules, name) {
	    let current;
	    // merge:
	    // - same conditions
	    // - replace name with hash of name + condititions + declarations
	    // - precedence:
	    //   - combine bits or use max precendence
	    //   - set layer bit to merged
	    let result = [];
	    for (let rule of rules)// only merge rules with declarations and names (eg no global rules)
	    if (rule.d && rule.n) {
	        if (current?.p == rule.p && '' + current.r == '' + rule.r) {
	            current.c = [
	                current.c,
	                rule.c
	            ].filter(Boolean).join(' ');
	            current.d = current.d + ';' + rule.d;
	        } else // only set name for named rules eg not for global or className propagation rules
	        result.push(current = {
	            ...rule,
	            n: rule.n && name
	        });
	    } else result.push({
	        ...rule,
	        n: rule.n && name
	    });
	    return result;
	}
	function translate(rules, context, precedence = Layer.u, conditions, important) {
	    // Sorted by precedence
	    let result = [];
	    for (let rule of rules)for (let cssRule of function(rule, context, precedence, conditions, important) {
	        rule = {
	            ...rule,
	            i: rule.i || important
	        };
	        let resolved = function(rule, context) {
	            let factory = registry.get(rule.n);
	            return factory ? factory(rule, context) : context.r(rule.n, 'dark' == rule.v[0]);
	        }(rule, context);
	        return resolved ? // a list of class names
	        'string' == typeof resolved ? ({ r: conditions , p: precedence  } = convert(rule, context, precedence, conditions), merge(translate(parse(resolved), context, precedence, conditions, rule.i), rule.n)) : Array.isArray(resolved) ? resolved.map((rule)=>{
	            var /* Shifts.layer */ /*
	To have a predictable styling the styles must be ordered.

	This order is represented by a precedence number. The lower values
	are inserted before higher values. Meaning higher precedence styles
	overwrite lower precedence styles.

	Each rule has some traits that are put into a bit set which form
	the precedence:

	| bits | trait                                                |
	| ---- | ---------------------------------------------------- |
	| 1    | dark mode                                            |
	| 2    | layer: preflight, global, components, utilities, css |
	| 1    | screens: is this a responsive variation of a rule    |
	| 5    | responsive based on min-width                        |
	| 4    | at-rules                                             |
	| 18   | pseudo and group variants                            |
	| 4    | number of declarations (descending)                  |
	| 4    | greatest precedence of properties                    |

	**Dark Mode: 1 bit**

	Flag for dark mode rules.

	**Layer: 3 bits**

	- defaults = 0: The preflight styles and any base styles registered by plugins.
	- base = 1: The global styles registered by plugins.
	- components = 2
	- variants = 3
	- compounds = 4
	- aliases = 5
	- utilities = 6: Utility classes and any utility classes registered by plugins.
	- css = 7: Styles generated by css

	**Screens: 1 bit**

	Flag for screen variants. They may not always have a `min-width` to be detected by _Responsive_ below.

	**Responsive: 4 bits**

	Based on extracted `min-width` value:

	- 576px -> 3
	- 1536px -> 10
	- 36rem -> 3
	- 96rem -> 9

	**At-Rules: 4 bits**

	Based on the count of special chars (`-:,`) within the at-rule.

	**Pseudo and group variants: 18 bits**

	Ensures predictable order of pseudo classes.

	- https://bitsofco.de/when-do-the-hover-focus-and-active-pseudo-classes-apply/#orderofstyleshoverthenfocusthenactive
	- https://developer.mozilla.org/docs/Web/CSS/:active#Active_links
	- https://github.com/tailwindlabs/tailwindcss/blob/master/stubs/defaultConfig.stub.js#L718

	**Number of declarations (descending): 4 bits**

	Allows single declaration styles to overwrite styles from multi declaration styles.

	**Greatest precedence of properties: 4 bits**

	Ensure shorthand properties are inserted before longhand properties; eg longhand override shorthand
	*/ precedence1, layer;
	            return {
	                o: 0,
	                ...rule,
	                r: [
	                    ...asArray(conditions),
	                    ...asArray(rule.r)
	                ],
	                p: (precedence1 = precedence, layer = rule.p ?? precedence, precedence1 & ~Layer.o | layer)
	            };
	        }) : serialize(resolved, rule, context, precedence, conditions) : // propagate className as is
	        [
	            {
	                c: toClassName(rule),
	                p: 0,
	                o: 0,
	                r: []
	            }
	        ];
	    }(rule, context, precedence, conditions, important))result.splice(sortedInsertionIndex(result, cssRule), 0, cssRule);
	    return result;
	}
	function translateWith(name, layer, rules, context, precedence, conditions, important, useOrderOfRules) {
	    return merge((useOrderOfRules ? rules.flatMap((rule)=>translate([
	            rule
	        ], context, precedence, conditions, important)) : translate(rules, context, precedence, conditions, important)).map((rule)=>{
	        return(// do not move defaults
	        // move only rules with a name unless they are in the base layer
	        rule.p & Layer.o && (rule.n || layer == Layer.b) ? {
	            ...rule,
	            p: rule.p & ~Layer.o | layer,
	            o: 0
	        } : rule);
	    }), name);
	}
	function define(className, layer, rules, useOrderOfRules) {
	    var factory;
	    return factory = (rule, context)=>{
	        let { n: name , p: precedence , r: conditions , i: important  } = convert(rule, context, layer);
	        return rules && translateWith(name, layer, rules, context, precedence, conditions, important, useOrderOfRules);
	    }, registry.set(className, factory), className;
	}
	/**
	   * The utility name including `-` if set, but without `!` and variants
	   */ /**
	   * All variants without trailing colon: `hover`, `after:`, `[...]`
	   */ /**
	   * Something like `!underline` or `!bg-red-500` or `!red-500`
	   */ function createRule(active, current, loc) {
	    if ('(' != active[active.length - 1]) {
	        let variants = [], important = false, negated = false, name = '';
	        for (let value of active)if (!('(' == value || /[~@]$/.test(value))) {
	            if ('!' == value[0]) {
	                value = value.slice(1);
	                important = !important;
	            }
	            if (value.endsWith(':')) {
	                variants['dark:' == value ? 'unshift' : 'push'](value.slice(0, -1));
	                continue;
	            }
	            if ('-' == value[0]) {
	                value = value.slice(1);
	                negated = !negated;
	            }
	            value.endsWith('-') && (value = value.slice(0, -1));
	            value && '&' != value && (name += (name && '-') + value);
	        }
	        if (name) {
	            negated && (name = '-' + name);
	            current[0].push({
	                n: name,
	                v: variants.filter(uniq),
	                i: important
	            });
	        }
	    }
	}
	function uniq(value, index, values) {
	    return values.indexOf(value) == index;
	}
	let cache = new Map();
	/**
	 * @internal
	 * @param token
	 * @returns
	 */ function parse(token) {
	    let parsed = cache.get(token);
	    if (!parsed) {
	        // Stack of active groupings (`(`), variants, or nested (`~` or `@`)
	        let active = [], // Stack of current rule list to put new rules in
	        // the first `0` element is the current list
	        current = [
	            []
	        ], startIndex = 0, skip = 0, comment = null, position = 0, // eslint-disable-next-line no-inner-declarations
	        commit = (isRule, endOffset = 0)=>{
	            if (startIndex != position) {
	                active.push(token.slice(startIndex, position + endOffset));
	                isRule && createRule(active, current);
	            }
	            startIndex = position + 1;
	        };
	        for(; position < token.length; position++){
	            let char = token[position];
	            if (skip) '\\' != token[position - 1] && (skip += +('[' == char) || -(']' == char));
	            else if ('[' == char) // start to skip
	            skip += 1;
	            else if (comment) {
	                if ('\\' != token[position - 1] && comment.test(token.slice(position))) {
	                    comment = null;
	                    startIndex = position + RegExp.lastMatch.length;
	                }
	            } else if ('/' == char && '\\' != token[position - 1] && ('*' == token[position + 1] || '/' == token[position + 1])) // multiline or single line comment
	            comment = '*' == token[position + 1] ? /^\*\// : /^[\r\n]/;
	            else if ('(' == char) {
	                // hover:(...) or utilitity-(...)
	                commit();
	                active.push(char);
	            } else if (':' == char) ':' != token[position + 1] && commit(false, 1);
	            else if (/[\s,)]/.test(char)) {
	                // whitespace, comma or closing brace
	                commit(true);
	                let lastGroup = active.lastIndexOf('(');
	                if (')' == char) {
	                    // Close nested block
	                    let nested = active[lastGroup - 1];
	                    if (/[~@]$/.test(nested)) {
	                        let rules = current.shift();
	                        active.length = lastGroup;
	                        // remove variants that are already applied through active
	                        createRule([
	                            ...active,
	                            '#'
	                        ], current);
	                        let { v  } = current[0].pop();
	                        for (let rule of rules)// if a rule has dark we need to splice after the first entry eg dark
	                        rule.v.splice(+('dark' == rule.v[0]) - +('dark' == v[0]), v.length);
	                        createRule([
	                            ...active,
	                            define(// named nested
	                            nested.length > 1 ? nested.slice(0, -1) + hash(JSON.stringify([
	                                nested,
	                                rules
	                            ])) : nested + '(' + format(rules) + ')', Layer.a, rules, /@$/.test(nested))
	                        ], current);
	                    }
	                    lastGroup = active.lastIndexOf('(', lastGroup - 1);
	                }
	                active.length = lastGroup + 1;
	            } else /[~@]/.test(char) && '(' == token[position + 1] && // start nested block
	            // ~(...) or button~(...)
	            // @(...) or button@(...)
	            current.unshift([]);
	        }
	        // Consume remaining stack
	        commit(true);
	        cache.set(token, parsed = current[0]);
	    }
	    return parsed;
	}
	/** The found theme value */ // indirection wrapper to remove autocomplete functions from production bundles
	/**
	 * @group Configuration
	 * @param pattern
	 */ /**
	 * @group Configuration
	 * @param pattern
	 * @param resolver
	 */ /**
	 * @group Configuration
	 * @param pattern
	 * @param resolve
	 */ // eslint-disable-next-line @typescript-eslint/ban-types
	/**
	 * @group Configuration
	 * @param pattern
	 * @param resolve
	 * @param convert
	 */ function match(pattern, // eslint-disable-next-line @typescript-eslint/ban-types
	resolve, convert) {
	    return [
	        pattern,
	        fromMatch(resolve, convert)
	    ];
	}
	/**
	 * @group Configuration
	 * @internal
	 * @deprecated Use {@link match} instead.
	 */ /**
	 * @group Configuration
	 * @internal
	 * @deprecated Use {@link match} instead.
	 */ /**
	 * @group Configuration
	 * @internal
	 * @deprecated Use {@link match} instead.
	 */ /**
	 * @group Configuration
	 * @internal
	 * @deprecated Use {@link match} instead.
	 */ function fromMatch(resolve, convert) {
	    return 'function' == typeof resolve ? resolve : 'string' == typeof resolve && /^[\w-]+$/.test(resolve) ? // a CSS property alias
	    (match, context)=>({
	            [resolve]: convert ? convert(match, context) : maybeNegate(match, 1)
	        }) : (match)=>// CSSObject, shortcut or apply
	        resolve || {
	            [match[1]]: maybeNegate(match, 2)
	        };
	}
	function maybeNegate(match, offset, value = match.slice(offset).find(Boolean) || match.$$ || match.input) {
	    return '-' == match.input[0] ? `calc(${value} * -1)` : value;
	}
	/**
	 * @group Configuration
	 * @param pattern
	 * @param section
	 * @param resolve
	 * @param convert
	 * @returns
	 */ function matchTheme(pattern, /** Theme section to use (default: `$1` — The first matched group) */ section, /** The css property (default: value of {@link section}) */ resolve, convert) {
	    return [
	        pattern,
	        fromTheme(section, resolve, convert)
	    ];
	}
	/**
	 * @group Configuration
	 * @internal
	 * @deprecated Use {@link matchTheme} instead.
	 * @param section
	 * @param resolve
	 * @param convert
	 * @returns
	 */ function fromTheme(/** Theme section to use (default: `$1` — The first matched group) */ section, /** The css property (default: value of {@link section}) */ resolve, convert) {
	    let factory = 'string' == typeof resolve ? (match, context)=>({
	            [resolve]: convert ? convert(match, context) : match._
	        }) : resolve || (({ 1: $1 , _  }, context, section)=>({
	            [$1 || section]: _
	        }));
	    return (match, context)=>{
	        let themeSection = camelize(section || match[1]), value = context.theme(themeSection, match.$$) ?? arbitrary(match.$$, themeSection, context);
	        if (null != value) return match._ = maybeNegate(match, 0, value), factory(match, context, themeSection);
	    };
	}
	/** Theme section to use (default: `$0.replace('-', 'Color')` — The matched string with `Color` appended) */ /** The css property (default: value of {@link section}) */ /** `--tw-${$0}opacity` -> '--tw-text-opacity' */ /** `section.replace('Color', 'Opacity')` -> 'textOpacity' */ /**
	 * @group Configuration
	 * @param pattern
	 * @param options
	 * @param resolve
	 * @returns
	 */ function matchColor(pattern, options = {}, resolve) {
	    return [
	        pattern,
	        colorFromTheme(options, resolve)
	    ];
	}
	/**
	 * @group Configuration
	 * @internal
	 * @deprecated Use {@link matchColor} instead.
	 * @param options
	 * @param resolve
	 * @returns
	 */ function colorFromTheme(options = {}, resolve) {
	    return (match, context)=>{
	        // text- -> textColor
	        // ring-offset(?:-|$) -> ringOffsetColor
	        let { section =camelize(match[0]).replace('-', '') + 'Color'  } = options, // extract color and opacity
	        // rose-500                  -> ['rose-500']
	        // [hsl(0_100%_/_50%)]       -> ['[hsl(0_100%_/_50%)]']
	        // indigo-500/100            -> ['indigo-500', '100']
	        // [hsl(0_100%_/_50%)]/[.25] -> ['[hsl(0_100%_/_50%)]', '[.25]']
	        [colorMatch, opacityMatch] = parseValue(match.$$);
	        if (!colorMatch) return;
	        let colorValue = context.theme(section, colorMatch) || arbitrary(colorMatch, section, context);
	        if (!colorValue || 'object' == typeof colorValue) return;
	        let { // text- -> --tw-text-opacity
	        // ring-offset(?:-|$) -> --tw-ring-offset-opacity
	        // TODO move this default into preset-tailwind?
	        opacityVariable =`--tw-${match[0].replace(/-$/, '')}-opacity` , opacitySection =section.replace('Color', 'Opacity') , property =section , selector  } = options, opacityValue = context.theme(opacitySection, opacityMatch || 'DEFAULT') || opacityMatch && arbitrary(opacityMatch, opacitySection, context), // if (typeof color != 'string') {
	        //   console.warn(`Invalid color ${colorMatch} (from ${match.input}):`, color)
	        //   return
	        // }
	        create = resolve || (({ _  })=>{
	            let properties = toCSS(property, _);
	            return selector ? {
	                [selector]: properties
	            } : properties;
	        });
	        match._ = {
	            value: toColorValue(colorValue, {
	                opacityVariable: opacityVariable || void 0,
	                opacityValue: opacityValue || void 0
	            }),
	            color: (options)=>toColorValue(colorValue, options),
	            opacityVariable: opacityVariable || void 0,
	            opacityValue: opacityValue || void 0
	        };
	        let properties = create(match, context);
	        // auto support dark mode colors
	        if (!match.dark) {
	            let darkColorValue = context.d(section, colorMatch, colorValue);
	            if (darkColorValue && darkColorValue !== colorValue) {
	                match._ = {
	                    value: toColorValue(darkColorValue, {
	                        opacityVariable: opacityVariable || void 0,
	                        opacityValue: opacityValue || '1'
	                    }),
	                    color: (options)=>toColorValue(darkColorValue, options),
	                    opacityVariable: opacityVariable || void 0,
	                    opacityValue: opacityValue || void 0
	                };
	                properties = {
	                    '&': properties,
	                    [context.v('dark')]: create(match, context)
	                };
	            }
	        }
	        return properties;
	    };
	}
	/**
	 * @internal
	 * @param input
	 */ function parseValue(input) {
	    // extract color and opacity
	    // rose-500                  -> ['rose-500']
	    // [hsl(0_100%_/_50%)]       -> ['[hsl(0_100%_/_50%)]']
	    // indigo-500/100            -> ['indigo-500', '100']
	    // [hsl(0_100%_/_50%)]/[.25] -> ['[hsl(0_100%_/_50%)]', '[.25]']
	    return (input.match(/^(\[[^\]]+]|[^/]+?)(?:\/(.+))?$/) || []).slice(1);
	}
	/**
	 * @internal
	 * @param property
	 * @param value
	 * @returns
	 */ function toCSS(property, value) {
	    let properties = {};
	    if ('string' == typeof value) properties[property] = value;
	    else {
	        value.opacityVariable && value.value.includes(value.opacityVariable) && (properties[value.opacityVariable] = value.opacityValue || '1');
	        properties[property] = value.value;
	    }
	    return properties;
	}
	/**
	 * @internal
	 * @param value
	 * @param section
	 * @param context
	 * @returns
	 */ function arbitrary(value, section, context) {
	    if ('[' == value[0] && ']' == value.slice(-1)) {
	        value = normalize(resolveThemeFunction(value.slice(1, -1), context.theme));
	        if (!section) return value;
	        if (// Respect type hints from the user on ambiguous arbitrary values - https://tailwindcss.com/docs/adding-custom-styles#resolving-ambiguities
	        !// If this is a color section and the value is a hex color, color function or color name
	        (/color|fill|stroke/i.test(section) && !(/^color:/.test(value) || /^(#|((hsl|rgb)a?|hwb|lab|lch|color)\(|[a-z]+$)/.test(value)) || // url(, [a-z]-gradient(, image(, cross-fade(, image-set(
	        /image/i.test(section) && !(/^image:/.test(value) || /^[a-z-]+\(/.test(value)) || // font-*
	        // - fontWeight (type: ['lookup', 'number', 'any'])
	        // - fontFamily (type: ['lookup', 'generic-name', 'family-name'])
	        /weight/i.test(section) && !(/^(number|any):/.test(value) || /^\d+$/.test(value)) || // bg-*
	        // - backgroundPosition (type: ['lookup', ['position', { preferOnConflict: true }]])
	        // - backgroundSize (type: ['lookup', 'length', 'percentage', 'size'])
	        /position/i.test(section) && /^(length|size):/.test(value))) // remove arbitrary type prefix — we do not need it but user may use it
	        // https://github.com/tailwindlabs/tailwindcss/blob/master/src/util/dataTypes.js
	        // url, number, percentage, length, line-width, shadow, color, image, gradient, position, family-name, lookup, any, generic-name, absolute-size, relative-size
	        return value.replace(/^[a-z-]+:/, '');
	    }
	}
	function camelize(value) {
	    return value.replace(/-./g, (x)=>x[1].toUpperCase());
	}
	/**
	 * @internal
	 * @param value
	 * @returns
	 */ function normalize(value) {
	    return(// Keep raw strings if it starts with `url(`
	    value.includes('url(') ? value.replace(/(.*?)(url\(.*?\))(.*?)/g, (_, before = '', url, after = '')=>normalize(before) + url + normalize(after)) : value.// Convert `_` to ` `, except for escaped underscores `\_`
	    replace(/(^|[^\\])_+/g, (fullMatch, characterBefore)=>characterBefore + ' '.repeat(fullMatch.length - characterBefore.length)).replace(/\\_/g, '_').// Add spaces around operators inside math functions like calc() that do not follow an operator
	    // or '('.
	    replace(/(calc|min|max|clamp)\(.+\)/g, (match)=>match.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, '$1 $2 ')));
	}
	/**
	 * @group Configuration
	 * @param param0
	 * @returns
	 */ function defineConfig({ presets =[] , ...userConfig }) {
	    // most user config values go first to have precendence over preset config
	    // only `preflight` and `theme` are applied as last preset to override all presets
	    let config = {
	        darkMode: void 0,
	        darkColor: void 0,
	        preflight: false !== userConfig.preflight && [],
	        theme: {},
	        variants: asArray(userConfig.variants),
	        rules: asArray(userConfig.rules),
	        ignorelist: asArray(userConfig.ignorelist),
	        hash: void 0,
	        stringify: (property, value)=>property + ':' + value,
	        finalize: []
	    };
	    for (let preset of asArray([
	        ...presets,
	        {
	            darkMode: userConfig.darkMode,
	            darkColor: userConfig.darkColor,
	            preflight: false !== userConfig.preflight && asArray(userConfig.preflight),
	            theme: userConfig.theme,
	            hash: userConfig.hash,
	            stringify: userConfig.stringify,
	            finalize: userConfig.finalize
	        }
	    ])){
	        let { preflight , darkMode =config.darkMode , darkColor =config.darkColor , theme , variants , rules , ignorelist , hash =config.hash , stringify =config.stringify , finalize  } = 'function' == typeof preset ? preset(config) : preset;
	        config = {
	            // values defined by user or previous presets take precedence
	            preflight: false !== config.preflight && false !== preflight && [
	                ...config.preflight,
	                ...asArray(preflight)
	            ],
	            darkMode,
	            darkColor,
	            theme: {
	                ...config.theme,
	                ...theme,
	                extend: {
	                    ...config.theme.extend,
	                    ...theme?.extend
	                }
	            },
	            variants: [
	                ...config.variants,
	                ...asArray(variants)
	            ],
	            rules: [
	                ...config.rules,
	                ...asArray(rules)
	            ],
	            ignorelist: [
	                ...config.ignorelist,
	                ...asArray(ignorelist)
	            ],
	            hash,
	            stringify,
	            finalize: [
	                ...config.finalize,
	                ...asArray(finalize)
	            ]
	        };
	    }
	    return config;
	}
	function find(value, list, cache, getResolver, context, isDark) {
	    for (let item of list){
	        let resolver = cache.get(item);
	        resolver || cache.set(item, resolver = getResolver(item));
	        let resolved = resolver(value, context, isDark);
	        if (resolved) return resolved;
	    }
	}
	function getVariantResolver(variant) {
	    var resolve;
	    return createResolve(variant[0], 'function' == typeof (resolve = variant[1]) ? resolve : ()=>resolve);
	}
	function getRuleResolver(rule) {
	    var resolve, convert;
	    return Array.isArray(rule) ? createResolve(rule[0], fromMatch(rule[1], rule[2])) : createResolve(rule, fromMatch(resolve, convert));
	}
	function createResolve(patterns, resolve) {
	    return createRegExpExecutor(patterns, (value, condition, context, isDark)=>{
	        let match = condition.exec(value);
	        if (match) return(// MATCH.$_ = value
	        match.$$ = value.slice(match[0].length), match.dark = isDark, resolve(match, context));
	    });
	}
	function createRegExpExecutor(patterns, run) {
	    let conditions = asArray(patterns).map(toCondition);
	    return (value, context, isDark)=>{
	        for (let condition of conditions){
	            let result = run(value, condition, context, isDark);
	            if (result) return result;
	        }
	    };
	}
	function toCondition(value) {
	    // "visible" -> /^visible$/
	    // "(float)-(left|right|none)" -> /^(float)-(left|right|none)$/
	    // "auto-rows-" -> /^auto-rows-/
	    // "gap(-|$)" -> /^gap(-|$)/
	    return 'string' == typeof value ? RegExp('^' + value + (value.includes('$') || '-' == value.slice(-1) ? '' : '$')) : value;
	}
	/**
	 * @group Runtime
	 * @param config
	 * @param sheet
	 */ function twind(userConfig, sheet) {
	    let config = defineConfig(userConfig), context = function({ theme , darkMode , darkColor =noop , variants , rules , hash: hash$1 , stringify , ignorelist , finalize  }) {
	        // Used to cache resolved rule values
	        let variantCache = new Map(), // lazy created resolve functions
	        variantResolvers = new Map(), // Used to cache resolved rule values
	        ruleCache = new Map(), // lazy created resolve functions
	        ruleResolvers = new Map(), ignored = createRegExpExecutor(ignorelist, (value, condition)=>condition.test(value));
	        // add dark as last variant to allow user to override it
	        // we can modify variants as it has been passed through defineConfig which already made a copy
	        variants.push([
	            'dark',
	            Array.isArray(darkMode) || 'class' == darkMode ? `${asArray(darkMode)[1] || '.dark'} &` : 'string' == typeof darkMode && 'media' != darkMode ? darkMode : // a custom selector
	            '@media (prefers-color-scheme:dark)'
	        ]);
	        let h = 'function' == typeof hash$1 ? (value)=>hash$1(value, hash) : hash$1 ? hash : identity;
	        h !== identity && finalize.push((rule)=>({
	                ...rule,
	                n: rule.n && h(rule.n),
	                d: rule.d?.replace(/--(tw(?:-[\w-]+)?)\b/g, (_, property)=>'--' + h(property).replace('#', ''))
	            }));
	        let ctx = {
	            theme: function({ extend ={} , ...base }) {
	                let resolved = {}, resolveContext = {
	                    get colors () {
	                        return theme('colors');
	                    },
	                    theme,
	                    // Stub implementation as negated values are automatically infered and do _not_ need to be in the theme
	                    negative () {
	                        return {};
	                    },
	                    breakpoints (screens) {
	                        let breakpoints = {};
	                        for(let key in screens)'string' == typeof screens[key] && (breakpoints['screen-' + key] = screens[key]);
	                        return breakpoints;
	                    }
	                };
	                return theme;
	                function theme(sectionKey, key, defaultValue, opacityValue) {
	                    if (sectionKey) {
	                        ({ 1: sectionKey , 2: opacityValue  } = // eslint-disable-next-line no-sparse-arrays
	                        /^(\S+?)(?:\s*\/\s*([^/]+))?$/.exec(sectionKey) || [
	                            ,
	                            sectionKey
	                        ]);
	                        if (/[.[]/.test(sectionKey)) {
	                            let path = [];
	                            // dotted deep access: colors.gray.500 or spacing[2.5]
	                            sectionKey.replace(/\[([^\]]+)\]|([^.[]+)/g, (_, $1, $2 = $1)=>path.push($2));
	                            sectionKey = path.shift();
	                            defaultValue = key;
	                            key = path.join('-');
	                        }
	                        let section = resolved[sectionKey] || // two-step deref to allow extend section to reference base section
	                        Object.assign(Object.assign(// Make sure to not get into recursive calls
	                        resolved[sectionKey] = {}, deref(base, sectionKey)), deref(extend, sectionKey));
	                        if (null == key) return section;
	                        key || (key = 'DEFAULT');
	                        let value = section[key] ?? key.split('-').reduce((obj, prop)=>obj?.[prop], section) ?? defaultValue;
	                        return opacityValue ? toColorValue(value, {
	                            opacityValue: resolveThemeFunction(opacityValue, theme)
	                        }) : value;
	                    }
	                    // Collect the whole theme
	                    let result = {};
	                    for (let section1 of [
	                        ...Object.keys(base),
	                        ...Object.keys(extend)
	                    ])result[section1] = theme(section1);
	                    return result;
	                }
	                function deref(source, section) {
	                    let value = source[section];
	                    return ('function' == typeof value && (value = value(resolveContext)), value && /color|fill|stroke/i.test(section)) ? function flattenColorPalette(colors, path = []) {
	                        let flattend = {};
	                        for(let key in colors){
	                            let value = colors[key], keyPath = [
	                                ...path,
	                                key
	                            ];
	                            flattend[keyPath.join('-')] = value;
	                            if ('DEFAULT' == key) {
	                                keyPath = path;
	                                flattend[path.join('-')] = value;
	                            }
	                            'object' == typeof value && Object.assign(flattend, flattenColorPalette(value, keyPath));
	                        }
	                        return flattend;
	                    }(value) : value;
	                }
	            }(theme),
	            e: escape,
	            h,
	            s (property, value) {
	                return stringify(property, value, ctx);
	            },
	            d (section, key, color) {
	                return darkColor(section, key, ctx, color);
	            },
	            v (value) {
	                return variantCache.has(value) || variantCache.set(value, find(value, variants, variantResolvers, getVariantResolver, ctx) || '&:' + value), variantCache.get(value);
	            },
	            r (className, isDark) {
	                let key = JSON.stringify([
	                    className,
	                    isDark
	                ]);
	                return ruleCache.has(key) || ruleCache.set(key, !ignored(className, ctx) && find(className, rules, ruleResolvers, getRuleResolver, ctx, isDark)), ruleCache.get(key);
	            },
	            f (rule) {
	                return finalize.reduce((rule, p)=>p(rule, ctx), rule);
	            }
	        };
	        return ctx;
	    }(config), // Map of tokens to generated className
	    cache = new Map(), // An array of precedence by index within the sheet
	    // always sorted
	    sortedPrecedences = [], // Cache for already inserted css rules
	    // to prevent double insertions
	    insertedRules = new Set();
	    sheet.resume((className)=>cache.set(className, className), (cssText, rule)=>{
	        sheet.insert(cssText, sortedPrecedences.length, rule);
	        sortedPrecedences.push(rule);
	        insertedRules.add(cssText);
	    });
	    function insert(rule) {
	        let finalRule = context.f(rule), cssText = stringify$1(finalRule);
	        // If not already inserted
	        if (cssText && !insertedRules.has(cssText)) {
	            // Mark rule as inserted
	            insertedRules.add(cssText);
	            // Find the correct position
	            let index = sortedInsertionIndex(sortedPrecedences, rule);
	            // Insert
	            sheet.insert(cssText, index, rule);
	            // Update sorted index
	            sortedPrecedences.splice(index, 0, rule);
	        }
	        return finalRule.n;
	    }
	    return Object.defineProperties(function tw(tokens) {
	        if (!cache.size) for (let preflight of asArray(config.preflight)){
	            'function' == typeof preflight && (preflight = preflight(context));
	            preflight && ('string' == typeof preflight ? translateWith('', Layer.b, parse(preflight), context, Layer.b, [], false, true) : serialize(preflight, {}, context, Layer.b)).forEach(insert);
	        }
	        tokens = '' + tokens;
	        let className = cache.get(tokens);
	        if (!className) {
	            let classNames = new Set();
	            for (let rule of translate(parse(tokens), context))classNames.add(rule.c).add(insert(rule));
	            className = [
	                ...classNames
	            ].filter(Boolean).join(' ');
	            // Remember the generated class name
	            cache.set(tokens, className).set(className, className);
	        }
	        return className;
	    }, Object.getOwnPropertyDescriptors({
	        get target () {
	            return sheet.target;
	        },
	        theme: context.theme,
	        config,
	        snapshot () {
	            let restoreSheet = sheet.snapshot(), insertedRules$ = new Set(insertedRules), cache$ = new Map(cache), sortedPrecedences$ = [
	                ...sortedPrecedences
	            ];
	            return ()=>{
	                restoreSheet();
	                insertedRules = insertedRules$;
	                cache = cache$;
	                sortedPrecedences = sortedPrecedences$;
	            };
	        },
	        clear () {
	            sheet.clear();
	            insertedRules = new Set();
	            cache = new Map();
	            sortedPrecedences = [];
	        },
	        destroy () {
	            this.clear();
	            sheet.destroy();
	        }
	    }));
	}
	/**
	 * Determines if two class name strings contain the same classes.
	 *
	 * @param a first class names
	 * @param b second class names
	 * @returns are they different
	 */ function changed(a, b) {
	    return a != b && '' + a.split(' ').sort() != '' + b.split(' ').sort();
	}
	/**
	 * @group Runtime
	 * @param tw
	 * @param target
	 * @returns
	 * @internal
	 */ function mo(tw) {
	    let observer = new MutationObserver(handleMutationRecords);
	    return {
	        observe (target) {
	            observer.observe(target, {
	                attributeFilter: [
	                    'class'
	                ],
	                subtree: true,
	                childList: true
	            });
	            // handle class attribute on target
	            handleClassAttributeChange(target);
	            // handle children of target
	            handleMutationRecords([
	                {
	                    target,
	                    type: ''
	                }
	            ]);
	        },
	        disconnect () {
	            observer.disconnect();
	        }
	    };
	    function handleMutationRecords(records) {
	        for (let { type , target  } of records)if ('a' == type[0]) /* attribute */ // class attribute has been changed
	        handleClassAttributeChange(target);
	        else /* childList */ // some nodes have been added — find all with a class attribute
	        for (let el of target.querySelectorAll('[class]'))handleClassAttributeChange(el);
	        // remove pending mutations — these are triggered by updating the class attributes
	        observer.takeRecords();
	    }
	    // XXX maybe we need to handle all pending mutations
	    // observer.takeRecords().forEach(handleMutation)
	    function handleClassAttributeChange(target) {
	        let className;
	        // Not using target.classList.value (not supported in all browsers) or target.class (this is an SVGAnimatedString for svg)
	        // safe guard access to getAttribute because ShadowRoot does not have attribute but child nodes
	        let tokens = target.getAttribute?.('class');
	        tokens && changed(tokens, className = tw(tokens)) && // Not using `target.className = ...` as that is read-only for SVGElements
	        target.setAttribute('class', className);
	    }
	}
	/**
	 * @group Runtime
	 * @param tw
	 * @param target
	 * @returns
	 */ function observe(tw$1 = tw, target = 'undefined' != typeof document && document.documentElement) {
	    if (target) {
	        let observer = mo(tw$1);
	        observer.observe(target);
	        // monkey patch tw.destroy to disconnect this observer
	        // eslint-disable-next-line @typescript-eslint/unbound-method
	        let { destroy  } = tw$1;
	        tw$1.destroy = ()=>{
	            observer.disconnect();
	            destroy.call(tw$1);
	        };
	    }
	    return tw$1;
	}
	/**
	 * Simplified MutationRecord which allows us to pass an
	 * ArrayLike (compatible with Array and NodeList) `addedNodes` and
	 * omit other properties we are not interested in.
	 */ function getStyleElement(selector) {
	    let style = document.querySelector(selector || 'style[data-twind=""]');
	    if (!style || 'STYLE' != style.tagName) {
	        style = document.createElement('style');
	        document.head.prepend(style);
	    }
	    return style.dataset.twind = 'claimed', style;
	}
	/**
	 * @group Sheets
	 * @param element
	 * @returns
	 */ function cssom(element) {
	    let target = element?.cssRules ? element : (element && 'string' != typeof element ? element : getStyleElement(element)).sheet;
	    return {
	        target,
	        snapshot () {
	            // collect current rules
	            let rules = Array.from(target.cssRules, (rule)=>rule.cssText);
	            return ()=>{
	                // remove all existing rules
	                this.clear();
	                // add all snapshot rules back
	                // eslint-disable-next-line @typescript-eslint/unbound-method
	                rules.forEach(this.insert);
	            };
	        },
	        clear () {
	            // remove all added rules
	            for(let index = target.cssRules.length; index--;)target.deleteRule(index);
	        },
	        destroy () {
	            target.ownerNode?.remove();
	        },
	        insert (cssText, index) {
	            try {
	                // Insert
	                target.insertRule(cssText, index);
	            } catch (error) {
	                // Empty rule to keep index valid — not using `*{}` as that would show up in all rules (DX)
	                target.insertRule(':root{}', index);
	            }
	        },
	        resume: noop
	    };
	}
	/**
	 * A proxy to the currently active Twind instance.
	 * @group Style Injectors
	 */ let tw = /* #__PURE__ */ new Proxy(// just exposing the active as tw should work with most bundlers
	// as ES module export can be re-assigned BUT some bundlers to not honor this
	// -> using a delegation proxy here
	noop, {
	    apply (_target, _thisArg, args) {
	        return active(args[0]);
	    },
	    get (target, property) {
	        let value = active[property];
	        return 'function' == typeof value ? function() {
	            // eslint-disable-next-line prefer-rest-params
	            return value.apply(active, arguments);
	        } : value;
	    }
	});

	/**
	 * @module @twind/preset-tailwind/baseTheme
	 */ /**
	 * @experimental
	 */ let theme = {
	    screens: {
	        sm: '640px',
	        md: '768px',
	        lg: '1024px',
	        xl: '1280px',
	        '2xl': '1536px'
	    },
	    columns: {
	        auto: 'auto',
	        // Handled by plugin,
	        // 1: '1',
	        // 2: '2',
	        // 3: '3',
	        // 4: '4',
	        // 5: '5',
	        // 6: '6',
	        // 7: '7',
	        // 8: '8',
	        // 9: '9',
	        // 10: '10',
	        // 11: '11',
	        // 12: '12',
	        '3xs': '16rem',
	        '2xs': '18rem',
	        xs: '20rem',
	        sm: '24rem',
	        md: '28rem',
	        lg: '32rem',
	        xl: '36rem',
	        '2xl': '42rem',
	        '3xl': '48rem',
	        '4xl': '56rem',
	        '5xl': '64rem',
	        '6xl': '72rem',
	        '7xl': '80rem'
	    },
	    spacing: {
	        px: '1px',
	        0: '0px',
	        .../* #__PURE__ */ linear(4, 'rem', 4, 0.5, 0.5),
	        // 0.5: '0.125rem',
	        // 1: '0.25rem',
	        // 1.5: '0.375rem',
	        // 2: '0.5rem',
	        // 2.5: '0.625rem',
	        // 3: '0.75rem',
	        // 3.5: '0.875rem',
	        // 4: '1rem',
	        .../* #__PURE__ */ linear(12, 'rem', 4, 5),
	        // 5: '1.25rem',
	        // 6: '1.5rem',
	        // 7: '1.75rem',
	        // 8: '2rem',
	        // 9: '2.25rem',
	        // 10: '2.5rem',
	        // 11: '2.75rem',
	        // 12: '3rem',
	        14: '3.5rem',
	        .../* #__PURE__ */ linear(64, 'rem', 4, 16, 4),
	        // 16: '4rem',
	        // 20: '5rem',
	        // 24: '6rem',
	        // 28: '7rem',
	        // 32: '8rem',
	        // 36: '9rem',
	        // 40: '10rem',
	        // 44: '11rem',
	        // 48: '12rem',
	        // 52: '13rem',
	        // 56: '14rem',
	        // 60: '15rem',
	        // 64: '16rem',
	        72: '18rem',
	        80: '20rem',
	        96: '24rem'
	    },
	    durations: {
	        75: '75ms',
	        100: '100ms',
	        150: '150ms',
	        200: '200ms',
	        300: '300ms',
	        500: '500ms',
	        700: '700ms',
	        1000: '1000ms'
	    },
	    animation: {
	        none: 'none',
	        spin: 'spin 1s linear infinite',
	        ping: 'ping 1s cubic-bezier(0,0,0.2,1) infinite',
	        pulse: 'pulse 2s cubic-bezier(0.4,0,0.6,1) infinite',
	        bounce: 'bounce 1s infinite'
	    },
	    aspectRatio: {
	        auto: 'auto',
	        square: '1/1',
	        video: '16/9'
	    },
	    backdropBlur: /* #__PURE__ */ alias('blur'),
	    backdropBrightness: /* #__PURE__ */ alias('brightness'),
	    backdropContrast: /* #__PURE__ */ alias('contrast'),
	    backdropGrayscale: /* #__PURE__ */ alias('grayscale'),
	    backdropHueRotate: /* #__PURE__ */ alias('hueRotate'),
	    backdropInvert: /* #__PURE__ */ alias('invert'),
	    backdropOpacity: /* #__PURE__ */ alias('opacity'),
	    backdropSaturate: /* #__PURE__ */ alias('saturate'),
	    backdropSepia: /* #__PURE__ */ alias('sepia'),
	    backgroundColor: /* #__PURE__ */ alias('colors'),
	    backgroundImage: {
	        none: 'none'
	    },
	    // These are built-in
	    // 'gradient-to-t': 'linear-gradient(to top, var(--tw-gradient-stops))',
	    // 'gradient-to-tr': 'linear-gradient(to top right, var(--tw-gradient-stops))',
	    // 'gradient-to-r': 'linear-gradient(to right, var(--tw-gradient-stops))',
	    // 'gradient-to-br': 'linear-gradient(to bottom right, var(--tw-gradient-stops))',
	    // 'gradient-to-b': 'linear-gradient(to bottom, var(--tw-gradient-stops))',
	    // 'gradient-to-bl': 'linear-gradient(to bottom left, var(--tw-gradient-stops))',
	    // 'gradient-to-l': 'linear-gradient(to left, var(--tw-gradient-stops))',
	    // 'gradient-to-tl': 'linear-gradient(to top left, var(--tw-gradient-stops))',
	    backgroundOpacity: /* #__PURE__ */ alias('opacity'),
	    // backgroundPosition: {
	    //   // The following are already handled by the plugin:
	    //   // center, right, left, bottom, top
	    //   // 'bottom-10px-right-20px' -> bottom 10px right 20px
	    // },
	    backgroundSize: {
	        auto: 'auto',
	        cover: 'cover',
	        contain: 'contain'
	    },
	    blur: {
	        none: 'none',
	        0: '0',
	        sm: '4px',
	        DEFAULT: '8px',
	        md: '12px',
	        lg: '16px',
	        xl: '24px',
	        '2xl': '40px',
	        '3xl': '64px'
	    },
	    brightness: {
	        .../* #__PURE__ */ linear(200, '', 100, 0, 50),
	        // 0: '0',
	        // 50: '.5',
	        // 150: '1.5',
	        // 200: '2',
	        .../* #__PURE__ */ linear(110, '', 100, 90, 5),
	        // 90: '.9',
	        // 95: '.95',
	        // 100: '1',
	        // 105: '1.05',
	        // 110: '1.1',
	        75: '0.75',
	        125: '1.25'
	    },
	    borderColor: ({ theme  })=>({
	            DEFAULT: theme('colors.gray.200', 'currentColor'),
	            ...theme('colors')
	        }),
	    borderOpacity: /* #__PURE__ */ alias('opacity'),
	    borderRadius: {
	        none: '0px',
	        sm: '0.125rem',
	        DEFAULT: '0.25rem',
	        md: '0.375rem',
	        lg: '0.5rem',
	        xl: '0.75rem',
	        '2xl': '1rem',
	        '3xl': '1.5rem',
	        '1/2': '50%',
	        full: '9999px'
	    },
	    borderSpacing: /* #__PURE__ */ alias('spacing'),
	    borderWidth: {
	        DEFAULT: '1px',
	        .../* #__PURE__ */ exponential(8, 'px')
	    },
	    // 0: '0px',
	    // 2: '2px',
	    // 4: '4px',
	    // 8: '8px',
	    boxShadow: {
	        sm: '0 1px 2px 0 rgba(0,0,0,0.05)',
	        DEFAULT: '0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px -1px rgba(0,0,0,0.1)',
	        md: '0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1)',
	        lg: '0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -4px rgba(0,0,0,0.1)',
	        xl: '0 20px 25px -5px rgba(0,0,0,0.1), 0 8px 10px -6px rgba(0,0,0,0.1)',
	        '2xl': '0 25px 50px -12px rgba(0,0,0,0.25)',
	        inner: 'inset 0 2px 4px 0 rgba(0,0,0,0.05)',
	        none: '0 0 #0000'
	    },
	    boxShadowColor: alias('colors'),
	    // container: {},
	    // cursor: {
	    //   // Default values are handled by plugin
	    // },
	    caretColor: /* #__PURE__ */ alias('colors'),
	    accentColor: ({ theme  })=>({
	            auto: 'auto',
	            ...theme('colors')
	        }),
	    contrast: {
	        .../* #__PURE__ */ linear(200, '', 100, 0, 50),
	        // 0: '0',
	        // 50: '.5',
	        // 150: '1.5',
	        // 200: '2',
	        75: '0.75',
	        125: '1.25'
	    },
	    content: {
	        none: 'none'
	    },
	    divideColor: /* #__PURE__ */ alias('borderColor'),
	    divideOpacity: /* #__PURE__ */ alias('borderOpacity'),
	    divideWidth: /* #__PURE__ */ alias('borderWidth'),
	    dropShadow: {
	        sm: '0 1px 1px rgba(0,0,0,0.05)',
	        DEFAULT: [
	            '0 1px 2px rgba(0,0,0,0.1)',
	            '0 1px 1px rgba(0,0,0,0.06)'
	        ],
	        md: [
	            '0 4px 3px rgba(0,0,0,0.07)',
	            '0 2px 2px rgba(0,0,0,0.06)'
	        ],
	        lg: [
	            '0 10px 8px rgba(0,0,0,0.04)',
	            '0 4px 3px rgba(0,0,0,0.1)'
	        ],
	        xl: [
	            '0 20px 13px rgba(0,0,0,0.03)',
	            '0 8px 5px rgba(0,0,0,0.08)'
	        ],
	        '2xl': '0 25px 25px rgba(0,0,0,0.15)',
	        none: '0 0 #0000'
	    },
	    fill: ({ theme  })=>({
	            ...theme('colors'),
	            none: 'none'
	        }),
	    grayscale: {
	        DEFAULT: '100%',
	        0: '0'
	    },
	    hueRotate: {
	        0: '0deg',
	        15: '15deg',
	        30: '30deg',
	        60: '60deg',
	        90: '90deg',
	        180: '180deg'
	    },
	    invert: {
	        DEFAULT: '100%',
	        0: '0'
	    },
	    flex: {
	        1: '1 1 0%',
	        auto: '1 1 auto',
	        initial: '0 1 auto',
	        none: 'none'
	    },
	    flexBasis: ({ theme  })=>({
	            ...theme('spacing'),
	            ...ratios(2, 6),
	            // '1/2': '50%',
	            // '1/3': '33.333333%',
	            // '2/3': '66.666667%',
	            // '1/4': '25%',
	            // '2/4': '50%',
	            // '3/4': '75%',
	            // '1/5': '20%',
	            // '2/5': '40%',
	            // '3/5': '60%',
	            // '4/5': '80%',
	            // '1/6': '16.666667%',
	            // '2/6': '33.333333%',
	            // '3/6': '50%',
	            // '4/6': '66.666667%',
	            // '5/6': '83.333333%',
	            ...ratios(12, 12),
	            // '1/12': '8.333333%',
	            // '2/12': '16.666667%',
	            // '3/12': '25%',
	            // '4/12': '33.333333%',
	            // '5/12': '41.666667%',
	            // '6/12': '50%',
	            // '7/12': '58.333333%',
	            // '8/12': '66.666667%',
	            // '9/12': '75%',
	            // '10/12': '83.333333%',
	            // '11/12': '91.666667%',
	            auto: 'auto',
	            full: '100%'
	        }),
	    flexGrow: {
	        DEFAULT: 1,
	        0: 0
	    },
	    flexShrink: {
	        DEFAULT: 1,
	        0: 0
	    },
	    fontFamily: {
	        sans: 'ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji"'.split(','),
	        serif: 'ui-serif,Georgia,Cambria,"Times New Roman",Times,serif'.split(','),
	        mono: 'ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'.split(',')
	    },
	    fontSize: {
	        xs: [
	            '0.75rem',
	            '1rem'
	        ],
	        sm: [
	            '0.875rem',
	            '1.25rem'
	        ],
	        base: [
	            '1rem',
	            '1.5rem'
	        ],
	        lg: [
	            '1.125rem',
	            '1.75rem'
	        ],
	        xl: [
	            '1.25rem',
	            '1.75rem'
	        ],
	        '2xl': [
	            '1.5rem',
	            '2rem'
	        ],
	        '3xl': [
	            '1.875rem',
	            '2.25rem'
	        ],
	        '4xl': [
	            '2.25rem',
	            '2.5rem'
	        ],
	        '5xl': [
	            '3rem',
	            '1'
	        ],
	        '6xl': [
	            '3.75rem',
	            '1'
	        ],
	        '7xl': [
	            '4.5rem',
	            '1'
	        ],
	        '8xl': [
	            '6rem',
	            '1'
	        ],
	        '9xl': [
	            '8rem',
	            '1'
	        ]
	    },
	    fontWeight: {
	        thin: '100',
	        extralight: '200',
	        light: '300',
	        normal: '400',
	        medium: '500',
	        semibold: '600',
	        bold: '700',
	        extrabold: '800',
	        black: '900'
	    },
	    gap: /* #__PURE__ */ alias('spacing'),
	    gradientColorStops: /* #__PURE__ */ alias('colors'),
	    gridAutoColumns: {
	        auto: 'auto',
	        min: 'min-content',
	        max: 'max-content',
	        fr: 'minmax(0,1fr)'
	    },
	    gridAutoRows: {
	        auto: 'auto',
	        min: 'min-content',
	        max: 'max-content',
	        fr: 'minmax(0,1fr)'
	    },
	    gridColumn: {
	        // span-X is handled by the plugin: span-1 -> span 1 / span 1
	        auto: 'auto',
	        'span-full': '1 / -1'
	    },
	    // gridColumnEnd: {
	    //   // Defaults handled by plugin
	    // },
	    // gridColumnStart: {
	    //   // Defaults handled by plugin
	    // },
	    gridRow: {
	        // span-X is handled by the plugin: span-1 -> span 1 / span 1
	        auto: 'auto',
	        'span-full': '1 / -1'
	    },
	    // gridRowStart: {
	    //   // Defaults handled by plugin
	    // },
	    // gridRowEnd: {
	    //   // Defaults handled by plugin
	    // },
	    gridTemplateColumns: {
	        // numbers are handled by the plugin: 1 -> repeat(1, minmax(0, 1fr))
	        none: 'none'
	    },
	    gridTemplateRows: {
	        // numbers are handled by the plugin: 1 -> repeat(1, minmax(0, 1fr))
	        none: 'none'
	    },
	    height: ({ theme  })=>({
	            ...theme('spacing'),
	            ...ratios(2, 6),
	            // '1/2': '50%',
	            // '1/3': '33.333333%',
	            // '2/3': '66.666667%',
	            // '1/4': '25%',
	            // '2/4': '50%',
	            // '3/4': '75%',
	            // '1/5': '20%',
	            // '2/5': '40%',
	            // '3/5': '60%',
	            // '4/5': '80%',
	            // '1/6': '16.666667%',
	            // '2/6': '33.333333%',
	            // '3/6': '50%',
	            // '4/6': '66.666667%',
	            // '5/6': '83.333333%',
	            min: 'min-content',
	            max: 'max-content',
	            fit: 'fit-content',
	            auto: 'auto',
	            full: '100%',
	            screen: '100vh'
	        }),
	    inset: ({ theme  })=>({
	            ...theme('spacing'),
	            ...ratios(2, 4),
	            // '1/2': '50%',
	            // '1/3': '33.333333%',
	            // '2/3': '66.666667%',
	            // '1/4': '25%',
	            // '2/4': '50%',
	            // '3/4': '75%',
	            auto: 'auto',
	            full: '100%'
	        }),
	    keyframes: {
	        spin: {
	            from: {
	                transform: 'rotate(0deg)'
	            },
	            to: {
	                transform: 'rotate(360deg)'
	            }
	        },
	        ping: {
	            '0%': {
	                transform: 'scale(1)',
	                opacity: '1'
	            },
	            '75%,100%': {
	                transform: 'scale(2)',
	                opacity: '0'
	            }
	        },
	        pulse: {
	            '0%,100%': {
	                opacity: '1'
	            },
	            '50%': {
	                opacity: '.5'
	            }
	        },
	        bounce: {
	            '0%, 100%': {
	                transform: 'translateY(-25%)',
	                animationTimingFunction: 'cubic-bezier(0.8,0,1,1)'
	            },
	            '50%': {
	                transform: 'none',
	                animationTimingFunction: 'cubic-bezier(0,0,0.2,1)'
	            }
	        }
	    },
	    letterSpacing: {
	        tighter: '-0.05em',
	        tight: '-0.025em',
	        normal: '0em',
	        wide: '0.025em',
	        wider: '0.05em',
	        widest: '0.1em'
	    },
	    lineHeight: {
	        .../* #__PURE__ */ linear(10, 'rem', 4, 3),
	        // 3: '.75rem',
	        // 4: '1rem',
	        // 5: '1.25rem',
	        // 6: '1.5rem',
	        // 7: '1.75rem',
	        // 8: '2rem',
	        // 9: '2.25rem',
	        // 10: '2.5rem',
	        none: '1',
	        tight: '1.25',
	        snug: '1.375',
	        normal: '1.5',
	        relaxed: '1.625',
	        loose: '2'
	    },
	    // listStyleType: {
	    //   // Defaults handled by plugin
	    // },
	    margin: ({ theme  })=>({
	            auto: 'auto',
	            ...theme('spacing')
	        }),
	    maxHeight: ({ theme  })=>({
	            full: '100%',
	            min: 'min-content',
	            max: 'max-content',
	            fit: 'fit-content',
	            screen: '100vh',
	            ...theme('spacing')
	        }),
	    maxWidth: ({ theme , breakpoints  })=>({
	            ...breakpoints(theme('screens')),
	            none: 'none',
	            0: '0rem',
	            xs: '20rem',
	            sm: '24rem',
	            md: '28rem',
	            lg: '32rem',
	            xl: '36rem',
	            '2xl': '42rem',
	            '3xl': '48rem',
	            '4xl': '56rem',
	            '5xl': '64rem',
	            '6xl': '72rem',
	            '7xl': '80rem',
	            full: '100%',
	            min: 'min-content',
	            max: 'max-content',
	            fit: 'fit-content',
	            prose: '65ch'
	        }),
	    minHeight: {
	        0: '0px',
	        full: '100%',
	        min: 'min-content',
	        max: 'max-content',
	        fit: 'fit-content',
	        screen: '100vh'
	    },
	    minWidth: {
	        0: '0px',
	        full: '100%',
	        min: 'min-content',
	        max: 'max-content',
	        fit: 'fit-content'
	    },
	    // objectPosition: {
	    //   // The plugins joins all arguments by default
	    // },
	    opacity: {
	        .../* #__PURE__ */ linear(100, '', 100, 0, 10),
	        // 0: '0',
	        // 10: '0.1',
	        // 20: '0.2',
	        // 30: '0.3',
	        // 40: '0.4',
	        // 60: '0.6',
	        // 70: '0.7',
	        // 80: '0.8',
	        // 90: '0.9',
	        // 100: '1',
	        5: '0.05',
	        25: '0.25',
	        75: '0.75',
	        95: '0.95'
	    },
	    order: {
	        // Handled by plugin
	        // 1: '1',
	        // 2: '2',
	        // 3: '3',
	        // 4: '4',
	        // 5: '5',
	        // 6: '6',
	        // 7: '7',
	        // 8: '8',
	        // 9: '9',
	        // 10: '10',
	        // 11: '11',
	        // 12: '12',
	        first: '-9999',
	        last: '9999',
	        none: '0'
	    },
	    padding: /* #__PURE__ */ alias('spacing'),
	    placeholderColor: /* #__PURE__ */ alias('colors'),
	    placeholderOpacity: /* #__PURE__ */ alias('opacity'),
	    outlineColor: /* #__PURE__ */ alias('colors'),
	    outlineOffset: /* #__PURE__ */ exponential(8, 'px'),
	    // 0: '0px',
	    // 1: '1px',
	    // 2: '2px',
	    // 4: '4px',
	    // 8: '8px',,
	    outlineWidth: /* #__PURE__ */ exponential(8, 'px'),
	    // 0: '0px',
	    // 1: '1px',
	    // 2: '2px',
	    // 4: '4px',
	    // 8: '8px',,
	    ringColor: ({ theme  })=>({
	            ...theme('colors'),
	            DEFAULT: '#3b82f6'
	        }),
	    ringOffsetColor: /* #__PURE__ */ alias('colors'),
	    ringOffsetWidth: /* #__PURE__ */ exponential(8, 'px'),
	    // 0: '0px',
	    // 1: '1px',
	    // 2: '2px',
	    // 4: '4px',
	    // 8: '8px',,
	    ringOpacity: ({ theme  })=>({
	            ...theme('opacity'),
	            DEFAULT: '0.5'
	        }),
	    ringWidth: {
	        DEFAULT: '3px',
	        .../* #__PURE__ */ exponential(8, 'px')
	    },
	    // 0: '0px',
	    // 1: '1px',
	    // 2: '2px',
	    // 4: '4px',
	    // 8: '8px',
	    rotate: {
	        .../* #__PURE__ */ exponential(2, 'deg'),
	        // 0: '0deg',
	        // 1: '1deg',
	        // 2: '2deg',
	        .../* #__PURE__ */ exponential(12, 'deg', 3),
	        // 3: '3deg',
	        // 6: '6deg',
	        // 12: '12deg',
	        .../* #__PURE__ */ exponential(180, 'deg', 45)
	    },
	    // 45: '45deg',
	    // 90: '90deg',
	    // 180: '180deg',
	    saturate: /* #__PURE__ */ linear(200, '', 100, 0, 50),
	    // 0: '0',
	    // 50: '.5',
	    // 100: '1',
	    // 150: '1.5',
	    // 200: '2',
	    scale: {
	        .../* #__PURE__ */ linear(150, '', 100, 0, 50),
	        // 0: '0',
	        // 50: '.5',
	        // 150: '1.5',
	        .../* #__PURE__ */ linear(110, '', 100, 90, 5),
	        // 90: '.9',
	        // 95: '.95',
	        // 100: '1',
	        // 105: '1.05',
	        // 110: '1.1',
	        75: '0.75',
	        125: '1.25'
	    },
	    scrollMargin: /* #__PURE__ */ alias('spacing'),
	    scrollPadding: /* #__PURE__ */ alias('spacing'),
	    sepia: {
	        0: '0',
	        DEFAULT: '100%'
	    },
	    skew: {
	        .../* #__PURE__ */ exponential(2, 'deg'),
	        // 0: '0deg',
	        // 1: '1deg',
	        // 2: '2deg',
	        .../* #__PURE__ */ exponential(12, 'deg', 3)
	    },
	    // 3: '3deg',
	    // 6: '6deg',
	    // 12: '12deg',
	    space: /* #__PURE__ */ alias('spacing'),
	    stroke: ({ theme  })=>({
	            ...theme('colors'),
	            none: 'none'
	        }),
	    strokeWidth: /* #__PURE__ */ linear(2),
	    // 0: '0',
	    // 1: '1',
	    // 2: '2',,
	    textColor: /* #__PURE__ */ alias('colors'),
	    textDecorationColor: /* #__PURE__ */ alias('colors'),
	    textDecorationThickness: {
	        'from-font': 'from-font',
	        auto: 'auto',
	        .../* #__PURE__ */ exponential(8, 'px')
	    },
	    // 0: '0px',
	    // 1: '1px',
	    // 2: '2px',
	    // 4: '4px',
	    // 8: '8px',
	    textUnderlineOffset: {
	        auto: 'auto',
	        .../* #__PURE__ */ exponential(8, 'px')
	    },
	    // 0: '0px',
	    // 1: '1px',
	    // 2: '2px',
	    // 4: '4px',
	    // 8: '8px',
	    textIndent: /* #__PURE__ */ alias('spacing'),
	    textOpacity: /* #__PURE__ */ alias('opacity'),
	    // transformOrigin: {
	    //   // The following are already handled by the plugin:
	    //   // center, right, left, bottom, top
	    //   // 'bottom-10px-right-20px' -> bottom 10px right 20px
	    // },
	    transitionDuration: ({ theme  })=>({
	            ...theme('durations'),
	            DEFAULT: '150ms'
	        }),
	    transitionDelay: /* #__PURE__ */ alias('durations'),
	    transitionProperty: {
	        none: 'none',
	        all: 'all',
	        DEFAULT: 'color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter',
	        colors: 'color,background-color,border-color,text-decoration-color,fill,stroke',
	        opacity: 'opacity',
	        shadow: 'box-shadow',
	        transform: 'transform'
	    },
	    transitionTimingFunction: {
	        DEFAULT: 'cubic-bezier(0.4,0,0.2,1)',
	        linear: 'linear',
	        in: 'cubic-bezier(0.4,0,1,1)',
	        out: 'cubic-bezier(0,0,0.2,1)',
	        'in-out': 'cubic-bezier(0.4,0,0.2,1)'
	    },
	    translate: ({ theme  })=>({
	            ...theme('spacing'),
	            ...ratios(2, 4),
	            // '1/2': '50%',
	            // '1/3': '33.333333%',
	            // '2/3': '66.666667%',
	            // '1/4': '25%',
	            // '2/4': '50%',
	            // '3/4': '75%',
	            full: '100%'
	        }),
	    width: ({ theme  })=>({
	            min: 'min-content',
	            max: 'max-content',
	            fit: 'fit-content',
	            screen: '100vw',
	            ...theme('flexBasis')
	        }),
	    willChange: {
	        scroll: 'scroll-position'
	    },
	    // other options handled by rules
	    // auto: 'auto',
	    // contents: 'contents',
	    // transform: 'transform',
	    zIndex: {
	        .../* #__PURE__ */ linear(50, '', 1, 0, 10),
	        // 0: '0',
	        // 10: '10',
	        // 20: '20',
	        // 30: '30',
	        // 40: '40',
	        // 50: '50',
	        auto: 'auto'
	    }
	};
	// '1/2': '50%',
	// '1/3': '33.333333%',
	// '2/3': '66.666667%',
	// '1/4': '25%',
	// '2/4': '50%',
	// '3/4': '75%',
	// '1/5': '20%',
	// '2/5': '40%',
	// '3/5': '60%',
	// '4/5': '80%',
	// '1/6': '16.666667%',
	// '2/6': '33.333333%',
	// '3/6': '50%',
	// '4/6': '66.666667%',
	// '5/6': '83.333333%',
	function ratios(start, end) {
	    let result = {};
	    do // XXX: using var to avoid strange bug when generating cjs where `= 1` is removed
	    // eslint-disable-next-line no-var
	    for(var dividend = 1; dividend < start; dividend++)result[`${dividend}/${start}`] = Number((dividend / start * 100).toFixed(6)) + '%';
	    while (++start <= end)
	    return result;
	}
	// 0: '0px',
	// 2: '2px',
	// 4: '4px',
	// 8: '8px',
	function exponential(stop, unit, start = 0) {
	    let result = {};
	    for(; start <= stop; start = 2 * start || 1)result[start] = start + unit;
	    return result;
	}
	// 3: '.75rem',
	// 4: '1rem',
	// 5: '1.25rem',
	// 6: '1.5rem',
	// 7: '1.75rem',
	// 8: '2rem',
	// 9: '2.25rem',
	// 10: '2.5rem',
	function linear(stop, unit = '', divideBy = 1, start = 0, step = 1, result = {}) // eslint-disable-next-line max-params
	{
	    for(; start <= stop; start += step)result[start] = start / divideBy + unit;
	    return result;
	}
	function alias(section) {
	    return ({ theme  })=>theme(section);
	}

	let preflight = {
	    /*
	    1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
	    2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
	    */ '*,::before,::after': {
	        boxSizing: 'border-box',
	        /* 1 */ borderWidth: '0',
	        /* 2 */ borderStyle: 'solid',
	        /* 2 */ borderColor: 'theme(borderColor.DEFAULT, currentColor)'
	    },
	    /* 2 */ '::before,::after': {
	        '--tw-content': "''"
	    },
	    /*
	    1. Use a consistent sensible line-height in all browsers.
	    2. Prevent adjustments of font size after orientation changes in iOS.
	    3. Use a more readable tab size.
	    4. Use the user's configured `sans` font-family by default.
	    5. Use the user's configured `sans` font-feature-settings by default.
	    */ html: {
	        lineHeight: 1.5,
	        /* 1 */ WebkitTextSizeAdjust: '100%',
	        /* 2 */ MozTabSize: '4',
	        /* 3 */ tabSize: 4,
	        /* 3 */ fontFamily: `theme(fontFamily.sans, ${theme.fontFamily.sans})`,
	        /* 4 */ fontFeatureSettings: 'theme(fontFamily.sans[1].fontFeatureSettings, normal)'
	    },
	    /* 5 */ /*
	    1. Remove the margin in all browsers.
	    2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.
	    */ body: {
	        margin: '0',
	        /* 1 */ lineHeight: 'inherit'
	    },
	    /* 2 */ /*
	    1. Add the correct height in Firefox.
	    2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
	    3. Ensure horizontal rules are visible by default.
	    */ hr: {
	        height: '0',
	        /* 1 */ color: 'inherit',
	        /* 2 */ borderTopWidth: '1px'
	    },
	    /* 3 */ /*
	    Add the correct text decoration in Chrome, Edge, and Safari.
	    */ 'abbr:where([title])': {
	        textDecoration: 'underline dotted'
	    },
	    /*
	    Remove the default font size and weight for headings.
	    */ 'h1,h2,h3,h4,h5,h6': {
	        fontSize: 'inherit',
	        fontWeight: 'inherit'
	    },
	    /*
	    Reset links to optimize for opt-in styling instead of opt-out.
	    */ a: {
	        color: 'inherit',
	        textDecoration: 'inherit'
	    },
	    /*
	    Add the correct font weight in Edge and Safari.
	    */ 'b,strong': {
	        fontWeight: 'bolder'
	    },
	    /*
	    1. Use the user's configured `mono` font family by default.
	    2. Use the user's configured `mono` font-feature-settings by default.
	    3. Correct the odd `em` font sizing in all browsers.
	    */ 'code,kbd,samp,pre': {
	        fontFamily: `theme(fontFamily.mono, ${theme.fontFamily.mono})`,
	        fontFeatureSettings: 'theme(fontFamily.mono[1].fontFeatureSettings, normal)',
	        fontSize: '1em'
	    },
	    /*
	    Add the correct font size in all browsers.
	    */ small: {
	        fontSize: '80%'
	    },
	    /*
	    Prevent `sub` and `sup` elements from affecting the line height in all browsers.
	    */ 'sub,sup': {
	        fontSize: '75%',
	        lineHeight: 0,
	        position: 'relative',
	        verticalAlign: 'baseline'
	    },
	    sub: {
	        bottom: '-0.25em'
	    },
	    sup: {
	        top: '-0.5em'
	    },
	    /*
	    1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
	    2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
	    3. Remove gaps between table borders by default.
	    */ table: {
	        textIndent: '0',
	        /* 1 */ borderColor: 'inherit',
	        /* 2 */ borderCollapse: 'collapse'
	    },
	    /* 3 */ /*
	    1. Change the font styles in all browsers.
	    2. Remove the margin in Firefox and Safari.
	    3. Remove default padding in all browsers.
	    */ 'button,input,optgroup,select,textarea': {
	        fontFamily: 'inherit',
	        /* 1 */ fontSize: '100%',
	        /* 1 */ lineHeight: 'inherit',
	        /* 1 */ color: 'inherit',
	        /* 1 */ margin: '0',
	        /* 2 */ padding: '0'
	    },
	    /* 3 */ /*
	    Remove the inheritance of text transform in Edge and Firefox.
	    */ 'button,select': {
	        textTransform: 'none'
	    },
	    /*
	    1. Correct the inability to style clickable types in iOS and Safari.
	    2. Remove default button styles.
	    */ "button,[type='button'],[type='reset'],[type='submit']": {
	        WebkitAppearance: 'button',
	        /* 1 */ backgroundColor: 'transparent',
	        /* 2 */ backgroundImage: 'none'
	    },
	    /* 4 */ /*
	    Use the modern Firefox focus style for all focusable elements.
	    */ ':-moz-focusring': {
	        outline: 'auto'
	    },
	    /*
	    Remove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
	    */ ':-moz-ui-invalid': {
	        boxShadow: 'none'
	    },
	    /*
	    Add the correct vertical alignment in Chrome and Firefox.
	    */ progress: {
	        verticalAlign: 'baseline'
	    },
	    /*
	    Correct the cursor style of increment and decrement buttons in Safari.
	    */ '::-webkit-inner-spin-button,::-webkit-outer-spin-button': {
	        height: 'auto'
	    },
	    /*
	    1. Correct the odd appearance in Chrome and Safari.
	    2. Correct the outline style in Safari.
	    */ "[type='search']": {
	        WebkitAppearance: 'textfield',
	        /* 1 */ outlineOffset: '-2px'
	    },
	    /* 2 */ /*
	    Remove the inner padding in Chrome and Safari on macOS.
	    */ '::-webkit-search-decoration': {
	        WebkitAppearance: 'none'
	    },
	    /*
	    1. Correct the inability to style clickable types in iOS and Safari.
	    2. Change font properties to `inherit` in Safari.
	    */ '::-webkit-file-upload-button': {
	        WebkitAppearance: 'button',
	        /* 1 */ font: 'inherit'
	    },
	    /* 2 */ /*
	    Add the correct display in Chrome and Safari.
	    */ summary: {
	        display: 'list-item'
	    },
	    /*
	    Removes the default spacing and border for appropriate elements.
	    */ 'blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre': {
	        margin: '0'
	    },
	    fieldset: {
	        margin: '0',
	        padding: '0'
	    },
	    legend: {
	        padding: '0'
	    },
	    'ol,ul,menu': {
	        listStyle: 'none',
	        margin: '0',
	        padding: '0'
	    },
	    /*
	    Prevent resizing textareas horizontally by default.
	    */ textarea: {
	        resize: 'vertical'
	    },
	    /*
	    1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
	    2. Set the default placeholder color to the user's configured gray 400 color.
	    */ 'input::placeholder,textarea::placeholder': {
	        opacity: 1,
	        /* 1 */ color: 'theme(colors.gray.400, #9ca3af)'
	    },
	    /* 2 */ /*
	    Set the default cursor for buttons.
	    */ 'button,[role="button"]': {
	        cursor: 'pointer'
	    },
	    /*
	    Make sure disabled buttons don't get the pointer cursor.
	    */ ':disabled': {
	        cursor: 'default'
	    },
	    /*
	    1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)
	    2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
	      This can trigger a poorly considered lint error in some tools but is included by design.
	    */ 'img,svg,video,canvas,audio,iframe,embed,object': {
	        display: 'block',
	        /* 1 */ verticalAlign: 'middle'
	    },
	    /* 2 */ /*
	    Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
	    */ 'img,video': {
	        maxWidth: '100%',
	        height: 'auto'
	    },
	    /* Make elements with the HTML hidden attribute stay hidden by default */ '[hidden]': {
	        display: 'none'
	    }
	};

	// indirection wrapper to remove autocomplete functions from production bundles
	let rules = [
	    /* arbitrary properties: [paint-order:markers] */ match('\\[([-\\w]+):(.+)]', ({ 1: $1 , 2: $2  }, context)=>({
	            '@layer overrides': {
	                '&': {
	                    [$1]: arbitrary(`[${$2}]`, '', context)
	                }
	            }
	        })),
	    /* Styling based on parent and peer state */ match('(group|peer)([~/][^-[]+)?', ({ input  }, { h  })=>[
	            {
	                c: h(input)
	            }
	        ]),
	    /* LAYOUT */ matchTheme('aspect-', 'aspectRatio'),
	    match('container', (_, { theme  })=>{
	        let { screens =theme('screens') , center , padding  } = theme('container'), rules = {
	            width: '100%',
	            marginRight: center && 'auto',
	            marginLeft: center && 'auto',
	            ...paddingFor('xs')
	        };
	        for(let screen in screens){
	            let value = screens[screen];
	            'string' == typeof value && (rules[mql(value)] = {
	                '&': {
	                    maxWidth: value,
	                    ...paddingFor(screen)
	                }
	            });
	        }
	        return rules;
	        function paddingFor(screen) {
	            let value = padding && ('string' == typeof padding ? padding : padding[screen] || padding.DEFAULT);
	            if (value) return {
	                paddingRight: value,
	                paddingLeft: value
	            };
	        }
	    }),
	    // Content
	    matchTheme('content-', 'content', ({ _  })=>({
	            '--tw-content': _,
	            content: 'var(--tw-content)'
	        })),
	    // Box Decoration Break
	    match('(?:box-)?decoration-(slice|clone)', 'boxDecorationBreak'),
	    // Box Sizing
	    match('box-(border|content)', 'boxSizing', ({ 1: $1  })=>$1 + '-box'),
	    // Display
	    match('hidden', {
	        display: 'none'
	    }),
	    // Table Layout
	    match('table-(auto|fixed)', 'tableLayout'),
	    match([
	        '(block|flex|table|grid|inline|contents|flow-root|list-item)',
	        '(inline-(block|flex|table|grid))',
	        '(table-(caption|cell|column|row|(column|row|footer|header)-group))'
	    ], 'display'),
	    // Floats
	    '(float)-(left|right|none)',
	    // Clear
	    '(clear)-(left|right|none|both)',
	    // Overflow
	    '(overflow(?:-[xy])?)-(auto|hidden|clip|visible|scroll)',
	    // Isolation
	    '(isolation)-(auto)',
	    // Isolation
	    match('isolate', 'isolation'),
	    // Object Fit
	    match('object-(contain|cover|fill|none|scale-down)', 'objectFit'),
	    // Object Position
	    matchTheme('object-', 'objectPosition'),
	    match('object-(top|bottom|center|(left|right)(-(top|bottom))?)', 'objectPosition', spacify),
	    // Overscroll Behavior
	    match('overscroll(-[xy])?-(auto|contain|none)', ({ 1: $1 = '' , 2: $2  })=>({
	            ['overscroll-behavior' + $1]: $2
	        })),
	    // Position
	    match('(static|fixed|absolute|relative|sticky)', 'position'),
	    // Top / Right / Bottom / Left
	    matchTheme('-?inset(-[xy])?(?:$|-)', 'inset', ({ 1: $1 , _  })=>({
	            top: '-x' != $1 && _,
	            right: '-y' != $1 && _,
	            bottom: '-x' != $1 && _,
	            left: '-y' != $1 && _
	        })),
	    matchTheme('-?(top|bottom|left|right)(?:$|-)', 'inset'),
	    // Visibility
	    match('(visible|collapse)', 'visibility'),
	    match('invisible', {
	        visibility: 'hidden'
	    }),
	    // Z-Index
	    matchTheme('-?z-', 'zIndex'),
	    /* FLEXBOX */ // Flex Direction
	    match('flex-((row|col)(-reverse)?)', 'flexDirection', columnify),
	    match('flex-(wrap|wrap-reverse|nowrap)', 'flexWrap'),
	    matchTheme('(flex-(?:grow|shrink))(?:$|-)'),
	    /*, 'flex-grow' | flex-shrink */ matchTheme('(flex)-'),
	    /*, 'flex' */ matchTheme('grow(?:$|-)', 'flexGrow'),
	    matchTheme('shrink(?:$|-)', 'flexShrink'),
	    matchTheme('basis-', 'flexBasis'),
	    matchTheme('-?(order)-'),
	    /*, 'order' */ '-?(order)-(\\d+)',
	    /* GRID */ // Grid Template Columns
	    matchTheme('grid-cols-', 'gridTemplateColumns'),
	    match('grid-cols-(\\d+)', 'gridTemplateColumns', gridTemplate),
	    // Grid Column Start / End
	    matchTheme('col-', 'gridColumn'),
	    match('col-(span)-(\\d+)', 'gridColumn', span),
	    matchTheme('col-start-', 'gridColumnStart'),
	    match('col-start-(auto|\\d+)', 'gridColumnStart'),
	    matchTheme('col-end-', 'gridColumnEnd'),
	    match('col-end-(auto|\\d+)', 'gridColumnEnd'),
	    // Grid Template Rows
	    matchTheme('grid-rows-', 'gridTemplateRows'),
	    match('grid-rows-(\\d+)', 'gridTemplateRows', gridTemplate),
	    // Grid Row Start / End
	    matchTheme('row-', 'gridRow'),
	    match('row-(span)-(\\d+)', 'gridRow', span),
	    matchTheme('row-start-', 'gridRowStart'),
	    match('row-start-(auto|\\d+)', 'gridRowStart'),
	    matchTheme('row-end-', 'gridRowEnd'),
	    match('row-end-(auto|\\d+)', 'gridRowEnd'),
	    // Grid Auto Flow
	    match('grid-flow-((row|col)(-dense)?)', 'gridAutoFlow', (match)=>spacify(columnify(match))),
	    match('grid-flow-(dense)', 'gridAutoFlow'),
	    // Grid Auto Columns
	    matchTheme('auto-cols-', 'gridAutoColumns'),
	    // Grid Auto Rows
	    matchTheme('auto-rows-', 'gridAutoRows'),
	    // Gap
	    matchTheme('gap-x(?:$|-)', 'gap', 'columnGap'),
	    matchTheme('gap-y(?:$|-)', 'gap', 'rowGap'),
	    matchTheme('gap(?:$|-)', 'gap'),
	    /* BOX ALIGNMENT */ // Justify Items
	    // Justify Self
	    '(justify-(?:items|self))-',
	    // Justify Content
	    match('justify-', 'justifyContent', convertContentValue),
	    // Align Content
	    // Align Items
	    // Align Self
	    match('(content|items|self)-', (match)=>({
	            ['align-' + match[1]]: convertContentValue(match)
	        })),
	    // Place Content
	    // Place Items
	    // Place Self
	    match('(place-(content|items|self))-', ({ 1: $1 , $$  })=>({
	            [$1]: ('wun'.includes($$[3]) ? 'space-' : '') + $$
	        })),
	    /* SPACING */ // Padding
	    matchTheme('p([xytrbl])?(?:$|-)', 'padding', edge('padding')),
	    // Margin
	    matchTheme('-?m([xytrbl])?(?:$|-)', 'margin', edge('margin')),
	    // Space Between
	    matchTheme('-?space-(x|y)(?:$|-)', 'space', ({ 1: $1 , _  })=>({
	            '&>:not([hidden])~:not([hidden])': {
	                [`--tw-space-${$1}-reverse`]: '0',
	                ['margin-' + ({
	                    y: 'top',
	                    x: 'left'
	                })[$1]]: `calc(${_} * calc(1 - var(--tw-space-${$1}-reverse)))`,
	                ['margin-' + ({
	                    y: 'bottom',
	                    x: 'right'
	                })[$1]]: `calc(${_} * var(--tw-space-${$1}-reverse))`
	            }
	        })),
	    match('space-(x|y)-reverse', ({ 1: $1  })=>({
	            '&>:not([hidden])~:not([hidden])': {
	                [`--tw-space-${$1}-reverse`]: '1'
	            }
	        })),
	    /* SIZING */ // Width
	    matchTheme('w-', 'width'),
	    // Min-Width
	    matchTheme('min-w-', 'minWidth'),
	    // Max-Width
	    matchTheme('max-w-', 'maxWidth'),
	    // Height
	    matchTheme('h-', 'height'),
	    // Min-Height
	    matchTheme('min-h-', 'minHeight'),
	    // Max-Height
	    matchTheme('max-h-', 'maxHeight'),
	    /* TYPOGRAPHY */ // Font Weight
	    matchTheme('font-', 'fontWeight'),
	    // Font Family
	    matchTheme('font-', 'fontFamily', ({ _  })=>{
	        return 'string' == typeof (_ = asArray(_))[1] ? {
	            fontFamily: join(_)
	        } : {
	            fontFamily: join(_[0]),
	            ..._[1]
	        };
	    }),
	    // Font Smoothing
	    match('antialiased', {
	        WebkitFontSmoothing: 'antialiased',
	        MozOsxFontSmoothing: 'grayscale'
	    }),
	    match('subpixel-antialiased', {
	        WebkitFontSmoothing: 'auto',
	        MozOsxFontSmoothing: 'auto'
	    }),
	    // Font Style
	    match('italic', 'fontStyle'),
	    match('not-italic', {
	        fontStyle: 'normal'
	    }),
	    // Font Variant Numeric
	    match('(ordinal|slashed-zero|(normal|lining|oldstyle|proportional|tabular)-nums|(diagonal|stacked)-fractions)', ({ 1: $1 , 2: $2 = '' , 3: $3  })=>// normal-nums
	        'normal' == $2 ? {
	            fontVariantNumeric: 'normal'
	        } : {
	            ['--tw-' + ($3 ? // diagonal-fractions, stacked-fractions
	            'numeric-fraction' : 'pt'.includes($2[0]) ? // proportional-nums, tabular-nums
	            'numeric-spacing' : $2 ? // lining-nums, oldstyle-nums
	            'numeric-figure' : // ordinal, slashed-zero
	            $1)]: $1,
	            fontVariantNumeric: 'var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)',
	            ...asDefaults({
	                '--tw-ordinal': 'var(--tw-empty,/*!*/ /*!*/)',
	                '--tw-slashed-zero': 'var(--tw-empty,/*!*/ /*!*/)',
	                '--tw-numeric-figure': 'var(--tw-empty,/*!*/ /*!*/)',
	                '--tw-numeric-spacing': 'var(--tw-empty,/*!*/ /*!*/)',
	                '--tw-numeric-fraction': 'var(--tw-empty,/*!*/ /*!*/)'
	            })
	        }),
	    // Letter Spacing
	    matchTheme('tracking-', 'letterSpacing'),
	    // Line Height
	    matchTheme('leading-', 'lineHeight'),
	    // List Style Position
	    match('list-(inside|outside)', 'listStylePosition'),
	    // List Style Type
	    matchTheme('list-', 'listStyleType'),
	    match('list-', 'listStyleType'),
	    // Placeholder Opacity
	    matchTheme('placeholder-opacity-', 'placeholderOpacity', ({ _  })=>({
	            '&::placeholder': {
	                '--tw-placeholder-opacity': _
	            }
	        })),
	    // Placeholder Color
	    matchColor('placeholder-', {
	        property: 'color',
	        selector: '&::placeholder'
	    }),
	    // Text Alignment
	    match('text-(left|center|right|justify|start|end)', 'textAlign'),
	    match('text-(ellipsis|clip)', 'textOverflow'),
	    // Text Opacity
	    matchTheme('text-opacity-', 'textOpacity', '--tw-text-opacity'),
	    // Text Color
	    matchColor('text-', {
	        property: 'color'
	    }),
	    // Font Size
	    matchTheme('text-', 'fontSize', ({ _  })=>'string' == typeof _ ? {
	            fontSize: _
	        } : {
	            fontSize: _[0],
	            ...'string' == typeof _[1] ? {
	                lineHeight: _[1]
	            } : _[1]
	        }),
	    // Text Indent
	    matchTheme('indent-', 'textIndent'),
	    // Text Decoration
	    match('(overline|underline|line-through)', 'textDecorationLine'),
	    match('no-underline', {
	        textDecorationLine: 'none'
	    }),
	    // Text Underline offset
	    matchTheme('underline-offset-', 'textUnderlineOffset'),
	    // Text Decoration Color
	    matchColor('decoration-', {
	        section: 'textDecorationColor',
	        opacityVariable: false,
	        opacitySection: 'opacity'
	    }),
	    // Text Decoration Thickness
	    matchTheme('decoration-', 'textDecorationThickness'),
	    // Text Decoration Style
	    match('decoration-', 'textDecorationStyle'),
	    // Text Transform
	    match('(uppercase|lowercase|capitalize)', 'textTransform'),
	    match('normal-case', {
	        textTransform: 'none'
	    }),
	    // Text Overflow
	    match('truncate', {
	        overflow: 'hidden',
	        whiteSpace: 'nowrap',
	        textOverflow: 'ellipsis'
	    }),
	    // Vertical Alignment
	    match('align-', 'verticalAlign'),
	    // Whitespace
	    match('whitespace-', 'whiteSpace'),
	    // Word Break
	    match('break-normal', {
	        wordBreak: 'normal',
	        overflowWrap: 'normal'
	    }),
	    match('break-words', {
	        overflowWrap: 'break-word'
	    }),
	    match('break-all', {
	        wordBreak: 'break-all'
	    }),
	    match('break-keep', {
	        wordBreak: 'keep-all'
	    }),
	    // Caret Color
	    matchColor('caret-', {
	        // section: 'caretColor',
	        opacityVariable: false,
	        opacitySection: 'opacity'
	    }),
	    // Accent Color
	    matchColor('accent-', {
	        // section: 'accentColor',
	        opacityVariable: false,
	        opacitySection: 'opacity'
	    }),
	    // Gradient Color Stops
	    match('bg-gradient-to-([trbl]|[tb][rl])', 'backgroundImage', ({ 1: $1  })=>`linear-gradient(to ${position($1, ' ')},var(--tw-gradient-stops))`),
	    matchColor('from-', {
	        section: 'gradientColorStops',
	        opacityVariable: false,
	        opacitySection: 'opacity'
	    }, ({ _  })=>({
	            '--tw-gradient-from': _.value,
	            '--tw-gradient-to': _.color({
	                opacityValue: '0'
	            }),
	            '--tw-gradient-stops': "var(--tw-gradient-from),var(--tw-gradient-to)"
	        })),
	    matchColor('via-', {
	        section: 'gradientColorStops',
	        opacityVariable: false,
	        opacitySection: 'opacity'
	    }, ({ _  })=>({
	            '--tw-gradient-to': _.color({
	                opacityValue: '0'
	            }),
	            '--tw-gradient-stops': `var(--tw-gradient-from),${_.value},var(--tw-gradient-to)`
	        })),
	    matchColor('to-', {
	        section: 'gradientColorStops',
	        property: '--tw-gradient-to',
	        opacityVariable: false,
	        opacitySection: 'opacity'
	    }),
	    /* BACKGROUNDS */ // Background Attachment
	    match('bg-(fixed|local|scroll)', 'backgroundAttachment'),
	    // Background Origin
	    match('bg-origin-(border|padding|content)', 'backgroundOrigin', ({ 1: $1  })=>$1 + '-box'),
	    // Background Repeat
	    match([
	        'bg-(no-repeat|repeat(-[xy])?)',
	        'bg-repeat-(round|space)'
	    ], 'backgroundRepeat'),
	    // Background Blend Mode
	    match('bg-blend-', 'backgroundBlendMode'),
	    // Background Clip
	    match('bg-clip-(border|padding|content|text)', 'backgroundClip', ({ 1: $1  })=>$1 + ('text' == $1 ? '' : '-box')),
	    // Background Opacity
	    matchTheme('bg-opacity-', 'backgroundOpacity', '--tw-bg-opacity'),
	    // Background Color
	    // bg-${backgroundColor}/${backgroundOpacity}
	    matchColor('bg-', {
	        section: 'backgroundColor'
	    }),
	    // Background Image
	    // supported arbitrary types are: length, color, angle, list
	    matchTheme('bg-', 'backgroundImage'),
	    // Background Position
	    matchTheme('bg-', 'backgroundPosition'),
	    match('bg-(top|bottom|center|(left|right)(-(top|bottom))?)', 'backgroundPosition', spacify),
	    // Background Size
	    matchTheme('bg-', 'backgroundSize'),
	    /* BORDERS */ // Border Radius
	    matchTheme('rounded(?:$|-)', 'borderRadius'),
	    matchTheme('rounded-([trbl]|[tb][rl])(?:$|-)', 'borderRadius', ({ 1: $1 , _  })=>{
	        let corners = {
	            t: [
	                'tl',
	                'tr'
	            ],
	            r: [
	                'tr',
	                'br'
	            ],
	            b: [
	                'bl',
	                'br'
	            ],
	            l: [
	                'bl',
	                'tl'
	            ]
	        }[$1] || [
	            $1,
	            $1
	        ];
	        return {
	            [`border-${position(corners[0])}-radius`]: _,
	            [`border-${position(corners[1])}-radius`]: _
	        };
	    }),
	    // Border Collapse
	    match('border-(collapse|separate)', 'borderCollapse'),
	    // Border Opacity
	    matchTheme('border-opacity(?:$|-)', 'borderOpacity', '--tw-border-opacity'),
	    // Border Style
	    match('border-(solid|dashed|dotted|double|none)', 'borderStyle'),
	    // Border Spacing
	    matchTheme('border-spacing(-[xy])?(?:$|-)', 'borderSpacing', ({ 1: $1 , _  })=>({
	            ...asDefaults({
	                '--tw-border-spacing-x': '0',
	                '--tw-border-spacing-y': '0'
	            }),
	            ['--tw-border-spacing' + ($1 || '-x')]: _,
	            ['--tw-border-spacing' + ($1 || '-y')]: _,
	            'border-spacing': 'var(--tw-border-spacing-x) var(--tw-border-spacing-y)'
	        })),
	    // Border Color
	    matchColor('border-([xytrbl])-', {
	        section: 'borderColor'
	    }, edge('border', 'Color')),
	    matchColor('border-'),
	    // Border Width
	    matchTheme('border-([xytrbl])(?:$|-)', 'borderWidth', edge('border', 'Width')),
	    matchTheme('border(?:$|-)', 'borderWidth'),
	    // Divide Opacity
	    matchTheme('divide-opacity(?:$|-)', 'divideOpacity', ({ _  })=>({
	            '&>:not([hidden])~:not([hidden])': {
	                '--tw-divide-opacity': _
	            }
	        })),
	    // Divide Style
	    match('divide-(solid|dashed|dotted|double|none)', ({ 1: $1  })=>({
	            '&>:not([hidden])~:not([hidden])': {
	                borderStyle: $1
	            }
	        })),
	    // Divide Width
	    match('divide-([xy]-reverse)', ({ 1: $1  })=>({
	            '&>:not([hidden])~:not([hidden])': {
	                ['--tw-divide-' + $1]: '1'
	            }
	        })),
	    matchTheme('divide-([xy])(?:$|-)', 'divideWidth', ({ 1: $1 , _  })=>{
	        let edges = {
	            x: 'lr',
	            y: 'tb'
	        }[$1];
	        return {
	            '&>:not([hidden])~:not([hidden])': {
	                [`--tw-divide-${$1}-reverse`]: '0',
	                [`border-${position(edges[0])}Width`]: `calc(${_} * calc(1 - var(--tw-divide-${$1}-reverse)))`,
	                [`border-${position(edges[1])}Width`]: `calc(${_} * var(--tw-divide-${$1}-reverse))`
	            }
	        };
	    }),
	    // Divide Color
	    matchColor('divide-', {
	        // section: $0.replace('-', 'Color') -> 'divideColor'
	        property: 'borderColor',
	        // opacityVariable: '--tw-border-opacity',
	        // opacitySection: section.replace('Color', 'Opacity') -> 'divideOpacity'
	        selector: '&>:not([hidden])~:not([hidden])'
	    }),
	    // Ring Offset Opacity
	    matchTheme('ring-opacity(?:$|-)', 'ringOpacity', '--tw-ring-opacity'),
	    // Ring Offset Color
	    matchColor('ring-offset-', {
	        // section: 'ringOffsetColor',
	        property: '--tw-ring-offset-color',
	        opacityVariable: false
	    }),
	    // opacitySection: section.replace('Color', 'Opacity') -> 'ringOffsetOpacity'
	    // Ring Offset Width
	    matchTheme('ring-offset(?:$|-)', 'ringOffsetWidth', '--tw-ring-offset-width'),
	    // Ring Inset
	    match('ring-inset', {
	        '--tw-ring-inset': 'inset'
	    }),
	    // Ring Color
	    matchColor('ring-', {
	        // section: 'ringColor',
	        property: '--tw-ring-color'
	    }),
	    // opacityVariable: '--tw-ring-opacity',
	    // opacitySection: section.replace('Color', 'Opacity') -> 'ringOpacity'
	    // Ring Width
	    matchTheme('ring(?:$|-)', 'ringWidth', ({ _  }, { theme  })=>({
	            ...asDefaults({
	                '--tw-ring-offset-shadow': '0 0 #0000',
	                '--tw-ring-shadow': '0 0 #0000',
	                '--tw-shadow': '0 0 #0000',
	                '--tw-shadow-colored': '0 0 #0000',
	                // Within own declaration to have the defaults above to be merged with defaults from shadow
	                '&': {
	                    '--tw-ring-inset': 'var(--tw-empty,/*!*/ /*!*/)',
	                    '--tw-ring-offset-width': theme('ringOffsetWidth', '', '0px'),
	                    '--tw-ring-offset-color': toColorValue(theme('ringOffsetColor', '', '#fff')),
	                    '--tw-ring-color': toColorValue(theme('ringColor', '', '#93c5fd'), {
	                        opacityVariable: '--tw-ring-opacity'
	                    }),
	                    '--tw-ring-opacity': theme('ringOpacity', '', '0.5')
	                }
	            }),
	            '--tw-ring-offset-shadow': "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)",
	            '--tw-ring-shadow': `var(--tw-ring-inset) 0 0 0 calc(${_} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
	            boxShadow: "var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)"
	        })),
	    /* EFFECTS */ // Box Shadow Color
	    matchColor('shadow-', {
	        section: 'boxShadowColor',
	        opacityVariable: false,
	        opacitySection: 'opacity'
	    }, ({ _  })=>({
	            '--tw-shadow-color': _.value,
	            '--tw-shadow': 'var(--tw-shadow-colored)'
	        })),
	    // Box Shadow
	    matchTheme('shadow(?:$|-)', 'boxShadow', ({ _  })=>({
	            ...asDefaults({
	                '--tw-ring-offset-shadow': '0 0 #0000',
	                '--tw-ring-shadow': '0 0 #0000',
	                '--tw-shadow': '0 0 #0000',
	                '--tw-shadow-colored': '0 0 #0000'
	            }),
	            '--tw-shadow': join(_),
	            // replace all colors with reference to --tw-shadow-colored
	            // this matches colors after non-comma char (keyword, offset) before comma or the end
	            '--tw-shadow-colored': join(_).replace(/([^,]\s+)(?:#[a-f\d]+|(?:(?:hsl|rgb)a?|hwb|lab|lch|color|var)\(.+?\)|[a-z]+)(,|$)/g, '$1var(--tw-shadow-color)$2'),
	            boxShadow: "var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)"
	        })),
	    // Opacity
	    matchTheme('(opacity)-'),
	    /*, 'opacity' */ // Mix Blend Mode
	    match('mix-blend-', 'mixBlendMode'),
	    /* FILTERS */ ...filter(),
	    ...filter('backdrop-'),
	    /* TRANSITIONS AND ANIMATION */ // Transition Property
	    matchTheme('transition(?:$|-)', 'transitionProperty', (match, { theme  })=>({
	            transitionProperty: join(match),
	            transitionTimingFunction: 'none' == match._ ? void 0 : join(theme('transitionTimingFunction', '')),
	            transitionDuration: 'none' == match._ ? void 0 : join(theme('transitionDuration', ''))
	        })),
	    // Transition Duration
	    matchTheme('duration(?:$|-)', 'transitionDuration', 'transitionDuration', join),
	    // Transition Timing Function
	    matchTheme('ease(?:$|-)', 'transitionTimingFunction', 'transitionTimingFunction', join),
	    // Transition Delay
	    matchTheme('delay(?:$|-)', 'transitionDelay', 'transitionDelay', join),
	    matchTheme('animate(?:$|-)', 'animation', (match, { theme , h , e  })=>{
	        let animation = join(match), // Try to auto inject keyframes
	        parts = animation.split(' '), keyframeValues = theme('keyframes', parts[0]);
	        return keyframeValues ? {
	            ['@keyframes ' + (parts[0] = e(h(parts[0])))]: keyframeValues,
	            animation: parts.join(' ')
	        } : {
	            animation
	        };
	    }),
	    /* TRANSFORMS */ // Transform
	    '(transform)-(none)',
	    match('transform', tranformDefaults),
	    match('transform-(cpu|gpu)', ({ 1: $1  })=>({
	            '--tw-transform': transformValue('gpu' == $1)
	        })),
	    // Scale
	    matchTheme('scale(-[xy])?-', 'scale', ({ 1: $1 , _  })=>({
	            ['--tw-scale' + ($1 || '-x')]: _,
	            ['--tw-scale' + ($1 || '-y')]: _,
	            ...tranformDefaults()
	        })),
	    // Rotate
	    matchTheme('-?(rotate)-', 'rotate', transform),
	    // Translate
	    matchTheme('-?(translate-[xy])-', 'translate', transform),
	    // Skew
	    matchTheme('-?(skew-[xy])-', 'skew', transform),
	    // Transform Origin
	    match('origin-(center|((top|bottom)(-(left|right))?)|left|right)', 'transformOrigin', spacify),
	    /* INTERACTIVITY */ // Appearance
	    '(appearance)-',
	    // Columns
	    matchTheme('(columns)-'),
	    /*, 'columns' */ '(columns)-(\\d+)',
	    // Break Before, After and Inside
	    '(break-(?:before|after|inside))-',
	    // Cursor
	    matchTheme('(cursor)-'),
	    /*, 'cursor' */ '(cursor)-',
	    // Scroll Snap Type
	    match('snap-(none)', 'scroll-snap-type'),
	    match('snap-(x|y|both)', ({ 1: $1  })=>({
	            ...asDefaults({
	                '--tw-scroll-snap-strictness': 'proximity'
	            }),
	            'scroll-snap-type': $1 + ' var(--tw-scroll-snap-strictness)'
	        })),
	    match('snap-(mandatory|proximity)', '--tw-scroll-snap-strictness'),
	    // Scroll Snap Align
	    match('snap-(?:(start|end|center)|align-(none))', 'scroll-snap-align'),
	    // Scroll Snap Stop
	    match('snap-(normal|always)', 'scroll-snap-stop'),
	    match('scroll-(auto|smooth)', 'scroll-behavior'),
	    // Scroll Margin
	    // Padding
	    matchTheme('scroll-p([xytrbl])?(?:$|-)', 'padding', edge('scroll-padding')),
	    // Margin
	    matchTheme('-?scroll-m([xytrbl])?(?:$|-)', 'scroll-margin', edge('scroll-margin')),
	    // Touch Action
	    match('touch-(auto|none|manipulation)', 'touch-action'),
	    match('touch-(pinch-zoom|pan-(?:(x|left|right)|(y|up|down)))', ({ 1: $1 , 2: $2 , 3: $3  })=>({
	            ...asDefaults({
	                '--tw-pan-x': 'var(--tw-empty,/*!*/ /*!*/)',
	                '--tw-pan-y': 'var(--tw-empty,/*!*/ /*!*/)',
	                '--tw-pinch-zoom': 'var(--tw-empty,/*!*/ /*!*/)',
	                '--tw-touch-action': 'var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)'
	            }),
	            // x, left, right -> pan-x
	            // y, up, down -> pan-y
	            // -> pinch-zoom
	            [`--tw-${$2 ? 'pan-x' : $3 ? 'pan-y' : $1}`]: $1,
	            'touch-action': 'var(--tw-touch-action)'
	        })),
	    // Outline Style
	    match('outline-none', {
	        outline: '2px solid transparent',
	        'outline-offset': '2px'
	    }),
	    match('outline', {
	        outlineStyle: 'solid'
	    }),
	    match('outline-(dashed|dotted|double)', 'outlineStyle'),
	    // Outline Offset
	    matchTheme('-?(outline-offset)-'),
	    /*, 'outlineOffset'*/ // Outline Color
	    matchColor('outline-', {
	        opacityVariable: false,
	        opacitySection: 'opacity'
	    }),
	    // Outline Width
	    matchTheme('outline-', 'outlineWidth'),
	    // Pointer Events
	    '(pointer-events)-',
	    // Will Change
	    matchTheme('(will-change)-'),
	    /*, 'willChange' */ '(will-change)-',
	    // Resize
	    [
	        'resize(?:-(none|x|y))?',
	        'resize',
	        ({ 1: $1  })=>({
	                x: 'horizontal',
	                y: 'vertical'
	            })[$1] || $1 || 'both'
	    ],
	    // User Select
	    match('select-(none|text|all|auto)', 'userSelect'),
	    /* SVG */ // Fill, Stroke
	    matchColor('fill-', {
	        section: 'fill',
	        opacityVariable: false,
	        opacitySection: 'opacity'
	    }),
	    matchColor('stroke-', {
	        section: 'stroke',
	        opacityVariable: false,
	        opacitySection: 'opacity'
	    }),
	    // Stroke Width
	    matchTheme('stroke-', 'strokeWidth'),
	    /* ACCESSIBILITY */ // Screen Readers
	    match('sr-only', {
	        position: 'absolute',
	        width: '1px',
	        height: '1px',
	        padding: '0',
	        margin: '-1px',
	        overflow: 'hidden',
	        whiteSpace: 'nowrap',
	        clip: 'rect(0,0,0,0)',
	        borderWidth: '0'
	    }),
	    match('not-sr-only', {
	        position: 'static',
	        width: 'auto',
	        height: 'auto',
	        padding: '0',
	        margin: '0',
	        overflow: 'visible',
	        whiteSpace: 'normal',
	        clip: 'auto'
	    })
	];
	function spacify(value) {
	    return ('string' == typeof value ? value : value[1]).replace(/-/g, ' ').trim();
	}
	function columnify(value) {
	    return ('string' == typeof value ? value : value[1]).replace('col', 'column');
	}
	function position(shorthand, separator = '-') {
	    let longhand = [];
	    for (let short of shorthand)longhand.push({
	        t: 'top',
	        r: 'right',
	        b: 'bottom',
	        l: 'left'
	    }[short]);
	    return longhand.join(separator);
	}
	function join(value) {
	    return value && '' + (value._ || value);
	}
	function convertContentValue({ $$  }) {
	    return (({
	        // /* aut*/ o: '',
	        /* sta*/ r: /*t*/ 'flex-',
	        /* end*/ '': 'flex-',
	        // /* cen*/ t /*er*/: '',
	        /* bet*/ w: /*een*/ 'space-',
	        /* aro*/ u: /*nd*/ 'space-',
	        /* eve*/ n: /*ly*/ 'space-'
	    })[$$[3] || ''] || '') + $$;
	}
	function edge(propertyPrefix, propertySuffix = '') {
	    return ({ 1: $1 , _  })=>{
	        let edges = {
	            x: 'lr',
	            y: 'tb'
	        }[$1] || $1 + $1;
	        return edges ? {
	            ...toCSS(propertyPrefix + '-' + position(edges[0]) + propertySuffix, _),
	            ...toCSS(propertyPrefix + '-' + position(edges[1]) + propertySuffix, _)
	        } : toCSS(propertyPrefix + propertySuffix, _);
	    };
	}
	function filter(prefix = '') {
	    let filters = [
	        'blur',
	        'brightness',
	        'contrast',
	        'grayscale',
	        'hue-rotate',
	        'invert',
	        prefix && 'opacity',
	        'saturate',
	        'sepia',
	        !prefix && 'drop-shadow'
	    ].filter(Boolean), defaults = {};
	    // first create properties defaults
	    for (let key of filters)defaults[`--tw-${prefix}${key}`] = 'var(--tw-empty,/*!*/ /*!*/)';
	    return defaults = {
	        // move defaults
	        ...asDefaults(defaults),
	        // add default filter which allows standalone usage
	        [`${prefix}filter`]: filters.map((key)=>`var(--tw-${prefix}${key})`).join(' ')
	    }, [
	        `(${prefix}filter)-(none)`,
	        match(`${prefix}filter`, defaults),
	        ...filters.map((key)=>matchTheme(// hue-rotate can be negated
	            `${'h' == key[0] ? '-?' : ''}(${prefix}${key})(?:$|-)`, key, ({ 1: $1 , _  })=>({
	                    [`--tw-${$1}`]: asArray(_).map((value)=>`${key}(${value})`).join(' '),
	                    ...defaults
	                })))
	    ];
	}
	function transform({ 1: $1 , _  }) {
	    return {
	        ['--tw-' + $1]: _,
	        ...tranformDefaults()
	    };
	}
	function tranformDefaults() {
	    return {
	        ...asDefaults({
	            '--tw-translate-x': '0',
	            '--tw-translate-y': '0',
	            '--tw-rotate': '0',
	            '--tw-skew-x': '0',
	            '--tw-skew-y': '0',
	            '--tw-scale-x': '1',
	            '--tw-scale-y': '1',
	            '--tw-transform': transformValue()
	        }),
	        transform: 'var(--tw-transform)'
	    };
	}
	function transformValue(gpu) {
	    return [
	        gpu ? // -gpu
	        'translate3d(var(--tw-translate-x),var(--tw-translate-y),0)' : 'translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y))',
	        'rotate(var(--tw-rotate))',
	        'skewX(var(--tw-skew-x))',
	        'skewY(var(--tw-skew-y))',
	        'scaleX(var(--tw-scale-x))',
	        'scaleY(var(--tw-scale-y))'
	    ].join(' ');
	}
	function span({ 1: $1 , 2: $2  }) {
	    return `${$1} ${$2} / ${$1} ${$2}`;
	}
	function gridTemplate({ 1: $1  }) {
	    return `repeat(${$1},minmax(0,1fr))`;
	}
	function asDefaults(props) {
	    return {
	        '@layer defaults': {
	            '*,::before,::after': props,
	            '::backdrop': props
	        }
	    };
	}

	// indirection wrapper to remove autocomplete functions from production bundles
	let variants = [
	    [
	        'sticky',
	        '@supports ((position: -webkit-sticky) or (position:sticky))'
	    ],
	    [
	        'motion-reduce',
	        '@media (prefers-reduced-motion:reduce)'
	    ],
	    [
	        'motion-safe',
	        '@media (prefers-reduced-motion:no-preference)'
	    ],
	    [
	        'print',
	        '@media print'
	    ],
	    [
	        '(portrait|landscape)',
	        ({ 1: $1  })=>`@media (orientation:${$1})`
	    ],
	    [
	        'contrast-(more|less)',
	        ({ 1: $1  })=>`@media (prefers-contrast:${$1})`
	    ],
	    [
	        '(first-(letter|line)|placeholder|backdrop|before|after)',
	        ({ 1: $1  })=>`&::${$1}`
	    ],
	    [
	        '(marker|selection)',
	        ({ 1: $1  })=>`& *::${$1},&::${$1}`
	    ],
	    [
	        'file',
	        '&::file-selector-button'
	    ],
	    [
	        '(first|last|only)',
	        ({ 1: $1  })=>`&:${$1}-child`
	    ],
	    [
	        'even',
	        '&:nth-child(2n)'
	    ],
	    [
	        'odd',
	        '&:nth-child(odd)'
	    ],
	    [
	        'open',
	        '&[open]'
	    ],
	    // All other pseudo classes are already supported by twind
	    [
	        '(aria|data)-',
	        ({ 1: $1 , /* aria or data */ $$  }, /* everything after the dash */ context)=>$$ && `&[${$1}-${// aria-asc or data-checked -> from theme
            context.theme($1, $$) || // aria-[...] or data-[...]
            arbitrary($$, '', context) || // default handling
            `${$$}="true"`}]`
	    ],
	    /* Styling based on parent and peer state */ // Groups classes like: group-focus and group-hover
	    // these need to add a marker selector with the pseudo class
	    // => '.group:focus .group-focus:selector'
	    [
	        '((group|peer)(~[^-[]+)?)(-\\[(.+)]|[-[].+?)(\\/.+)?',
	        ({ 2: type , 3: name = '' , 4: $4 , 5: $5 = '' , 6: label = name  }, { e , h , v  })=>{
	            let selector = normalize($5) || ('[' == $4[0] ? $4 : v($4.slice(1)));
	            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	            return `${(selector.includes('&') ? selector : '&' + selector).replace(/&/g, `:merge(.${e(h(type + label))})`)}${'p' == type[0] ? '~' : ' '}&`;
	        }
	    ],
	    // direction variants
	    [
	        '(ltr|rtl)',
	        ({ 1: $1  })=>`[dir="${$1}"] &`
	    ],
	    [
	        'supports-',
	        ({ $$  }, /* everything after the dash */ context)=>{
	            $$ && ($$ = context.theme('supports', $$) || arbitrary($$, '', context));
	            if ($$) return $$.includes(':') || ($$ += ':var(--tw)'), /^\w*\s*\(/.test($$) || ($$ = `(${$$})`), // Chrome has a bug where `(condtion1)or(condition2)` is not valid
	            // But `(condition1) or (condition2)` is supported.
	            `@supports ${$$.replace(/\b(and|or|not)\b/g, ' $1 ').trim()}`;
	        }
	    ],
	    [
	        'max-',
	        ({ $$  }, context)=>{
	            $$ && ($$ = context.theme('screens', $$) || arbitrary($$, '', context));
	            if ('string' == typeof $$) return `@media not all and (min-width:${$$})`;
	        }
	    ],
	    [
	        'min-',
	        ({ $$  }, context)=>{
	            return $$ && ($$ = arbitrary($$, '', context)), $$ && `@media (min-width:${$$})`;
	        }
	    ],
	    // Arbitrary variants
	    [
	        /^\[(.+)]$/,
	        ({ 1: $1  })=>/[&@]/.test($1) && normalize($1).replace(/[}]+$/, '').split('{')
	    ]
	];

	/** Allows to disable to tailwind preflight (default: `false` eg include the tailwind preflight ) */ /**
	 * @experimental
	 */ function presetTailwindBase({ colors , disablePreflight  } = {}) {
	    return {
	        // allow other preflight to run
	        preflight: disablePreflight ? void 0 : preflight,
	        theme: {
	            ...theme,
	            colors: {
	                inherit: 'inherit',
	                current: 'currentColor',
	                transparent: 'transparent',
	                black: '#000',
	                white: '#fff',
	                ...colors
	            }
	        },
	        variants,
	        rules,
	        finalize (rule) {
	            return(// automatically add `content: ''` to before and after so you don’t have to specify it unless you want a different value
	            // ignore global, preflight, and auto added rules
	            rule.n && // only if there are declarations
	            rule.d && // and it has a ::before or ::after selector
	            rule.r.some((r)=>/^&::(before|after)$/.test(r)) && // there is no content property yet
	            !/(^|;)content:/.test(rule.d) ? {
	                ...rule,
	                d: 'content:var(--tw-content);' + rule.d
	            } : rule);
	        }
	    };
	}

	// Source from https://github.com/tailwindlabs/tailwindcss/blob/master/src/public/colors.js
	/**
	 * @module @twind/preset-tailwind/colors
	 */ let slate = {
	    50: '#f8fafc',
	    100: '#f1f5f9',
	    200: '#e2e8f0',
	    300: '#cbd5e1',
	    400: '#94a3b8',
	    500: '#64748b',
	    600: '#475569',
	    700: '#334155',
	    800: '#1e293b',
	    900: '#0f172a'
	}, gray = {
	    50: '#f9fafb',
	    100: '#f3f4f6',
	    200: '#e5e7eb',
	    300: '#d1d5db',
	    400: '#9ca3af',
	    500: '#6b7280',
	    600: '#4b5563',
	    700: '#374151',
	    800: '#1f2937',
	    900: '#111827'
	}, zinc = {
	    50: '#fafafa',
	    100: '#f4f4f5',
	    200: '#e4e4e7',
	    300: '#d4d4d8',
	    400: '#a1a1aa',
	    500: '#71717a',
	    600: '#52525b',
	    700: '#3f3f46',
	    800: '#27272a',
	    900: '#18181b'
	}, neutral = {
	    50: '#fafafa',
	    100: '#f5f5f5',
	    200: '#e5e5e5',
	    300: '#d4d4d4',
	    400: '#a3a3a3',
	    500: '#737373',
	    600: '#525252',
	    700: '#404040',
	    800: '#262626',
	    900: '#171717'
	}, stone = {
	    50: '#fafaf9',
	    100: '#f5f5f4',
	    200: '#e7e5e4',
	    300: '#d6d3d1',
	    400: '#a8a29e',
	    500: '#78716c',
	    600: '#57534e',
	    700: '#44403c',
	    800: '#292524',
	    900: '#1c1917'
	}, red = {
	    50: '#fef2f2',
	    100: '#fee2e2',
	    200: '#fecaca',
	    300: '#fca5a5',
	    400: '#f87171',
	    500: '#ef4444',
	    600: '#dc2626',
	    700: '#b91c1c',
	    800: '#991b1b',
	    900: '#7f1d1d'
	}, orange = {
	    50: '#fff7ed',
	    100: '#ffedd5',
	    200: '#fed7aa',
	    300: '#fdba74',
	    400: '#fb923c',
	    500: '#f97316',
	    600: '#ea580c',
	    700: '#c2410c',
	    800: '#9a3412',
	    900: '#7c2d12'
	}, amber = {
	    50: '#fffbeb',
	    100: '#fef3c7',
	    200: '#fde68a',
	    300: '#fcd34d',
	    400: '#fbbf24',
	    500: '#f59e0b',
	    600: '#d97706',
	    700: '#b45309',
	    800: '#92400e',
	    900: '#78350f'
	}, yellow = {
	    50: '#fefce8',
	    100: '#fef9c3',
	    200: '#fef08a',
	    300: '#fde047',
	    400: '#facc15',
	    500: '#eab308',
	    600: '#ca8a04',
	    700: '#a16207',
	    800: '#854d0e',
	    900: '#713f12'
	}, lime = {
	    50: '#f7fee7',
	    100: '#ecfccb',
	    200: '#d9f99d',
	    300: '#bef264',
	    400: '#a3e635',
	    500: '#84cc16',
	    600: '#65a30d',
	    700: '#4d7c0f',
	    800: '#3f6212',
	    900: '#365314'
	}, green = {
	    50: '#f0fdf4',
	    100: '#dcfce7',
	    200: '#bbf7d0',
	    300: '#86efac',
	    400: '#4ade80',
	    500: '#22c55e',
	    600: '#16a34a',
	    700: '#15803d',
	    800: '#166534',
	    900: '#14532d'
	}, emerald = {
	    50: '#ecfdf5',
	    100: '#d1fae5',
	    200: '#a7f3d0',
	    300: '#6ee7b7',
	    400: '#34d399',
	    500: '#10b981',
	    600: '#059669',
	    700: '#047857',
	    800: '#065f46',
	    900: '#064e3b'
	}, teal = {
	    50: '#f0fdfa',
	    100: '#ccfbf1',
	    200: '#99f6e4',
	    300: '#5eead4',
	    400: '#2dd4bf',
	    500: '#14b8a6',
	    600: '#0d9488',
	    700: '#0f766e',
	    800: '#115e59',
	    900: '#134e4a'
	}, cyan = {
	    50: '#ecfeff',
	    100: '#cffafe',
	    200: '#a5f3fc',
	    300: '#67e8f9',
	    400: '#22d3ee',
	    500: '#06b6d4',
	    600: '#0891b2',
	    700: '#0e7490',
	    800: '#155e75',
	    900: '#164e63'
	}, sky = {
	    50: '#f0f9ff',
	    100: '#e0f2fe',
	    200: '#bae6fd',
	    300: '#7dd3fc',
	    400: '#38bdf8',
	    500: '#0ea5e9',
	    600: '#0284c7',
	    700: '#0369a1',
	    800: '#075985',
	    900: '#0c4a6e'
	}, blue = {
	    50: '#eff6ff',
	    100: '#dbeafe',
	    200: '#bfdbfe',
	    300: '#93c5fd',
	    400: '#60a5fa',
	    500: '#3b82f6',
	    600: '#2563eb',
	    700: '#1d4ed8',
	    800: '#1e40af',
	    900: '#1e3a8a'
	}, indigo = {
	    50: '#eef2ff',
	    100: '#e0e7ff',
	    200: '#c7d2fe',
	    300: '#a5b4fc',
	    400: '#818cf8',
	    500: '#6366f1',
	    600: '#4f46e5',
	    700: '#4338ca',
	    800: '#3730a3',
	    900: '#312e81'
	}, violet = {
	    50: '#f5f3ff',
	    100: '#ede9fe',
	    200: '#ddd6fe',
	    300: '#c4b5fd',
	    400: '#a78bfa',
	    500: '#8b5cf6',
	    600: '#7c3aed',
	    700: '#6d28d9',
	    800: '#5b21b6',
	    900: '#4c1d95'
	}, purple = {
	    50: '#faf5ff',
	    100: '#f3e8ff',
	    200: '#e9d5ff',
	    300: '#d8b4fe',
	    400: '#c084fc',
	    500: '#a855f7',
	    600: '#9333ea',
	    700: '#7e22ce',
	    800: '#6b21a8',
	    900: '#581c87'
	}, fuchsia = {
	    50: '#fdf4ff',
	    100: '#fae8ff',
	    200: '#f5d0fe',
	    300: '#f0abfc',
	    400: '#e879f9',
	    500: '#d946ef',
	    600: '#c026d3',
	    700: '#a21caf',
	    800: '#86198f',
	    900: '#701a75'
	}, pink = {
	    50: '#fdf2f8',
	    100: '#fce7f3',
	    200: '#fbcfe8',
	    300: '#f9a8d4',
	    400: '#f472b6',
	    500: '#ec4899',
	    600: '#db2777',
	    700: '#be185d',
	    800: '#9d174d',
	    900: '#831843'
	}, rose = {
	    50: '#fff1f2',
	    100: '#ffe4e6',
	    200: '#fecdd3',
	    300: '#fda4af',
	    400: '#fb7185',
	    500: '#f43f5e',
	    600: '#e11d48',
	    700: '#be123c',
	    800: '#9f1239',
	    900: '#881337'
	}, // get lightBlue() {
	//   warn({ version: 'v2.2', from: 'lightBlue', to: 'sky' })
	//   return this.sky
	// }
	// get warmGray() {
	//   warn({ version: 'v3.0', from: 'warmGray', to: 'stone' })
	//   return this.stone
	// }
	// get trueGray() {
	//   warn({ version: 'v3.0', from: 'trueGray', to: 'neutral' })
	//   return this.neutral
	// }
	// get coolGray() {
	//   warn({ version: 'v3.0', from: 'coolGray', to: 'gray' })
	//   return this.gray
	// }
	// get blueGray() {
	//   warn({ version: 'v3.0', from: 'blueGray', to: 'slate' })
	//   return this.slate
	// }
	colors = {
	    __proto__: null,
	    slate,
	    gray,
	    zinc,
	    neutral,
	    stone,
	    red,
	    orange,
	    amber,
	    yellow,
	    lime,
	    green,
	    emerald,
	    teal,
	    cyan,
	    sky,
	    blue,
	    indigo,
	    violet,
	    purple,
	    fuchsia,
	    pink,
	    rose
	};

	/** Allows to disable to tailwind preflight (default: `false` eg include the tailwind preflight ) */ function presetTailwind({ disablePreflight  } = {}) {
	    return presetTailwindBase({
	        colors,
	        disablePreflight
	    });
	}

	var defaultTheme$1 = {};

	var cloneDeep = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		Object.defineProperty(exports, "cloneDeep", {
		    enumerable: true,
		    get: function() {
		        return cloneDeep;
		    }
		});
		function cloneDeep(value) {
		    if (Array.isArray(value)) {
		        return value.map((child)=>cloneDeep(child));
		    }
		    if (typeof value === "object" && value !== null) {
		        return Object.fromEntries(Object.entries(value).map(([k, v])=>[
		                k,
		                cloneDeep(v)
		            ]));
		    }
		    return value;
		} 
	} (cloneDeep));

	var config_full = {
	  content: [],
	  presets: [],
	  darkMode: 'media', // or 'class'
	  theme: {
	    accentColor: ({ theme }) => ({
	      ...theme('colors'),
	      auto: 'auto',
	    }),
	    animation: {
	      none: 'none',
	      spin: 'spin 1s linear infinite',
	      ping: 'ping 1s cubic-bezier(0, 0, 0.2, 1) infinite',
	      pulse: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
	      bounce: 'bounce 1s infinite',
	    },
	    aria: {
	      busy: 'busy="true"',
	      checked: 'checked="true"',
	      disabled: 'disabled="true"',
	      expanded: 'expanded="true"',
	      hidden: 'hidden="true"',
	      pressed: 'pressed="true"',
	      readonly: 'readonly="true"',
	      required: 'required="true"',
	      selected: 'selected="true"',
	    },
	    aspectRatio: {
	      auto: 'auto',
	      square: '1 / 1',
	      video: '16 / 9',
	    },
	    backdropBlur: ({ theme }) => theme('blur'),
	    backdropBrightness: ({ theme }) => theme('brightness'),
	    backdropContrast: ({ theme }) => theme('contrast'),
	    backdropGrayscale: ({ theme }) => theme('grayscale'),
	    backdropHueRotate: ({ theme }) => theme('hueRotate'),
	    backdropInvert: ({ theme }) => theme('invert'),
	    backdropOpacity: ({ theme }) => theme('opacity'),
	    backdropSaturate: ({ theme }) => theme('saturate'),
	    backdropSepia: ({ theme }) => theme('sepia'),
	    backgroundColor: ({ theme }) => theme('colors'),
	    backgroundImage: {
	      none: 'none',
	      'gradient-to-t': 'linear-gradient(to top, var(--tw-gradient-stops))',
	      'gradient-to-tr': 'linear-gradient(to top right, var(--tw-gradient-stops))',
	      'gradient-to-r': 'linear-gradient(to right, var(--tw-gradient-stops))',
	      'gradient-to-br': 'linear-gradient(to bottom right, var(--tw-gradient-stops))',
	      'gradient-to-b': 'linear-gradient(to bottom, var(--tw-gradient-stops))',
	      'gradient-to-bl': 'linear-gradient(to bottom left, var(--tw-gradient-stops))',
	      'gradient-to-l': 'linear-gradient(to left, var(--tw-gradient-stops))',
	      'gradient-to-tl': 'linear-gradient(to top left, var(--tw-gradient-stops))',
	    },
	    backgroundOpacity: ({ theme }) => theme('opacity'),
	    backgroundPosition: {
	      bottom: 'bottom',
	      center: 'center',
	      left: 'left',
	      'left-bottom': 'left bottom',
	      'left-top': 'left top',
	      right: 'right',
	      'right-bottom': 'right bottom',
	      'right-top': 'right top',
	      top: 'top',
	    },
	    backgroundSize: {
	      auto: 'auto',
	      cover: 'cover',
	      contain: 'contain',
	    },
	    blur: {
	      0: '0',
	      none: '0',
	      sm: '4px',
	      DEFAULT: '8px',
	      md: '12px',
	      lg: '16px',
	      xl: '24px',
	      '2xl': '40px',
	      '3xl': '64px',
	    },
	    borderColor: ({ theme }) => ({
	      ...theme('colors'),
	      DEFAULT: theme('colors.gray.200', 'currentColor'),
	    }),
	    borderOpacity: ({ theme }) => theme('opacity'),
	    borderRadius: {
	      none: '0px',
	      sm: '0.125rem',
	      DEFAULT: '0.25rem',
	      md: '0.375rem',
	      lg: '0.5rem',
	      xl: '0.75rem',
	      '2xl': '1rem',
	      '3xl': '1.5rem',
	      full: '9999px',
	    },
	    borderSpacing: ({ theme }) => ({
	      ...theme('spacing'),
	    }),
	    borderWidth: {
	      DEFAULT: '1px',
	      0: '0px',
	      2: '2px',
	      4: '4px',
	      8: '8px',
	    },
	    boxShadow: {
	      sm: '0 1px 2px 0 rgb(0 0 0 / 0.05)',
	      DEFAULT: '0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)',
	      md: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
	      lg: '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)',
	      xl: '0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)',
	      '2xl': '0 25px 50px -12px rgb(0 0 0 / 0.25)',
	      inner: 'inset 0 2px 4px 0 rgb(0 0 0 / 0.05)',
	      none: 'none',
	    },
	    boxShadowColor: ({ theme }) => theme('colors'),
	    brightness: {
	      0: '0',
	      50: '.5',
	      75: '.75',
	      90: '.9',
	      95: '.95',
	      100: '1',
	      105: '1.05',
	      110: '1.1',
	      125: '1.25',
	      150: '1.5',
	      200: '2',
	    },
	    caretColor: ({ theme }) => theme('colors'),
	    colors: ({ colors }) => ({
	      inherit: colors.inherit,
	      current: colors.current,
	      transparent: colors.transparent,
	      black: colors.black,
	      white: colors.white,
	      slate: colors.slate,
	      gray: colors.gray,
	      zinc: colors.zinc,
	      neutral: colors.neutral,
	      stone: colors.stone,
	      red: colors.red,
	      orange: colors.orange,
	      amber: colors.amber,
	      yellow: colors.yellow,
	      lime: colors.lime,
	      green: colors.green,
	      emerald: colors.emerald,
	      teal: colors.teal,
	      cyan: colors.cyan,
	      sky: colors.sky,
	      blue: colors.blue,
	      indigo: colors.indigo,
	      violet: colors.violet,
	      purple: colors.purple,
	      fuchsia: colors.fuchsia,
	      pink: colors.pink,
	      rose: colors.rose,
	    }),
	    columns: {
	      auto: 'auto',
	      1: '1',
	      2: '2',
	      3: '3',
	      4: '4',
	      5: '5',
	      6: '6',
	      7: '7',
	      8: '8',
	      9: '9',
	      10: '10',
	      11: '11',
	      12: '12',
	      '3xs': '16rem',
	      '2xs': '18rem',
	      xs: '20rem',
	      sm: '24rem',
	      md: '28rem',
	      lg: '32rem',
	      xl: '36rem',
	      '2xl': '42rem',
	      '3xl': '48rem',
	      '4xl': '56rem',
	      '5xl': '64rem',
	      '6xl': '72rem',
	      '7xl': '80rem',
	    },
	    container: {},
	    content: {
	      none: 'none',
	    },
	    contrast: {
	      0: '0',
	      50: '.5',
	      75: '.75',
	      100: '1',
	      125: '1.25',
	      150: '1.5',
	      200: '2',
	    },
	    cursor: {
	      auto: 'auto',
	      default: 'default',
	      pointer: 'pointer',
	      wait: 'wait',
	      text: 'text',
	      move: 'move',
	      help: 'help',
	      'not-allowed': 'not-allowed',
	      none: 'none',
	      'context-menu': 'context-menu',
	      progress: 'progress',
	      cell: 'cell',
	      crosshair: 'crosshair',
	      'vertical-text': 'vertical-text',
	      alias: 'alias',
	      copy: 'copy',
	      'no-drop': 'no-drop',
	      grab: 'grab',
	      grabbing: 'grabbing',
	      'all-scroll': 'all-scroll',
	      'col-resize': 'col-resize',
	      'row-resize': 'row-resize',
	      'n-resize': 'n-resize',
	      'e-resize': 'e-resize',
	      's-resize': 's-resize',
	      'w-resize': 'w-resize',
	      'ne-resize': 'ne-resize',
	      'nw-resize': 'nw-resize',
	      'se-resize': 'se-resize',
	      'sw-resize': 'sw-resize',
	      'ew-resize': 'ew-resize',
	      'ns-resize': 'ns-resize',
	      'nesw-resize': 'nesw-resize',
	      'nwse-resize': 'nwse-resize',
	      'zoom-in': 'zoom-in',
	      'zoom-out': 'zoom-out',
	    },
	    divideColor: ({ theme }) => theme('borderColor'),
	    divideOpacity: ({ theme }) => theme('borderOpacity'),
	    divideWidth: ({ theme }) => theme('borderWidth'),
	    dropShadow: {
	      sm: '0 1px 1px rgb(0 0 0 / 0.05)',
	      DEFAULT: ['0 1px 2px rgb(0 0 0 / 0.1)', '0 1px 1px rgb(0 0 0 / 0.06)'],
	      md: ['0 4px 3px rgb(0 0 0 / 0.07)', '0 2px 2px rgb(0 0 0 / 0.06)'],
	      lg: ['0 10px 8px rgb(0 0 0 / 0.04)', '0 4px 3px rgb(0 0 0 / 0.1)'],
	      xl: ['0 20px 13px rgb(0 0 0 / 0.03)', '0 8px 5px rgb(0 0 0 / 0.08)'],
	      '2xl': '0 25px 25px rgb(0 0 0 / 0.15)',
	      none: '0 0 #0000',
	    },
	    fill: ({ theme }) => ({
	      none: 'none',
	      ...theme('colors'),
	    }),
	    flex: {
	      1: '1 1 0%',
	      auto: '1 1 auto',
	      initial: '0 1 auto',
	      none: 'none',
	    },
	    flexBasis: ({ theme }) => ({
	      auto: 'auto',
	      ...theme('spacing'),
	      '1/2': '50%',
	      '1/3': '33.333333%',
	      '2/3': '66.666667%',
	      '1/4': '25%',
	      '2/4': '50%',
	      '3/4': '75%',
	      '1/5': '20%',
	      '2/5': '40%',
	      '3/5': '60%',
	      '4/5': '80%',
	      '1/6': '16.666667%',
	      '2/6': '33.333333%',
	      '3/6': '50%',
	      '4/6': '66.666667%',
	      '5/6': '83.333333%',
	      '1/12': '8.333333%',
	      '2/12': '16.666667%',
	      '3/12': '25%',
	      '4/12': '33.333333%',
	      '5/12': '41.666667%',
	      '6/12': '50%',
	      '7/12': '58.333333%',
	      '8/12': '66.666667%',
	      '9/12': '75%',
	      '10/12': '83.333333%',
	      '11/12': '91.666667%',
	      full: '100%',
	    }),
	    flexGrow: {
	      0: '0',
	      DEFAULT: '1',
	    },
	    flexShrink: {
	      0: '0',
	      DEFAULT: '1',
	    },
	    fontFamily: {
	      sans: [
	        'ui-sans-serif',
	        'system-ui',
	        'sans-serif',
	        '"Apple Color Emoji"',
	        '"Segoe UI Emoji"',
	        '"Segoe UI Symbol"',
	        '"Noto Color Emoji"',
	      ],
	      serif: ['ui-serif', 'Georgia', 'Cambria', '"Times New Roman"', 'Times', 'serif'],
	      mono: [
	        'ui-monospace',
	        'SFMono-Regular',
	        'Menlo',
	        'Monaco',
	        'Consolas',
	        '"Liberation Mono"',
	        '"Courier New"',
	        'monospace',
	      ],
	    },
	    fontSize: {
	      xs: ['0.75rem', { lineHeight: '1rem' }],
	      sm: ['0.875rem', { lineHeight: '1.25rem' }],
	      base: ['1rem', { lineHeight: '1.5rem' }],
	      lg: ['1.125rem', { lineHeight: '1.75rem' }],
	      xl: ['1.25rem', { lineHeight: '1.75rem' }],
	      '2xl': ['1.5rem', { lineHeight: '2rem' }],
	      '3xl': ['1.875rem', { lineHeight: '2.25rem' }],
	      '4xl': ['2.25rem', { lineHeight: '2.5rem' }],
	      '5xl': ['3rem', { lineHeight: '1' }],
	      '6xl': ['3.75rem', { lineHeight: '1' }],
	      '7xl': ['4.5rem', { lineHeight: '1' }],
	      '8xl': ['6rem', { lineHeight: '1' }],
	      '9xl': ['8rem', { lineHeight: '1' }],
	    },
	    fontWeight: {
	      thin: '100',
	      extralight: '200',
	      light: '300',
	      normal: '400',
	      medium: '500',
	      semibold: '600',
	      bold: '700',
	      extrabold: '800',
	      black: '900',
	    },
	    gap: ({ theme }) => theme('spacing'),
	    gradientColorStops: ({ theme }) => theme('colors'),
	    gradientColorStopPositions: {
	      '0%': '0%',
	      '5%': '5%',
	      '10%': '10%',
	      '15%': '15%',
	      '20%': '20%',
	      '25%': '25%',
	      '30%': '30%',
	      '35%': '35%',
	      '40%': '40%',
	      '45%': '45%',
	      '50%': '50%',
	      '55%': '55%',
	      '60%': '60%',
	      '65%': '65%',
	      '70%': '70%',
	      '75%': '75%',
	      '80%': '80%',
	      '85%': '85%',
	      '90%': '90%',
	      '95%': '95%',
	      '100%': '100%',
	    },
	    grayscale: {
	      0: '0',
	      DEFAULT: '100%',
	    },
	    gridAutoColumns: {
	      auto: 'auto',
	      min: 'min-content',
	      max: 'max-content',
	      fr: 'minmax(0, 1fr)',
	    },
	    gridAutoRows: {
	      auto: 'auto',
	      min: 'min-content',
	      max: 'max-content',
	      fr: 'minmax(0, 1fr)',
	    },
	    gridColumn: {
	      auto: 'auto',
	      'span-1': 'span 1 / span 1',
	      'span-2': 'span 2 / span 2',
	      'span-3': 'span 3 / span 3',
	      'span-4': 'span 4 / span 4',
	      'span-5': 'span 5 / span 5',
	      'span-6': 'span 6 / span 6',
	      'span-7': 'span 7 / span 7',
	      'span-8': 'span 8 / span 8',
	      'span-9': 'span 9 / span 9',
	      'span-10': 'span 10 / span 10',
	      'span-11': 'span 11 / span 11',
	      'span-12': 'span 12 / span 12',
	      'span-full': '1 / -1',
	    },
	    gridColumnEnd: {
	      auto: 'auto',
	      1: '1',
	      2: '2',
	      3: '3',
	      4: '4',
	      5: '5',
	      6: '6',
	      7: '7',
	      8: '8',
	      9: '9',
	      10: '10',
	      11: '11',
	      12: '12',
	      13: '13',
	    },
	    gridColumnStart: {
	      auto: 'auto',
	      1: '1',
	      2: '2',
	      3: '3',
	      4: '4',
	      5: '5',
	      6: '6',
	      7: '7',
	      8: '8',
	      9: '9',
	      10: '10',
	      11: '11',
	      12: '12',
	      13: '13',
	    },
	    gridRow: {
	      auto: 'auto',
	      'span-1': 'span 1 / span 1',
	      'span-2': 'span 2 / span 2',
	      'span-3': 'span 3 / span 3',
	      'span-4': 'span 4 / span 4',
	      'span-5': 'span 5 / span 5',
	      'span-6': 'span 6 / span 6',
	      'span-7': 'span 7 / span 7',
	      'span-8': 'span 8 / span 8',
	      'span-9': 'span 9 / span 9',
	      'span-10': 'span 10 / span 10',
	      'span-11': 'span 11 / span 11',
	      'span-12': 'span 12 / span 12',
	      'span-full': '1 / -1',
	    },
	    gridRowEnd: {
	      auto: 'auto',
	      1: '1',
	      2: '2',
	      3: '3',
	      4: '4',
	      5: '5',
	      6: '6',
	      7: '7',
	      8: '8',
	      9: '9',
	      10: '10',
	      11: '11',
	      12: '12',
	      13: '13',
	    },
	    gridRowStart: {
	      auto: 'auto',
	      1: '1',
	      2: '2',
	      3: '3',
	      4: '4',
	      5: '5',
	      6: '6',
	      7: '7',
	      8: '8',
	      9: '9',
	      10: '10',
	      11: '11',
	      12: '12',
	      13: '13',
	    },
	    gridTemplateColumns: {
	      none: 'none',
	      subgrid: 'subgrid',
	      1: 'repeat(1, minmax(0, 1fr))',
	      2: 'repeat(2, minmax(0, 1fr))',
	      3: 'repeat(3, minmax(0, 1fr))',
	      4: 'repeat(4, minmax(0, 1fr))',
	      5: 'repeat(5, minmax(0, 1fr))',
	      6: 'repeat(6, minmax(0, 1fr))',
	      7: 'repeat(7, minmax(0, 1fr))',
	      8: 'repeat(8, minmax(0, 1fr))',
	      9: 'repeat(9, minmax(0, 1fr))',
	      10: 'repeat(10, minmax(0, 1fr))',
	      11: 'repeat(11, minmax(0, 1fr))',
	      12: 'repeat(12, minmax(0, 1fr))',
	    },
	    gridTemplateRows: {
	      none: 'none',
	      subgrid: 'subgrid',
	      1: 'repeat(1, minmax(0, 1fr))',
	      2: 'repeat(2, minmax(0, 1fr))',
	      3: 'repeat(3, minmax(0, 1fr))',
	      4: 'repeat(4, minmax(0, 1fr))',
	      5: 'repeat(5, minmax(0, 1fr))',
	      6: 'repeat(6, minmax(0, 1fr))',
	      7: 'repeat(7, minmax(0, 1fr))',
	      8: 'repeat(8, minmax(0, 1fr))',
	      9: 'repeat(9, minmax(0, 1fr))',
	      10: 'repeat(10, minmax(0, 1fr))',
	      11: 'repeat(11, minmax(0, 1fr))',
	      12: 'repeat(12, minmax(0, 1fr))',
	    },
	    height: ({ theme }) => ({
	      auto: 'auto',
	      ...theme('spacing'),
	      '1/2': '50%',
	      '1/3': '33.333333%',
	      '2/3': '66.666667%',
	      '1/4': '25%',
	      '2/4': '50%',
	      '3/4': '75%',
	      '1/5': '20%',
	      '2/5': '40%',
	      '3/5': '60%',
	      '4/5': '80%',
	      '1/6': '16.666667%',
	      '2/6': '33.333333%',
	      '3/6': '50%',
	      '4/6': '66.666667%',
	      '5/6': '83.333333%',
	      full: '100%',
	      screen: '100vh',
	      svh: '100svh',
	      lvh: '100lvh',
	      dvh: '100dvh',
	      min: 'min-content',
	      max: 'max-content',
	      fit: 'fit-content',
	    }),
	    hueRotate: {
	      0: '0deg',
	      15: '15deg',
	      30: '30deg',
	      60: '60deg',
	      90: '90deg',
	      180: '180deg',
	    },
	    inset: ({ theme }) => ({
	      auto: 'auto',
	      ...theme('spacing'),
	      '1/2': '50%',
	      '1/3': '33.333333%',
	      '2/3': '66.666667%',
	      '1/4': '25%',
	      '2/4': '50%',
	      '3/4': '75%',
	      full: '100%',
	    }),
	    invert: {
	      0: '0',
	      DEFAULT: '100%',
	    },
	    keyframes: {
	      spin: {
	        to: {
	          transform: 'rotate(360deg)',
	        },
	      },
	      ping: {
	        '75%, 100%': {
	          transform: 'scale(2)',
	          opacity: '0',
	        },
	      },
	      pulse: {
	        '50%': {
	          opacity: '.5',
	        },
	      },
	      bounce: {
	        '0%, 100%': {
	          transform: 'translateY(-25%)',
	          animationTimingFunction: 'cubic-bezier(0.8,0,1,1)',
	        },
	        '50%': {
	          transform: 'none',
	          animationTimingFunction: 'cubic-bezier(0,0,0.2,1)',
	        },
	      },
	    },
	    letterSpacing: {
	      tighter: '-0.05em',
	      tight: '-0.025em',
	      normal: '0em',
	      wide: '0.025em',
	      wider: '0.05em',
	      widest: '0.1em',
	    },
	    lineHeight: {
	      none: '1',
	      tight: '1.25',
	      snug: '1.375',
	      normal: '1.5',
	      relaxed: '1.625',
	      loose: '2',
	      3: '.75rem',
	      4: '1rem',
	      5: '1.25rem',
	      6: '1.5rem',
	      7: '1.75rem',
	      8: '2rem',
	      9: '2.25rem',
	      10: '2.5rem',
	    },
	    listStyleType: {
	      none: 'none',
	      disc: 'disc',
	      decimal: 'decimal',
	    },
	    listStyleImage: {
	      none: 'none',
	    },
	    margin: ({ theme }) => ({
	      auto: 'auto',
	      ...theme('spacing'),
	    }),
	    lineClamp: {
	      1: '1',
	      2: '2',
	      3: '3',
	      4: '4',
	      5: '5',
	      6: '6',
	    },
	    maxHeight: ({ theme }) => ({
	      ...theme('spacing'),
	      none: 'none',
	      full: '100%',
	      screen: '100vh',
	      svh: '100svh',
	      lvh: '100lvh',
	      dvh: '100dvh',
	      min: 'min-content',
	      max: 'max-content',
	      fit: 'fit-content',
	    }),
	    maxWidth: ({ theme, breakpoints }) => ({
	      ...theme('spacing'),
	      none: 'none',
	      xs: '20rem',
	      sm: '24rem',
	      md: '28rem',
	      lg: '32rem',
	      xl: '36rem',
	      '2xl': '42rem',
	      '3xl': '48rem',
	      '4xl': '56rem',
	      '5xl': '64rem',
	      '6xl': '72rem',
	      '7xl': '80rem',
	      full: '100%',
	      min: 'min-content',
	      max: 'max-content',
	      fit: 'fit-content',
	      prose: '65ch',
	      ...breakpoints(theme('screens')),
	    }),
	    minHeight: ({ theme }) => ({
	      ...theme('spacing'),
	      full: '100%',
	      screen: '100vh',
	      svh: '100svh',
	      lvh: '100lvh',
	      dvh: '100dvh',
	      min: 'min-content',
	      max: 'max-content',
	      fit: 'fit-content',
	    }),
	    minWidth: ({ theme }) => ({
	      ...theme('spacing'),
	      full: '100%',
	      min: 'min-content',
	      max: 'max-content',
	      fit: 'fit-content',
	    }),
	    objectPosition: {
	      bottom: 'bottom',
	      center: 'center',
	      left: 'left',
	      'left-bottom': 'left bottom',
	      'left-top': 'left top',
	      right: 'right',
	      'right-bottom': 'right bottom',
	      'right-top': 'right top',
	      top: 'top',
	    },
	    opacity: {
	      0: '0',
	      5: '0.05',
	      10: '0.1',
	      15: '0.15',
	      20: '0.2',
	      25: '0.25',
	      30: '0.3',
	      35: '0.35',
	      40: '0.4',
	      45: '0.45',
	      50: '0.5',
	      55: '0.55',
	      60: '0.6',
	      65: '0.65',
	      70: '0.7',
	      75: '0.75',
	      80: '0.8',
	      85: '0.85',
	      90: '0.9',
	      95: '0.95',
	      100: '1',
	    },
	    order: {
	      first: '-9999',
	      last: '9999',
	      none: '0',
	      1: '1',
	      2: '2',
	      3: '3',
	      4: '4',
	      5: '5',
	      6: '6',
	      7: '7',
	      8: '8',
	      9: '9',
	      10: '10',
	      11: '11',
	      12: '12',
	    },
	    outlineColor: ({ theme }) => theme('colors'),
	    outlineOffset: {
	      0: '0px',
	      1: '1px',
	      2: '2px',
	      4: '4px',
	      8: '8px',
	    },
	    outlineWidth: {
	      0: '0px',
	      1: '1px',
	      2: '2px',
	      4: '4px',
	      8: '8px',
	    },
	    padding: ({ theme }) => theme('spacing'),
	    placeholderColor: ({ theme }) => theme('colors'),
	    placeholderOpacity: ({ theme }) => theme('opacity'),
	    ringColor: ({ theme }) => ({
	      DEFAULT: theme('colors.blue.500', '#3b82f6'),
	      ...theme('colors'),
	    }),
	    ringOffsetColor: ({ theme }) => theme('colors'),
	    ringOffsetWidth: {
	      0: '0px',
	      1: '1px',
	      2: '2px',
	      4: '4px',
	      8: '8px',
	    },
	    ringOpacity: ({ theme }) => ({
	      DEFAULT: '0.5',
	      ...theme('opacity'),
	    }),
	    ringWidth: {
	      DEFAULT: '3px',
	      0: '0px',
	      1: '1px',
	      2: '2px',
	      4: '4px',
	      8: '8px',
	    },
	    rotate: {
	      0: '0deg',
	      1: '1deg',
	      2: '2deg',
	      3: '3deg',
	      6: '6deg',
	      12: '12deg',
	      45: '45deg',
	      90: '90deg',
	      180: '180deg',
	    },
	    saturate: {
	      0: '0',
	      50: '.5',
	      100: '1',
	      150: '1.5',
	      200: '2',
	    },
	    scale: {
	      0: '0',
	      50: '.5',
	      75: '.75',
	      90: '.9',
	      95: '.95',
	      100: '1',
	      105: '1.05',
	      110: '1.1',
	      125: '1.25',
	      150: '1.5',
	    },
	    screens: {
	      sm: '640px',
	      md: '768px',
	      lg: '1024px',
	      xl: '1280px',
	      '2xl': '1536px',
	    },
	    scrollMargin: ({ theme }) => ({
	      ...theme('spacing'),
	    }),
	    scrollPadding: ({ theme }) => theme('spacing'),
	    sepia: {
	      0: '0',
	      DEFAULT: '100%',
	    },
	    skew: {
	      0: '0deg',
	      1: '1deg',
	      2: '2deg',
	      3: '3deg',
	      6: '6deg',
	      12: '12deg',
	    },
	    space: ({ theme }) => ({
	      ...theme('spacing'),
	    }),
	    spacing: {
	      px: '1px',
	      0: '0px',
	      0.5: '0.125rem',
	      1: '0.25rem',
	      1.5: '0.375rem',
	      2: '0.5rem',
	      2.5: '0.625rem',
	      3: '0.75rem',
	      3.5: '0.875rem',
	      4: '1rem',
	      5: '1.25rem',
	      6: '1.5rem',
	      7: '1.75rem',
	      8: '2rem',
	      9: '2.25rem',
	      10: '2.5rem',
	      11: '2.75rem',
	      12: '3rem',
	      14: '3.5rem',
	      16: '4rem',
	      20: '5rem',
	      24: '6rem',
	      28: '7rem',
	      32: '8rem',
	      36: '9rem',
	      40: '10rem',
	      44: '11rem',
	      48: '12rem',
	      52: '13rem',
	      56: '14rem',
	      60: '15rem',
	      64: '16rem',
	      72: '18rem',
	      80: '20rem',
	      96: '24rem',
	    },
	    stroke: ({ theme }) => ({
	      none: 'none',
	      ...theme('colors'),
	    }),
	    strokeWidth: {
	      0: '0',
	      1: '1',
	      2: '2',
	    },
	    supports: {},
	    data: {},
	    textColor: ({ theme }) => theme('colors'),
	    textDecorationColor: ({ theme }) => theme('colors'),
	    textDecorationThickness: {
	      auto: 'auto',
	      'from-font': 'from-font',
	      0: '0px',
	      1: '1px',
	      2: '2px',
	      4: '4px',
	      8: '8px',
	    },
	    textIndent: ({ theme }) => ({
	      ...theme('spacing'),
	    }),
	    textOpacity: ({ theme }) => theme('opacity'),
	    textUnderlineOffset: {
	      auto: 'auto',
	      0: '0px',
	      1: '1px',
	      2: '2px',
	      4: '4px',
	      8: '8px',
	    },
	    transformOrigin: {
	      center: 'center',
	      top: 'top',
	      'top-right': 'top right',
	      right: 'right',
	      'bottom-right': 'bottom right',
	      bottom: 'bottom',
	      'bottom-left': 'bottom left',
	      left: 'left',
	      'top-left': 'top left',
	    },
	    transitionDelay: {
	      0: '0s',
	      75: '75ms',
	      100: '100ms',
	      150: '150ms',
	      200: '200ms',
	      300: '300ms',
	      500: '500ms',
	      700: '700ms',
	      1000: '1000ms',
	    },
	    transitionDuration: {
	      DEFAULT: '150ms',
	      0: '0s',
	      75: '75ms',
	      100: '100ms',
	      150: '150ms',
	      200: '200ms',
	      300: '300ms',
	      500: '500ms',
	      700: '700ms',
	      1000: '1000ms',
	    },
	    transitionProperty: {
	      none: 'none',
	      all: 'all',
	      DEFAULT:
	        'color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter',
	      colors: 'color, background-color, border-color, text-decoration-color, fill, stroke',
	      opacity: 'opacity',
	      shadow: 'box-shadow',
	      transform: 'transform',
	    },
	    transitionTimingFunction: {
	      DEFAULT: 'cubic-bezier(0.4, 0, 0.2, 1)',
	      linear: 'linear',
	      in: 'cubic-bezier(0.4, 0, 1, 1)',
	      out: 'cubic-bezier(0, 0, 0.2, 1)',
	      'in-out': 'cubic-bezier(0.4, 0, 0.2, 1)',
	    },
	    translate: ({ theme }) => ({
	      ...theme('spacing'),
	      '1/2': '50%',
	      '1/3': '33.333333%',
	      '2/3': '66.666667%',
	      '1/4': '25%',
	      '2/4': '50%',
	      '3/4': '75%',
	      full: '100%',
	    }),
	    size: ({ theme }) => ({
	      auto: 'auto',
	      ...theme('spacing'),
	      '1/2': '50%',
	      '1/3': '33.333333%',
	      '2/3': '66.666667%',
	      '1/4': '25%',
	      '2/4': '50%',
	      '3/4': '75%',
	      '1/5': '20%',
	      '2/5': '40%',
	      '3/5': '60%',
	      '4/5': '80%',
	      '1/6': '16.666667%',
	      '2/6': '33.333333%',
	      '3/6': '50%',
	      '4/6': '66.666667%',
	      '5/6': '83.333333%',
	      '1/12': '8.333333%',
	      '2/12': '16.666667%',
	      '3/12': '25%',
	      '4/12': '33.333333%',
	      '5/12': '41.666667%',
	      '6/12': '50%',
	      '7/12': '58.333333%',
	      '8/12': '66.666667%',
	      '9/12': '75%',
	      '10/12': '83.333333%',
	      '11/12': '91.666667%',
	      full: '100%',
	      min: 'min-content',
	      max: 'max-content',
	      fit: 'fit-content',
	    }),
	    width: ({ theme }) => ({
	      auto: 'auto',
	      ...theme('spacing'),
	      '1/2': '50%',
	      '1/3': '33.333333%',
	      '2/3': '66.666667%',
	      '1/4': '25%',
	      '2/4': '50%',
	      '3/4': '75%',
	      '1/5': '20%',
	      '2/5': '40%',
	      '3/5': '60%',
	      '4/5': '80%',
	      '1/6': '16.666667%',
	      '2/6': '33.333333%',
	      '3/6': '50%',
	      '4/6': '66.666667%',
	      '5/6': '83.333333%',
	      '1/12': '8.333333%',
	      '2/12': '16.666667%',
	      '3/12': '25%',
	      '4/12': '33.333333%',
	      '5/12': '41.666667%',
	      '6/12': '50%',
	      '7/12': '58.333333%',
	      '8/12': '66.666667%',
	      '9/12': '75%',
	      '10/12': '83.333333%',
	      '11/12': '91.666667%',
	      full: '100%',
	      screen: '100vw',
	      svw: '100svw',
	      lvw: '100lvw',
	      dvw: '100dvw',
	      min: 'min-content',
	      max: 'max-content',
	      fit: 'fit-content',
	    }),
	    willChange: {
	      auto: 'auto',
	      scroll: 'scroll-position',
	      contents: 'contents',
	      transform: 'transform',
	    },
	    zIndex: {
	      auto: 'auto',
	      0: '0',
	      10: '10',
	      20: '20',
	      30: '30',
	      40: '40',
	      50: '50',
	    },
	  },
	  plugins: [],
	};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		Object.defineProperty(exports, "default", {
		    enumerable: true,
		    get: function() {
		        return _default;
		    }
		});
		const _cloneDeep = cloneDeep;
		const _configfull = /*#__PURE__*/ _interop_require_default(config_full);
		function _interop_require_default(obj) {
		    return obj && obj.__esModule ? obj : {
		        default: obj
		    };
		}
		const _default = (0, _cloneDeep.cloneDeep)(_configfull.default.theme); 
	} (defaultTheme$1));

	let defaultTheme = defaultTheme$1;
	var defaultTheme_1 = (defaultTheme.__esModule ? defaultTheme : { default: defaultTheme }).default;

	const config$1 = {
	  darkMode: ["class"],
	  content: ["./src/**/*.{html,js,svelte,ts}"],
	  safelist: ["dark"],
	  theme: {
	    container: {
	      center: true,
	      padding: "2rem",
	      screens: {
	        "2xl": "1400px",
	      },
	    },
	    extend: {
	      colors: {
	        red: "var(--red)",
	        border: "hsl(var(--border) / <alpha-value>)",
	        input: "hsl(var(--input) / <alpha-value>)",
	        ring: "hsl(var(--ring) / <alpha-value>)",
	        background: "hsl(var(--background) / <alpha-value>)",
	        foreground: "hsl(var(--foreground) / <alpha-value>)",
	        primary: {
	          DEFAULT: "hsl(var(--primary) / <alpha-value>)",
	          foreground: "hsl(var(--primary-foreground) / <alpha-value>)",
	        },
	        secondary: {
	          DEFAULT: "hsl(var(--secondary) / <alpha-value>)",
	          foreground: "hsl(var(--secondary-foreground) / <alpha-value>)",
	        },
	        destructive: {
	          DEFAULT: "hsl(var(--destructive) / <alpha-value>)",
	          foreground: "hsl(var(--destructive-foreground) / <alpha-value>)",
	        },
	        muted: {
	          DEFAULT: "hsl(var(--muted) / <alpha-value>)",
	          foreground: "hsl(var(--muted-foreground) / <alpha-value>)",
	        },
	        accent: {
	          DEFAULT: "hsl(var(--accent) / <alpha-value>)",
	          foreground: "hsl(var(--accent-foreground) / <alpha-value>)",
	        },
	        popover: {
	          DEFAULT: "hsl(var(--popover) / <alpha-value>)",
	          foreground: "hsl(var(--popover-foreground) / <alpha-value>)",
	        },
	        card: {
	          DEFAULT: "hsl(var(--card) / <alpha-value>)",
	          foreground: "hsl(var(--card-foreground) / <alpha-value>)",
	        },
	      },
	      borderRadius: {
	        lg: "var(--radius)",
	        md: "calc(var(--radius) - 2px)",
	        sm: "calc(var(--radius) - 4px)",
	      },
	      preflight: {
	        // Import Inter font
	        '@import': `url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap')`,
	      },
	      fontFamily: {
	        sans: ["Inter", "InterVariable", ...defaultTheme_1.fontFamily.sans],
	      },
	    },
	  },
	};

	const twPreset = presetTailwind();

	// Add specific apply from app.pcss and tailwind.config.js since that's not working
	twPreset.preflight["*"] = {
	  borderColor: "hsl(240 3.7% 15.9% / 1)",
	};

	var config = defineConfig({
	  presets: [twPreset],
	  darkMode: "class",
	  ...config$1,
	});

	(function () {

	    if (typeof document === 'undefined' || 'adoptedStyleSheets' in document) { return; }

	    var hasShadyCss = 'ShadyCSS' in window && !ShadyCSS.nativeShadow;
	    var bootstrapper = document.implementation.createHTMLDocument('');
	    var closedShadowRootRegistry = new WeakMap();
	    var _DOMException = typeof DOMException === 'object' ? Error : DOMException;
	    var defineProperty = Object.defineProperty;
	    var forEach = Array.prototype.forEach;

	    var importPattern = /@import.+?;?$/gm;
	    function rejectImports(contents) {
	        var _contents = contents.replace(importPattern, '');
	        if (_contents !== contents) {
	            console.warn('@import rules are not allowed here. See https://github.com/WICG/construct-stylesheets/issues/119#issuecomment-588352418');
	        }
	        return _contents.trim();
	    }
	    function isElementConnected(element) {
	        return 'isConnected' in element
	            ? element.isConnected
	            : document.contains(element);
	    }
	    function unique(arr) {
	        return arr.filter(function (value, index) { return arr.indexOf(value) === index; });
	    }
	    function diff(arr1, arr2) {
	        return arr1.filter(function (value) { return arr2.indexOf(value) === -1; });
	    }
	    function removeNode(node) {
	        node.parentNode.removeChild(node);
	    }
	    function getShadowRoot(element) {
	        return element.shadowRoot || closedShadowRootRegistry.get(element);
	    }

	    var cssStyleSheetMethods = [
	        'addRule',
	        'deleteRule',
	        'insertRule',
	        'removeRule',
	    ];
	    var NonConstructedStyleSheet = CSSStyleSheet;
	    var nonConstructedProto = NonConstructedStyleSheet.prototype;
	    nonConstructedProto.replace = function () {
	        return Promise.reject(new _DOMException("Can't call replace on non-constructed CSSStyleSheets."));
	    };
	    nonConstructedProto.replaceSync = function () {
	        throw new _DOMException("Failed to execute 'replaceSync' on 'CSSStyleSheet': Can't call replaceSync on non-constructed CSSStyleSheets.");
	    };
	    function isCSSStyleSheetInstance(instance) {
	        return typeof instance === 'object'
	            ? proto$1.isPrototypeOf(instance) ||
	                nonConstructedProto.isPrototypeOf(instance)
	            : false;
	    }
	    function isNonConstructedStyleSheetInstance(instance) {
	        return typeof instance === 'object'
	            ? nonConstructedProto.isPrototypeOf(instance)
	            : false;
	    }
	    var $basicStyleElement = new WeakMap();
	    var $locations = new WeakMap();
	    var $adoptersByLocation = new WeakMap();
	    var $appliedMethods = new WeakMap();
	    function addAdopterLocation(sheet, location) {
	        var adopter = document.createElement('style');
	        $adoptersByLocation.get(sheet).set(location, adopter);
	        $locations.get(sheet).push(location);
	        return adopter;
	    }
	    function getAdopterByLocation(sheet, location) {
	        return $adoptersByLocation.get(sheet).get(location);
	    }
	    function removeAdopterLocation(sheet, location) {
	        $adoptersByLocation.get(sheet).delete(location);
	        $locations.set(sheet, $locations.get(sheet).filter(function (_location) { return _location !== location; }));
	    }
	    function restyleAdopter(sheet, adopter) {
	        requestAnimationFrame(function () {
	            adopter.textContent = $basicStyleElement.get(sheet).textContent;
	            $appliedMethods
	                .get(sheet)
	                .forEach(function (command) {
	                return adopter.sheet[command.method].apply(adopter.sheet, command.args);
	            });
	        });
	    }
	    function checkInvocationCorrectness(self) {
	        if (!$basicStyleElement.has(self)) {
	            throw new TypeError('Illegal invocation');
	        }
	    }
	    function ConstructedStyleSheet() {
	        var self = this;
	        var style = document.createElement('style');
	        bootstrapper.body.appendChild(style);
	        $basicStyleElement.set(self, style);
	        $locations.set(self, []);
	        $adoptersByLocation.set(self, new WeakMap());
	        $appliedMethods.set(self, []);
	    }
	    var proto$1 = ConstructedStyleSheet.prototype;
	    proto$1.replace = function replace(contents) {
	        try {
	            this.replaceSync(contents);
	            return Promise.resolve(this);
	        }
	        catch (e) {
	            return Promise.reject(e);
	        }
	    };
	    proto$1.replaceSync = function replaceSync(contents) {
	        checkInvocationCorrectness(this);
	        if (typeof contents === 'string') {
	            var self_1 = this;
	            $basicStyleElement.get(self_1).textContent = rejectImports(contents);
	            $appliedMethods.set(self_1, []);
	            $locations.get(self_1).forEach(function (location) {
	                if (location.isConnected()) {
	                    restyleAdopter(self_1, getAdopterByLocation(self_1, location));
	                }
	            });
	        }
	    };
	    defineProperty(proto$1, 'cssRules', {
	        configurable: true,
	        enumerable: true,
	        get: function cssRules() {
	            checkInvocationCorrectness(this);
	            return $basicStyleElement.get(this).sheet.cssRules;
	        },
	    });
	    defineProperty(proto$1, 'media', {
	        configurable: true,
	        enumerable: true,
	        get: function media() {
	            checkInvocationCorrectness(this);
	            return $basicStyleElement.get(this).sheet.media;
	        },
	    });
	    cssStyleSheetMethods.forEach(function (method) {
	        proto$1[method] = function () {
	            var self = this;
	            checkInvocationCorrectness(self);
	            var args = arguments;
	            $appliedMethods.get(self).push({ method: method, args: args });
	            $locations.get(self).forEach(function (location) {
	                if (location.isConnected()) {
	                    var sheet = getAdopterByLocation(self, location).sheet;
	                    sheet[method].apply(sheet, args);
	                }
	            });
	            var basicSheet = $basicStyleElement.get(self).sheet;
	            return basicSheet[method].apply(basicSheet, args);
	        };
	    });
	    defineProperty(ConstructedStyleSheet, Symbol.hasInstance, {
	        configurable: true,
	        value: isCSSStyleSheetInstance,
	    });

	    var defaultObserverOptions = {
	        childList: true,
	        subtree: true,
	    };
	    var locations = new WeakMap();
	    function getAssociatedLocation(element) {
	        var location = locations.get(element);
	        if (!location) {
	            location = new Location(element);
	            locations.set(element, location);
	        }
	        return location;
	    }
	    function attachAdoptedStyleSheetProperty(constructor) {
	        defineProperty(constructor.prototype, 'adoptedStyleSheets', {
	            configurable: true,
	            enumerable: true,
	            get: function () {
	                return getAssociatedLocation(this).sheets;
	            },
	            set: function (sheets) {
	                getAssociatedLocation(this).update(sheets);
	            },
	        });
	    }
	    function traverseWebComponents(node, callback) {
	        var iter = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT, function (foundNode) {
	            return getShadowRoot(foundNode)
	                ? NodeFilter.FILTER_ACCEPT
	                : NodeFilter.FILTER_REJECT;
	        },
	        null, false);
	        for (var next = void 0; (next = iter.nextNode());) {
	            callback(getShadowRoot(next));
	        }
	    }
	    var $element = new WeakMap();
	    var $uniqueSheets = new WeakMap();
	    var $observer = new WeakMap();
	    function isExistingAdopter(self, element) {
	        return (element instanceof HTMLStyleElement &&
	            $uniqueSheets.get(self).some(function (sheet) { return getAdopterByLocation(sheet, self); }));
	    }
	    function getAdopterContainer(self) {
	        var element = $element.get(self);
	        return element instanceof Document ? element.body : element;
	    }
	    function adopt(self) {
	        var styleList = document.createDocumentFragment();
	        var sheets = $uniqueSheets.get(self);
	        var observer = $observer.get(self);
	        var container = getAdopterContainer(self);
	        observer.disconnect();
	        sheets.forEach(function (sheet) {
	            styleList.appendChild(getAdopterByLocation(sheet, self) || addAdopterLocation(sheet, self));
	        });
	        container.insertBefore(styleList, null);
	        observer.observe(container, defaultObserverOptions);
	        sheets.forEach(function (sheet) {
	            restyleAdopter(sheet, getAdopterByLocation(sheet, self));
	        });
	    }
	    function Location(element) {
	        var self = this;
	        self.sheets = [];
	        $element.set(self, element);
	        $uniqueSheets.set(self, []);
	        $observer.set(self, new MutationObserver(function (mutations, observer) {
	            if (!document) {
	                observer.disconnect();
	                return;
	            }
	            mutations.forEach(function (mutation) {
	                if (!hasShadyCss) {
	                    forEach.call(mutation.addedNodes, function (node) {
	                        if (!(node instanceof Element)) {
	                            return;
	                        }
	                        traverseWebComponents(node, function (root) {
	                            getAssociatedLocation(root).connect();
	                        });
	                    });
	                }
	                forEach.call(mutation.removedNodes, function (node) {
	                    if (!(node instanceof Element)) {
	                        return;
	                    }
	                    if (isExistingAdopter(self, node)) {
	                        adopt(self);
	                    }
	                    if (!hasShadyCss) {
	                        traverseWebComponents(node, function (root) {
	                            getAssociatedLocation(root).disconnect();
	                        });
	                    }
	                });
	            });
	        }));
	    }
	    Location.prototype = {
	        isConnected: function () {
	            var element = $element.get(this);
	            return element instanceof Document
	                ? element.readyState !== 'loading'
	                : isElementConnected(element.host);
	        },
	        connect: function () {
	            var container = getAdopterContainer(this);
	            $observer.get(this).observe(container, defaultObserverOptions);
	            if ($uniqueSheets.get(this).length > 0) {
	                adopt(this);
	            }
	            traverseWebComponents(container, function (root) {
	                getAssociatedLocation(root).connect();
	            });
	        },
	        disconnect: function () {
	            $observer.get(this).disconnect();
	        },
	        update: function (sheets) {
	            var self = this;
	            var locationType = $element.get(self) === document ? 'Document' : 'ShadowRoot';
	            if (!Array.isArray(sheets)) {
	                throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + locationType + ": Iterator getter is not callable.");
	            }
	            if (!sheets.every(isCSSStyleSheetInstance)) {
	                throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + locationType + ": Failed to convert value to 'CSSStyleSheet'");
	            }
	            if (sheets.some(isNonConstructedStyleSheetInstance)) {
	                throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + locationType + ": Can't adopt non-constructed stylesheets");
	            }
	            self.sheets = sheets;
	            var oldUniqueSheets = $uniqueSheets.get(self);
	            var uniqueSheets = unique(sheets);
	            var removedSheets = diff(oldUniqueSheets, uniqueSheets);
	            removedSheets.forEach(function (sheet) {
	                removeNode(getAdopterByLocation(sheet, self));
	                removeAdopterLocation(sheet, self);
	            });
	            $uniqueSheets.set(self, uniqueSheets);
	            if (self.isConnected() && uniqueSheets.length > 0) {
	                adopt(self);
	            }
	        },
	    };

	    window.CSSStyleSheet = ConstructedStyleSheet;
	    attachAdoptedStyleSheetProperty(Document);
	    if ('ShadowRoot' in window) {
	        attachAdoptedStyleSheetProperty(ShadowRoot);
	        var proto = Element.prototype;
	        var attach_1 = proto.attachShadow;
	        proto.attachShadow = function attachShadow(init) {
	            var root = attach_1.call(this, init);
	            if (init.mode === 'closed') {
	                closedShadowRootRegistry.set(this, root);
	            }
	            return root;
	        };
	    }
	    var documentLocation = getAssociatedLocation(document);
	    if (documentLocation.isConnected()) {
	        documentLocation.connect();
	    }
	    else {
	        document.addEventListener('DOMContentLoaded', documentLocation.connect.bind(documentLocation));
	    }

	}());

	class OnlookToolbar extends HTMLElement {
	    constructor() {
	        super();
	        // Attaches a shadow DOM
	        const shadowRoot = this.attachShadow({ mode: 'open' });
	        // Add twind styles
	        const sheet = cssom(new CSSStyleSheet());
	        shadowRoot.adoptedStyleSheets = [sheet.target];
	        observe(twind(config, sheet), shadowRoot);
	        // Initialize Svelte app in the shadow root
	        new App({
	            target: shadowRoot
	        });
	    }
	    connectedCallback() {
	        this.style.position = 'fixed';
	        this.style.zIndex = '9999';
	    }
	}
	// Define the new element
	customElements.define(ONLOOK_TOOLBAR, OnlookToolbar);

})();
